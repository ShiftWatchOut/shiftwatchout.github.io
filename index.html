<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Watchout的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Watchout的博客">
<meta property="og:url" content="https://shiftwatchout.github.io/index.html">
<meta property="og:site_name" content="Watchout的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Watchout的博客">
  
    <link rel="alternate" href="/atom.xml" title="Watchout的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Watchout的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shiftwatchout.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-用VS-Codeb运行其中写好的C-文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/用VS-Codeb运行其中写好的C-文件/" class="article-date">
  <time datetime="2019-07-14T03:07:07.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/用VS-Codeb运行其中写好的C-文件/">用VS Codeb运行其中写好的C++文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>VS Code 具有良好的代码补全、简洁的页面和丰富的插件。作为从前端入坑编程，开始使用 VS Code 的人，目前有了使用 C++ 的需要，想仅使用 VS Code 就满足日常的 C++ 学习需求。</p>
<h4 id="下载编译器"><a href="#下载编译器" class="headerlink" title="下载编译器"></a>下载编译器</h4><p>VS Code 仅仅是一个文本编辑器，并非一个 IDE，它没有运行 C++ 所必要的编译器，这里我选择 Mingw-w64 作为编译器，前往<a href="https://mingw-w64.org/doku.php/download" title="官网下载页面" target="_blank" rel="noopener">官网</a>选择所需版本下载。</p>
<p>下载好安装程序后，第二项选择 <code>x86_64</code>，其它选项可不改动，然后一路 <code>next</code> 下去。</p>
<p><img src="https://images2017.cnblogs.com/blog/341522/201801/341522-20180115191945506-2090768460.png" alt="POSIX"></p>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>如此安装好了之后，并不能直接在任何文件夹下直接编译运行 C++ 程序，还需要设置环境变量。用 <code>gcc -v</code> 或 <code>g++ -v</code> 检验编译器是否在安装文件夹之外可用。假设你的安装文件夹为 E 盘根目录</p>
<ul>
<li>在 <code>系统变量</code> 的 <code>Path</code> 变量中添加 <code>E:\mingw64\bin</code> 值，</li>
<li>在 <code>系统变量</code> 中添加新变量，名为 <code>C_INCLUDE_PATH</code> ，并将值设为 <code>E:\mingw64\include</code>，</li>
<li>在 <code>系统变量</code> 中添加新变量，名为 <code>CPLUS_INCLUDE_PATH</code> ，并将值设为 <code>E:\mingw64\include</code> 。</li>
</ul>
<p>环境变量设置完成之后，运行 <code>gcc -v</code> 或 <code>g++ -v</code> 命令则会得到一大串关于编译器的版本信息。</p>
<h4 id="VS-Code-插件"><a href="#VS-Code-插件" class="headerlink" title="VS Code 插件"></a>VS Code 插件</h4><p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++</a>、<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a>。</p>
<p>Code Runner 可以一键运行工作文件夹下的对应 CPP/C 文件，也就是代替人打出冗长的编译运行命令。对于本人的学习需求已经足够了，而且还很方便。</p>
<p><strong>参考链接：</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/54861567" title="[VSCode插件推荐] Code Runner: 代码一键运行，支持超过40种语言" target="_blank" rel="noopener">Code Runner 插件作者知乎文章</a><br><a href="https://www.cnblogs.com/findumars/p/8289454.html" title="在Windows中安装MinGW-w64" target="_blank" rel="noopener">网友的 MinGW-W64 安装图文教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/07/14/用VS-Codeb运行其中写好的C-文件/" data-id="cjy2fdnuv0009d0orj6i0o7vq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ubuntu-using" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/08/Ubuntu-using/" class="article-date">
  <time datetime="2019-06-08T12:55:27.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/Ubuntu-using/">Ubuntu using</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><p>目前最受推荐的便是使用系统自带包管理器来安装。</p>
<p>先设置包管理器的源</p>
<p><code>$ sudo vim /etc/apt/sources.list.d/nodesource.list</code></p>
<p>使用下方的源来代替源内的 URL</p>
<p><code>https://mirrors.ustc.edu.cn/nodesource/deb/node_{版本号，例如: 10}.x</code></p>
<p>然后</p>
<p><code>$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</code></p>
<p>更新 APT 源</p>
<p><code>$ sudo apt-get update</code></p>
<p>通过 APT 安装</p>
<p><code>$ sudo apt-get install -y nodejs</code></p>
<p>检查 nodejs 版本</p>
<p><code>$ node -v</code></p>
<p>升级 node 至最新 LTS 版本：将上面 <code>curl</code> 那一步的 node 版本改为最新的稳定版，源里的 URL 会被自动更改，再更新 APT 源，然后使用更新命令，</p>
<p><code>$ sudo apt upgrade</code></p>
<p>升级后清理掉旧版本。</p>
<p><code>$ sudo apt autoclean</code></p>
<p>本地使用 mongo 前先启动服务，不然进不了命令行工具，然后 <code>mongo</code></p>
<p><code>sudo service mongod start</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/06/08/Ubuntu-using/" data-id="cjy2fdnue0001d0ormboq2l4k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-Cargo-Sorting-DNA-Robot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/08/译-Cargo-Sorting-DNA-Robot/" class="article-date">
  <time datetime="2019-06-08T12:55:04.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/译-Cargo-Sorting-DNA-Robot/">译-Cargo Sorting DNA Robot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a href="https://science.sciencemag.org/content/357/6356/eaan6558" title="A Cargo-sorting Robot" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<blockquote>
<p><strong>Abstract</strong><br>分子机器人的设计和合成中的两个关键挑战是模块化和算法简单性。我们展示了三个模块化构建模块，用于 DNA 机器人，在分子水平上进行货物分类。通过硬编码货物与其目的地之间识别的简单算法来简化机器人设计：设计为有一条腿和两只脚用于行走的单链 DNA ，以及用于拾取和放下货物的一条臂和一个手。机器人探索 DNA 折纸平面上的测试场，拾取最初处于无序位置的两种类型的多个货物，并将它们运送到各自指定的目的地，直到所有分子分成两个不同的堆。机器人被设计为在不提供任何能量的情况下随机行走。利用此功能，一个机器人可以重复排序多个货物。将机器人局限于 DNA 折纸上允许在一个试管中同时进行不同的货物分拣任务，或者允许多个机器人共同执行相同的任务。</p>
</blockquote>
<p>执行机械任务的分子机器是所有生物有机体中的关键功能组件。自动执行复杂的纳米机械任务，同时与其环境互动的可编程分子机器人的设计，目前在分子工程中面临着两个关键挑战，即模块化和算法简单性。</p>
<p>在机电机器人中模块化的重要性最初建立于 20 世纪 70 年代。模块化机器人可以是自适应的，可以自我修复，并且只使用一些组件就能执行各种任务。例如，长期太空任务需要机器人在自主操作期间处理不可预见的情况。模块化对于分子机器人来说也很重要，不仅因为在它们运行的​​生物化学环境中存在许多不可预见的情况，而且因为开发针对特定任务而定制的新分子机器人需要大量的努力。在最近发展的蛋白质马达已经显示模块化的潜力，例如，由已知基序的蛋白质中创造出新的功能。</p>
<p>复杂的单个分子难以合成，并且更难以赋予精确控制的动力学和机械性质。因此，算法越简单，就越可能被简单分子执行，分子的合成也越简单，实验就越有可能成功。简单的算法可以产生复杂的功能，包括图灵通用计算。对蚂蚁和白蚁等社会性昆虫行为的研究表明，能力有限的个体可以完成复杂的任务。他们的行为为复杂的工程挑战提供了简单而强大的解决方案。</p>
<p>我们现在展示的是，一个简单的算法可以使一个简单的 DNA 机器人在二维（2D） DNA 折纸表面上执行复杂的货物分类任务。该系统使用三个可相互组合的构建块，可用于货物分拣以外的各种功能。</p>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>化学合成的小DNA分子是模块化设计的天然构件，因为连续的核苷酸区段可以作为杂交或链置换中的独立结构。人们已经设计并合成了由DNA分子制成的各种机械装置，包括镊子，聚合物马达和旋转装置。DNA机器人已经从非自主，发展到独立（13 - 16），并从走在指定方向，到可以转弯，选择岔路，拾取货物，并在微粒表面上行走。</p>
<p>我们选择货物分拣作为示例任务，因为该功能比先前的DNA机器人能够执行的功能复杂得多，在算法上是有趣的，并且在许多生物和工程系统中起着至关重要的作用。例如，在神经元中，不同的蛋白质，包括神经递质受体和离子通道，在细胞体中的相同位置合成，但被递送到轴突和树突中的不同位置。在蚁群中，工蚁通过在中心区域聚集卵和微型幼虫并按照大小增加的顺序将较大的幼虫推离中心来对它们的巢进行分类。排序也是计算机科学和工程中最基本的技术之一。已经开发了各种排序算法来优化数据处理。按顺序排列项目，无论它们是信息还是物理对象，都可以更轻松地完成许多其他任务，包括搜索和比较。</p>
<p>开发一种在DNA折纸表面进行货物分类的机器人有两个主要原因，而不仅仅是让货物分子在溶液中扩散到目的地。首先，货物的初始和最终几何位置可以是分拣任务的一个整体组成部分。例如，如果树突膜蛋白被错误地递送到神经元的轴突，它们就可以结合在轴突膜并导致轴突具有树突特性，从而失去其特性。其次，在自己的测试区域上工作的各个机器人的几何分离使得可以并行地进行不同的货物分拣任务并且使多个机器人共同执行相同的任务。DNA 折纸表面的定位提供了一些与生物学中的区域化分隔相同的益处，其中膜允许单个细胞并行地执行不同的局部功能，并且细胞之间的通信随后在生物体内执行复杂的全局功能。</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>货物分拣的任务定义如下：最初，每种类型具有多个分子的两种或更多种分子被放置在有限尺寸的2D空间中。这些分子的位置可以是任意的。机器人应该能够搜索整个空间，拾取任何类型的分子，并将每种类型传送到指定的目的地，直到所有分子分成不同的堆（图1A）。</p>
<p><img src="https://science.sciencemag.org/content/sci/357/6356/eaan6558/F2.large.jpg" alt="图1：货物分拣算法" title="图1：货物分拣算法"></p>
<p><em>（A）在任意指定的目的地将任意分布的分子分类成不同的堆的示意图。（B）简单货物分拣算法的流程图。在分子实现中，拾取和放下货物的选择并不总是按设计进行 - 机器人有较小的概率返回随机行走。（C）随机行走，（D）货物拾取和（E）放下货物的三个构件的机制。（F）三个构件的可组合性。三种类型的轮廓突出显示了三个构建块中使用的组件。（G.）分类多种货物的实施。波浪线表示短的立足结构，直线表示DNA链中的长链迁移结构，箭头标记其3’末端。</em></p>
<p>如果我们不受单个分子的能力限制，则需要以下简单有效的算法。机器人系统地探索相关领域。如果碰到货物，机器人将捡起货物，识别货物类型，选择指向该货物类型的指定目的地的路径，并将其放在目的地。然后，机器人将重复该过程，直到所有货物都被分拣。为了实现该算法，机器人将需要具有存储器，用于记录自己去过哪里，识别各种类型的货物，以及用于选择指向各个目的地的不同路径的处理。这些功能要求构成机器人的分子能够进行信息处理，并且具有更多类型货物的货物分拣任务将需要内置于机器人中的更复杂的信息处理电路。</p>
<p>为了实现一种实际可用的分子，我们开发了一种简单得多的算法（图1B），类似于在集体机器人学中受蚂蚁启发的排序算法，其中机器人执行随机游走。如果撞到货物，机器人会捡起它并继续随机行走。如果碰到货物的指定目的地的目标，机器人将把它甩掉。然后，机器人将重复该过程，直到所有货物都被分拣。为了实现这种算法，机器人只需要能够随机行走，拾取货物并将其丢弃。机器人既不会识别货物类型，也不会识别目的地类型。目标将识别匹配的货物并迫使机器人将其丢弃。随着货物类型的增长，机器人分子的复杂度将保持不变。只要每种类型的货物和目标之间的识别具有足够的特异性，货物和目标分子的复杂度也将保持不变。</p>
<p>使用DNA链置换反应（8，29，30）中，我们开发了三个模块化构件换随机游走，货物拾取，和货物脱落-以实现简单货物排序算法。为了在轨道上进行随机游走，设计了单链 DNA 机器人，各自含有6个核苷酸的两个足和一个含有15个核苷酸的一个腿（图1C）。该轨道由2D DNA折纸表面上的许多单链延伸组成。每个轨道链通过与机器人互补的脚和腿与机器人结合，留下机器人的另一个脚空出来。机器人通过可逆链置换反应从轨道上的一个位置移动到另一个位置。机器人的自由足首先与相邻轨道链的互补足结合。当两个相邻轨道股的互补腿部区域彼此竞争以结合到机器人的腿部时，发生分支迁移。当分支迁移进行到腿部的末尾时，机器人的先前绑定的足将解除关联，从而机器人从先前位置移动一步。有两种类型的轨道线以棋盘图案排列：每个都绑定到机器人的3’端或5’端的一英尺域。机器人应该能够在无偏差的情况下从轨道上的任何位置向任何相邻位置迈出一步，因为所有相邻位置的轨道都是相同且等距的。</p>
<p>用手臂和手扩展单链 DNA 机器人使它能拾取货物（图1D）。货物分子可以是 DNA 链，称为货物链，或与货物链的3’末端缀合的任何分子。在这里，我们使用荧光团或 DNA 链本身作为货物。货物链具有与机器人互补的手和臂。它最初与 DNA 折纸表面结合，同时互补的手暴露在外。如果机器人位于货物链的相邻位置，它将通过不可逆的链置换反应来拾取货物。通过结合手域启动反应，并通过臂结构域内的分支迁移完成反应。因为机器人的手臂和手臂域在反应结束时都会变成双股，所以机器人在携带货物时不能拿起另一个货物。货物装好后，货物的原始位置现在被认为是惰性的。这种状态变化的发生是因为单独的臂结构，没有手，不能与系统中的任何其他分子相互作用。足部和腿部区独立于手和臂起作用，因此，无论机器人是否携带货物，机器人都应该能够随机行走。</p>
<p>在货物链上添加货物段以允许卸货（图1E）。DNA 折纸表面上的目标链设计为具有手，臂和货物端的互补链。机器人通过不可逆的链置换反应来卸下货物，类似于货物拾取。通过货物链和目标链之间的货物的结合来启动反应，并且通过臂和手的链迁移来完成反应。通过这种方式，目的地主动从机器人抓取货物。货物卸下后，货物和目标区域内的所有区域都是双链的，因此在目的地不会再发生任何反应。没有了货物，机器人现在可以自由探索折纸表面上的其他位置并拾取另一个货物。</p>
<p>在三个构件中的每一个中使用的DNA链和链中的结构域可彼此直接组合（图1F）。因此，货物分拣机制简单地结合了随机行走，拾取货物和放下货物的机制。为了对多种类型的货物进行分类，我们只需要确保每种类型的货物和目标链具有独特的货物区域（图1G）。</p>
<h3 id="Random-Walk"><a href="#Random-Walk" class="headerlink" title="Random Walk"></a>Random Walk</h3><p>为了获得随机游走构建模块的定量理解，并将其与随机游走理论的基本特性进行比较，我们先在 DNA 折纸表面上使用线性轨迹进行实验演示（图2A）。为了减少机器人在轨道上任何位置卡住的可能性（如果缺少履带），我们将轨道设计为三个点的宽度。为了确定机器人行进一定距离所需的时间，我们指定了的起点和终点。机器人在起始位置等待，直到触发信号被引入，并且一旦到达目的地就停止行走。</p>
<p><img src="https://science.sciencemag.org/content/sci/357/6356/eaan6558/F3.large.jpg" alt="图2：随机游走构建块" title="图2：随机游走构建块"></p>
<p><em>（A）双层DNA折纸上的八步长轨道的3D和2D示意图。相邻轨道位置之间的线指示机器人的可能移动：两种类型的轨道线是棋盘图案，并且对于每个步骤，机器人只能在两种不同类型的轨道之间移动。因此，六边形网格在功能上就是机器人运动的方形网格（图S4A）。（B）仅在实验开始时保护机器人免于与轨道相互作用并激活机器人的机制。通过使用比抑制机器人高20倍的触发链，激活反应向前偏向。（C）机器人到达目标位置的机制。（D.）具有长度为8个单位的轨道的双层 DNA 折纸的 AFM 图像。（E）具有八个不同轨道长度的随机游走实验的荧光动力学数据和没有轨道的空白对照。在实验结束时添加相对于折纸浓度20倍过量的自由浮动机器人以测量最大可能的完成度。将三分之二的完成时间（T<sub>2/3</sub>）相对于轨道长度（l）绘制。二次函数的最小二乘拟合是T <sub>2/3</sub> = 0.38 + 0.055× l <sup>2</sup>。（F.）随机游走和空白对照的质量动作模拟。在该模型中，机器人从任意轨道位置行进到其相邻位置，k<sub>w</sub> = 3.5×10 <sup>-3</sup> s <sup>-1</sup>。最初禁用机器人并在k<sub>t</sub> = 3.2×10 <sup>4</sup> M <sup>-1</sup> s <sup>-1</sup>处触发。这两个速率常数是根据从实验数据获得的三分之二完成时间与轨道长度的二次拟合确定的。阴性对照用机器人在一个DNA折纸上模拟，与另一个相互作用，k<sub>s</sub> = 5×10 <sup>2</sup> M <sup>-1</sup>s <sup>-1</sup>。</em></p>
<p>尽管步行时不需要手和手臂，但我们使用它们来设计抑制器，迫使机器人在起始位置等待（图2B）。除了保持其与机器人稳定结合的互补的手臂和手臂区域之外，抑制剂链还具有互补的足以覆盖未连接到轨道的机器人的足部。因此，机器人不能在没有自由脚的情况下开始行走。抑制剂链还具有触发域，其可以结合自由的触发链并允许其激活机器人。触发链通过可逆链置换反应从机器人中去除抑制器 - 触发器没有手，因此，激活的机器人仍然可以与触发器和抑制剂复合物相互作用以逆转反应。如果触发线具有手域，它将像机器人一样拾取任何货物。因为我们想控制机器人的激活，不仅用于随机行走，还用于货物分拣，我们决定省略手域，而使用过量的触发链来激活反应。</p>
<p>为了让机器人在目的地停止行走，我们设计了一个类似于轨道链但具有两个互补脚域的目标链。在到达目标时，机器人将没有脚来采取进一步的步骤（图2C）。为了监测在目标位置有机器人的 DNA 折纸的分数，我们用淬灭器标记机器人的3’端，并用荧光团标记与目标相邻的钉的5’端。有和没有机器人的目标位置应分别产生低和高荧光状态。</p>
<p>有三个主要观察结果导致我们的设计选择和制作机器人成功随机行走的实验程序：（i） DNA 折纸作为机器人试验场的刚性会引发不良反应；（ii）机器人足区的 DNA 序列影响行走速度；（iii） DNA 折纸的纯度影响所需反应的完成水平。</p>
<p>我们首先使用单层矩形 DNA 折纸为DNA机器人建立一个试验场（图S1A）。在随机游走的空白对照实验中，机器人被放置在远离目标的不同距离处，但没有提供轨道 - 我们发现一小部分机器人仍然达到了目标（图S1B）。更令人惊讶的是，尽管最近的距离已经比机器人和目标之间设计的可到达距离的距离已经三倍，但是机器人越靠近目标越近，不期望的相互作用就越大。我们期望一个折纸上的目标可以与另一个折纸上的机器人互动，但如果折纸之间的相互作用是唯一的解释，我们就不会期望相互作用水平与机器人和目标之间的距离之间存在任何相关性。从而，我们假设，由于单层折纸的结构灵活性，同一折纸中的相互作用也可能在实验中发挥了作用。</p>
<p>我们并不关心折纸之间的相互作用，而是决定重新设计DNA折纸结构以减少折纸内不利的相互作用，原因如下：首先，折纸之间的相互作用可以通过降低折纸浓度来减少，但折纸内的相互作用不能。此外，折纸之间的相互作用可以简单地建模为具有已知浓度和速率常数的双分子反应，但是如果不理解折纸的结构波动如何影响折纸表面上的每个单分子反应的速率，则难以建立在折纸内不利相互作用的模型，从而使得很难预测随机行走和货物分拣的行为。为了解决这些问题，我们设计了一个双层方形 DNA 折纸（图S1D）。因为DNA结构沿着螺旋方向更加刚性并且在通过交叉连接的螺旋之间有些柔性，我们让两个层的螺旋方向彼此垂直以增加折纸的结构刚度。在双层折纸的表面上进行相同的空白对照实验，我们观察到移动到目标的机器人的比例不依赖于机器人和目标之间的距离（图S1E），表明相互作用在折纸内显著减少。单层和双层折纸之间结构灵活性的差异也与 CanDo 模拟（图S1，C和F）一致。</p>
<p>接下来，我们探索了机器人足部域的两个 DNA 序列选择：一个用于两个脚的两个不同的序列（图S2A），另一个使用相同的（图S2B）。通过一个实验，其中机器人在被触发后执行单个步骤，我们已经观察到两个选择之间的显著速率差异 - 后者更快（图S2C）。我们怀疑更快的反应速率与序列相同没什么关系，但主要是由机器人3’端附近序列的较弱结合能引起的。在这两种情况下，机器人到达目标的链置换反应是不可逆的。对于具有相同引发立足点的不可逆反应，如果反应物分子在溶液中自由漂浮，则速率应相似。然而，研究表明，如果将反应物分子束缚在固定位置，情况可能会有所不同。对于束缚分子，当解离速率变得快于分支迁移速率朝向越来越受约束的几何形状时，链置换反应可能以立足点解离而结束。因此，靠近机器人3’端的足部序列的结合能越弱，解离速率就越快。</p>
<p>我们开发了一种生物物理模型，以更好地理解行走机制，考虑DNA的几何和弹性（笔记S2.3和图S3）。该模型进一步表明，（i）当分支迁移的接合点足够接近表面时，拉伸 DNA 链的熵成本显著减慢了分支迁移到 DNA 折纸表面，和（ii） DNA 序列的标准自由能的微小差异可导致机器人一步完成率的巨大差异。有了这种理解，我们决定使用较弱序列继续推进。</p>
<p>在图S2C所示的一步实验中讲不通的，是反应的完成水平仅为约60％。什么可以阻止机器人走一步？我们假设折纸的纯度可能起了作用：在畸形的折纸结构中，激活的机器人可能仍然远离目标。为了验证这一假设，我们探索了两种净化折纸的方法，并在机器人在不同长度的线性轨道上行走的实验中将它们与未净化的折纸进行比较（图S4，A和B）。离心过滤器净化折纸（图S4D）的结果与未纯化的折纸（图S4C）非常相似，但凝胶纯化的折纸产生了更好的完成水平：接近95％（图S4E）。从凝胶和原子力显微镜（AFM）图像可以明显看出，离心过滤器净化足以去除多余的钉，但不足以去除畸形的折纸结构（图S4F）。因此，我们为后面的所有实验都将凝胶纯化折纸。</p>
<p>使用上述设计选择和实验程序，我们验证了在折纸上形成线性轨迹（图2D），并证明了在长度为1到8步的线性轨迹上的随机行走（图2E）。在理论，的步骤以随机行走的预期数量，这是从起点到长度的路径上的终点的击中时间 n ，是 n <sup>2</sup>。数值分析表明，可以直接从实验数据中获得的三分之二完成时间应该与预期的时间相似（笔记S2.5和图S5）。在我们的数据中，三分之二的完成时间与轨道的长度呈二次方相关（图2E，插图）。拟合二次函数中的常数项取决于激活机器人的时间和实际是三个单位宽度的轨道。</p>
<p>我们模拟了宽度为3的轨道上的激活和随机游走反应（图2F）。通过将三分之二的完成时间与实验数据进行比较来确定两个反应的速率常数。在机器人行走一步大约5分钟，步长6纳米，这类似于上折纸其他自治 DNA 电动机。在折纸上与机器人的抑制器相互作用的自由浮动触发链的速率比两个自由浮动分子之间的类似链置换反应慢约100倍，但与在折纸表面上测量的其他杂交和链置换速率相当。我们还模拟了空白对照 - 机器人在一个折纸上与另一个折纸相互作用而没有任何轨道的反应。这种折纸间相互作用的速率被确定为比机器人激活的反应慢大约100倍，可能是由于两种反应物的缓慢扩散速率和在碰撞事件期间分子定位以启动所需反应的概率降低所致。</p>
<h3 id="Cargo-sorting"><a href="#Cargo-sorting" class="headerlink" title="Cargo-sorting"></a>Cargo-sorting</h3><p>第二个构件，货物拾取器，与随机行走构件一起直接组成（图S6A）。因为抑制剂链不仅覆盖了行走的足部区域，而且还覆盖了用于货物拾取的手和臂区域，因此使用相同的激活反应来控制实验的开始。在这个设置中，机器人最初放置在 DNA 折纸的中心，折纸表面被轨道线完全覆盖，这样机器人就可以探索整个2D测试场。三个相同类型的货物最初位于折纸的一个边缘附近。一旦激活，机器人就开始随机行走，当它碰到一个货物时拿起货物，在运载货物时继续行走。缺乏卸货功能，机器人应该只能拿起一个货物，而将其他两个货物留在他们的初始位置。正如预期的那样，货物拣选的完成水平为27％，略低于三分之一（图S6B）。机器人还能够拾取标有不同荧光团的第二种货物链（图S6C）。</p>
<p>将卸货构件加入系统需要一种保护目标链的机制；否则，当它们混合在一起，还没装配到各自在折纸表面上的指定目的地进行定位，目标就将直接与货物相互作用（图S7）。设计目标抑制剂比设计机器人抑制剂更具挑战性。手域和货物域都不应该存在于与抑制剂结合的触发链中：臂和手一起将像机器人一样拾取货物，而货物和手臂将像目的地能做的那样拾取货物。因此，我们使用两条抑制剂链而不是一条（图3A）。与机器人激活反应类似，目标激活反应也是可逆的，并且由两个触发线的大量过量向前偏置。在激活之后，如果有机器人在其相邻位置携带匹配的货物，则目标可以从机器人抓取货物。</p>
<p><img src="https://science.sciencemag.org/content/sci/357/6356/eaan6558/F4.large.jpg" alt="图3：货物分拣示范" title="图3：货物分拣示范"></p>
<p><em>（A）保护目标免于与货物相互作用并仅在实验开始时激活目标的机制。所有货物分拣系统中两种类型轨道的布局如图S8A所示。（B）用两种不同类型的货物进行货物分类实验的荧光动力学数据。在初始状态下，货物 1-F 和货物 2-F 表示用荧光团标记的货物，而目标 1-Q 和目标 2-Q 表示用淬灭剂标记的目标。最终状态显示随机选择机器人的位置和未占用的目标。（C）每种类型的货物在其初始位置的 AFM 图像并分别被传送到它们的目标位置。所有图像的比例相同，右下图像中的比例尺为50 nm。</em></p>
<p>在货物分拣设置中，两种类型的六种货物最初位于折纸的一个边缘附近的无序位置，相应类型的八个目标位于相对边缘附近的两个分开的位置（图3B）。由于折纸合成的不完美，因此目标比货物有更多，来避免缺少目标链的可能情况。同样，机器人最初被放置在折纸的中心。两种类型的货物用两种不同的荧光团标记，但只有一种类型的目标用淬灭剂标记。在每个实验中，对于其中一种类型的货物，如果荧光信号在正确的目标位置放下，则荧光信号将减少； 对于另一种类型，只有在不正确的位置掉落时，信号才会减少。这对实验表明，两种类型的货物都在其所需的目的地下降（图3B）。观察到80％的完成水平，可能是因为机器人，货物和目标链中的合成错误抑制了期望的拾取和下落反应以及缺少机器人的不完美折纸的存在。尽管如此，机器人成功地分类了两种类型的货物，每种类型有多个货物。相比之下，没有机器人，货物在折纸处保留在其初始位置（图S8）。</p>
<p>荧光动力学实验提供了对散装货物分类行为的定量理解，但在单个折纸表面上，我们能猜到分子的位置吗？为了解决这个问题，我们进行了图3C所示的 AFM 实验。可视化货物分拣结果的挑战是区分目标货物的双链复合物与单链履带链，以及没有任何货物的部分双链目标。然而，在 AFM 成像中，不可能直接这样做； 因此，我们不得不从折纸表面移除所有没有货物的轨道和目标。因为没有货物的目标暴露了互补的货物区域（图3A），我们设计了一个目标移除链，它与它结合并使目标链远离折纸表面（图S9）。接下来，我们使用外切核酸酶I去除所有单链延伸，包括轨道链。我们将最初的货物地点留作双股，以作为折纸方向的参考。除了在目标的另一侧，这些位置也更接近折纸的右侧。在折纸落在云母上的情况下，我们根据初始货物位置的不对称性翻转图像。两个单独的 AFM 实验，每个实验都有一种类型的货物，但是两种类型的目标，都表明货物被运送到正确的目的地（图3C和图S10）。</p>
<p>为了探索我们系统的并行性，我们在一个试管中设计了两个 DNA 折纸混合群体的实验（图S11）：一个带有机器人而另一个没有。带机器人的折纸有一种用荧光团标记的货物，另一种的货物未经修饰。没有机器人的折纸与货物的标签相反。通过这种设置，如果机器人停留在最初放置的折纸上，将检测到一种货物的分类，而不是另一种。实验结果表明，一小部分（12至14％）的折纸具有不希望的串扰，但大多数情况下，两个折纸群体保持其自身的独立性（图S11）。</p>
<p>为了实际展示并行发生的两个不同的货物分拣任务，我们将机器人放置在 DNA 折纸的两个群体上，但不修饰其中一个的目标（图4A）。通过这种设置，如果两个折纸群保持其自身的独立性，则可以检测两种类型的货物的分类。否则，检测到的活性将显著降低，因为即使使用荧光团标记的货物，向未修饰的目的地的输送也不会产生荧光信号变化。我们确实观察到，与仅仅一个货物分拣群体相比，反应的完成水平比在单个群落上降低了16％至18％（图4A）（图3B）。然而，这种下降仍然远低于50％，相同货物的预期完成水平和目标在一个混合良好的解决方案中相互作用。</p>
<p><img src="https://science.sciencemag.org/content/sci/357/6356/eaan6558/F5.large.jpg" alt="图4：探索DNA折纸混合群体与单个DNA折纸表面上的多个机器人的平行度" title="图4：探索DNA折纸混合群体与单个DNA折纸表面上的多个机器人的平行度"></p>
<p><em>（A）两个DNA折纸混合群体的荧光动力学实验，每个都有两种类型的可以单独分类的货物。（B）将两类货物分类为连续时间马尔可夫链的随机模拟。 Robot <sub>x,y</sub>表示处于任意轨道位置（x，y）的机器人。（x \</em>，y *）是（x，y）的邻近位置。货物 i 和目标 i 分别表示特定类型的货物和目标。d 是（x <sub>1</sub>，y <sub>1</sub>）和（x <sub>2</sub>，y <sub>2</sub>）之间的欧几里德距离。d <sub>Min</sub>是机器人与其邻近位置的货物或目标之间的欧几里德距离。因为在最近的订书钉延伸位置之间有16个碱基对（bp），并且每三个订书钉列有 1-bp 缺失用于折纸扭曲校正，d <sub>Min</sub>计算为（16 × 3 -1）/ 3 bp × 0.34 nm / bp = 5.33 nm。如果距离在可到达的范围内，该模型允许机器人从不是其直接邻居的位置拾取货物（或将货物卸下），但是反应速率随距离呈二次方减小。因为双链足，腿和货物（或目标）附着区域中碱基对的总数是41bp，单链足和接头结构域中核苷酸的总数是16个核苷酸（nt），最大可达距离计算为每bp 41 bp×0.34 nm + 16 nt×0.5 nm / nt = 21.94 nm。随机行走的速度是k <sub>w</sub> = 3.5×10 <sup>-3</sup> s <sup>-1</sup>，最近的货物拾取和下降的速率是k <sub>c</sub> = 100 × k <sub>w</sub>。我们假设只有80％的货物可以成功地运送到目标位置，因为一小部分折纸缺少功能性机器人。该分数基于图3B中所示的实验数据确定。（C）多个机器人共同执行单个货物分拣任务的荧光动力学实验。*</p>
<p>我们建立了一个模型来模拟货物分拣系统（图4B）。轨道上处于任何位置的机器人可以以随机行走模型中确定的相同速率向任何紧邻的位置移动一步（图2F），无论它是否携带货物。如果距离货物或目标到机器人的距离足够，则任何位置的机器人都可以接载或放下货物。足够的距离是根据拾取和下降的链移位反应期间的最紧密连接计算的。我们假设拾取和卸货的最大速率是当货物或目标是机器人的直接邻居时，并且对于任何更远的距离，速率随着距离呈二次方减小。最大载货和卸货速度比步行速度快100倍，模拟（图4B）半定量地再现实验数据（图3B）。模拟表明，机器人平均需要295步才能完成货物分拣任务。</p>
<p>我们还分析了不期望的折纸间相互作用，包括机器人从一个折纸移动到另一个折纸，以及一个折纸机器人或目标在另一个折纸上拾取货物（图S12A）。使用与实验数据拟合的线性最小二乘法，我们确定了每种类型的模型化折纸间相互作用的完成水平（图S12B）。在折纸之间移动的机器人是最不重要的（1.59％），可能是因为与本地轨道股相互作用的可能性很高，而且在另一个折纸上的密集包装轨道股的可达性较低。一个折纸机上的机器人和目标在另一个折纸上拾取货物都更为重要（分别为4.56和8.25％），这可能是因为货物线远离折纸表面并高于轨道线的高度，因此更多无障碍。</p>
<p>最后，为了进一步利用折纸定位实现的并行性，我们展示了由多个机器人共同执行的单一货物分拣任务（图4C）。我们将机器人的初始位置移离货物，以增加货物分拣的难度。我们选择了五个机器人位置，并根据模拟对每个机器人单独对货物进行分类所需的时间进行排序（图S13A）。我们在每个实验中一次增加一个机器人的数量，从模拟预测的最快到最慢的机器人。通过这种方式，如果货物分拣的整体速度随着机器人的增加而增加，则应该是集体行为的结果，而不是任何特别快的机器人。增加机器人的数量将货物分拣的三分之二完成时间从超过10小时减少到不到1小时，并且四个机器人足以以接近最佳速度完成任务（图4C）。</p>
<p>多机器人实验中的一个启发性事实是，越来越多的机器人将完成水平从略低于80％提高到接近100％。这一观察结果排除了货物或目标分子出现故障的可能性，这表明是机器人本身发生故障或者一小部分折纸缺少机器人。如果单个机器人发生故障或丢失的概率为20％，那么使用 m 机器人的实验应该具有1 - 0.2 <sup>m</sup>的完成水平，这与实验数据非常吻合（图4C）。我们模拟了多机器人系统，假设每个机器人正常工作的概率为80％。模拟半定量地捕获实验结果（图S13C）。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>我们开发了一个简单的算法和三个构建块，以构建一个能在分子水平上进行货物分类的 DNA 机器人。我们证明了机器人可以在 DNA 折纸的表面上探索 2D 测试场，拾取最初在无序位置的两种类型的多个货物，并将它们运送到两个不同的目的地。我们还展示了同时在一个试管中进行的两个不同的货物分拣任务，多个机器人共同执行相同的任务。为了通过实验呈现这三个构建模块及其可组合性，我们测试了一系列子系统，这些子系统逐步整合了随机行走的构建块，然后是货物拾取，最后是货物下落。成功实现上一个构建块后，无需对先前设计的组件进行任何更改就可以添加下一个构建块。</p>
<p>原则上，使用完全相同的机器人设计，系统可以在以下方面进行推广：首先，该算法不需要机器人识别货物的类型，而是将识别嵌入目的地，因此，系统可以是适用于两种以上的货物。其次，该算法允许机器人自由探索整个2D测试场，因此货物的初始位置可以是任意的。第三，因为机器人被设计成在没有任何能量供应的情况下进行随机游走，所以应该可以对越来越多的货物进行分类。最后，因为分拣进行在单个折纸表面上，所以可以利用并行性来扩展系统以执行不同任务的许多实例，并且根据任务的难度，可以为每个任务分配不同数量的机器人。</p>
<p>通过努力，可以进一步开发机器人的以下方面。首先，机器人比最快的驱动蛋白电机慢大约100,000倍。根据我们对足部 DNA 序列如何影响行走速度的理解，我们认为通过添加单链尾部可以将速率提高至少100倍，从而提高局部链置换反应的起始速率，通过使用具有较弱结合能的序列（图S3B）。还可以通过使用酶来驱动 DNA 机器人或使用由 DNA 编程的蛋白质马达来进一步提高速率。其次，使用更大和更多样化的测试场地，例如随机 DNA 折纸阵列，可以帮助我们获得改善机器人稳健性的理解。第三，使用适体或直接结合，小化学品，金属纳米颗粒，和蛋白质可作为货物来运输的分子，使得货物分拣可用于化学合成（21，43，44）和分子器件的制造。例如，在化学合成中，一些所需的产物只有当化学基团以正确的顺序连接在一起，才能组装上。因此，货物分拣机器人可以与组装机器人一起工作，从最初随机分布的组件合成期望的产品。在分子装置中，可以触发货物分拣机器人重排诸如纳米颗粒的电路部件，使得装置的功能可以适应环境信号。最后，使分子机器人在生物环境中工作塑成可编程疗法。例如，参与疾病的 microRNA 可以被编程为用于货物分类任务的触发信号，其将蛋白质亚单位聚集在一起以用作药物。</p>
<p>更通常地说，我们的兴趣在于开发简单的算法和模块化构建模块，最终将用于系统构建可执行各种任务的分子机器人。我们相信我们在这里开发的三个构件不仅限于货物分拣任务。例如，受到蚂蚁觅食的启发，添加一个新的构建块，用于在路径上留下类信息素信号，可以对 DNA 机器人进行编程，以找到最短的路径并有效地运输货物分子。通过机器人之间的简单通信，他们可以执行更复杂的任务。类似于折纸表面上 DNA 链置换反应可以用于构建任意逻辑电路和化学反应网络，应该也可以制造一小组 DNA 链置换构建块，包括在这项工作中的那些，以执行在某个确定框架内定义的任意机械任务。通过系统化方法，分子机器人可以像宏观机器人一样轻松编程，但在微观环境中工作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/06/08/译-Cargo-Sorting-DNA-Robot/" data-id="cjy2fdnv2000ed0orku7ads4j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chemistry/">Chemistry</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-eloquent-javascript-Objects" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/10/译-eloquent-javascript-Objects/" class="article-date">
  <time datetime="2019-05-10T14:56:11.000Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/10/译-eloquent-javascript-Objects/">译-eloquent-javascript-Objects</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>抽象数据类型是通过编写一种特殊类型的程序来实现的，该程序根据可以对其执行的操作来定义类型。   Barbara Liskov, <em>Programming with Abstract Data Types</em></p>
</blockquote>
<p><img src="http://eloquentjavascript.net/img/chapter_picture_6.jpg" alt="img"></p>
<p>第四章介绍了 JavaScript 的对象。在编程文化中，有种称为面向对象编程的东西，一系列使用对象（和相关概念）作为程序组织的核心原则的技术。</p>
<p>虽然没有人真正同意其精确定义，但面向对象编程已经塑造了许多编程语言的设计，包括JavaScript。本章将介绍这些想法在JavaScript中的应用方式。</p>
<p>###Encapsulation</p>
<p>面向对象编程的核心思想是将程序划分为更小的部分，并使每个部分负责管理自己的状态。</p>
<p>这样，关于程序的一部分工作方式的信息就可以保留在该部分的本地。开发程序其余部分的人不必记住甚至了解这些信息。每当这些本地细节发生变化时，只需要更新其周围的代码。</p>
<p>这样的程序的不同部分通过接口彼此交互，提供有限的函数或绑定，这些函数或绑定在更抽象的级别提供有用的功能，隐藏它们的完整实现。</p>
<p>这类程序使用对象建模。它们的接口由一组特定的方法和属性组成。暴露在该接口的属性称为 <em>public</em> 。外部代码无法获取的其他内容称为 <em>private</em>。</p>
<p>许多语言提供了区分公共和私有属性的方法，并完全阻止外部代码访问私有属性。JavaScript，再一次采用极简主义的方法，还没有–至少现在没有区分公私变量。将其添加到该语言中的工作正在进行。（译者注：T39 委员会已于2018年10月将“#”作为表示私有变量的标记）</p>
<p>尽管语言没有内置这种区别，JavaScript 程序员却也成功地使用了这种想法。往往，可用的接口被描述在文档或注释中。在属性名称的开头加上下划线（_）字符以表示这些属性是私有的也很常见的。</p>
<p>将接口与实现分离是一个绝妙的主意，这被叫做<em>封装</em>。</p>
<p>###Methods</p>
<p>方法只不过是将函数作为值保存的属性。下面是一个简单的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let rabbit = &#123;&#125;;</span><br><span class="line">rabbit.speak = function(line) &#123;</span><br><span class="line">console.log(`The rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.speak(&quot;I&apos;m alive.&quot;);</span><br><span class="line">// → The rabbit says &apos;I&apos;m alive.&apos;</span><br></pre></td></tr></table></figure>
<p>通常，方法需要对调用它的对象执行某些操作。当一个函数作为一个方法被调用–作为一个属性并被立即调用时，就像在<code>object.method()</code>中一样 - 在它的函数体中的<code>this</code>绑定会自动指向它被调用的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function speak(line) &#123;</span><br><span class="line">console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;</span><br><span class="line">let whiteRabbit = &#123;type: &quot;white&quot;, speak&#125;;</span><br><span class="line">let hungryRabbit = &#123;type: &quot;hungry&quot;, speak&#125;;</span><br><span class="line"></span><br><span class="line">whiteRabbit.speak(&quot;Oh my ears and whiskers, &quot; + &quot;how late it&apos;s getting!&quot;);</span><br><span class="line">// → The white rabbit says &apos;Oh my ears and whiskers, how</span><br><span class="line">//   late it&apos;s getting!&apos;</span><br><span class="line">hungryRabbit.speak(&quot;I could use a carrot right now.&quot;);</span><br><span class="line">// → The hungry rabbit says &apos;I could use a carrot right now.&apos;</span><br></pre></td></tr></table></figure>
<p>你可以将<code>this</code>视为以隐蔽方式传入的额外参数。如果要显式传递它，可以使用函数的<code>call</code>方法，该方法将传入的第一个参数作为其<code>this</code>值，并将其他参数视为普通参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">speak.call(hungryRabbit, &quot;Burp!&quot;);</span><br><span class="line">// → The hungry rabbit says &apos;Burp!&apos;</span><br></pre></td></tr></table></figure>
<p>由于每个函数都有自己的<code>this</code>绑定，其值取决于它的调用方式，因此不能在使用<code>function</code>关键字定义的常规函数中引用包装作用域。</p>
<p>箭头函数则不同的–它们不绑定它们自己的<code>this</code>，但可以看到它们邻近作用域的<code>this</code>绑定。因此，你可以执行类似以下代码的操作，该代码从本地函数内部引用<code>this</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function normalize() &#123;</span><br><span class="line">    console.log(this.coords.map(n =&gt; n / this.length));</span><br><span class="line">&#125;</span><br><span class="line">normalize.call(&#123;coords: [0, 2, 3], length: 5&#125;);</span><br><span class="line">// → [0, 0.4, 0.6]</span><br></pre></td></tr></table></figure>
<p>如果我在使用了<code>function</code>关键字的<code>map</code>函数里写了参数，代码将无法运行。</p>
<p>###Prototypes</p>
<p>仔细看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let empty = &#123;&#125;;</span><br><span class="line">console.log(empty.toString);</span><br><span class="line">// → function toString()&#123;…&#125;</span><br><span class="line">console.log(empty.toString());</span><br><span class="line">// → [object Object]</span><br></pre></td></tr></table></figure>
<p>我从空对象里提出来一个属性。嗒当！</p>
<p>好吧，非也。我只是隐瞒了有关 JavaScript 对象工作方式的信息。除了自身属性外，大多数对象还有一个<em>原型</em>。原型是另一个用作属性后备源的对象。当一个对象获得一个它没有的属性的请求时，将会去它的原型那里搜索属性，然后是原型的原型，依此类推。</p>
<p>那么谁是那个空对象的原型？ 它是伟大的祖先原型，几乎所有对象背后的实体，<code>Object.prototype</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(&#123;&#125;) == Object.prototype);</span><br><span class="line">// → true</span><br><span class="line">console.log(Object.getPrototypeOf(Object.prototype));</span><br><span class="line">// → null</span><br></pre></td></tr></table></figure>
<p>如你所料，<code>Object.getPrototypeOf</code>返回对象原型。</p>
<p>JavaScript 对象的原型关系形成一个树形结构，在这个结构的根部是<code>Object.prototype</code>。它提供了一些所有对象中都可用的方法，例如<code>toString</code>，它将对象转换为字符串形式。</p>
<p>许多对象不直接将<code>Object.prototype</code>作为其原型，而是使用另一个对象来提供不同的默认属性集。函数派生自<code>Function.prototype</code>，数组派生自<code>Array.prototype</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(Math.max) ==</span><br><span class="line">            Function.prototype);</span><br><span class="line">// → true</span><br><span class="line">console.log(Object.getPrototypeOf([]) ==</span><br><span class="line">            Array.prototype);</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure>
<p>这样的原型对象本身就有一个原型，通常是<code>Object.prototype</code>，所以它仍然间接提供像<code>toString</code>这样的方法。</p>
<p>你可以使用<code>Object.create</code>创建具有特定原型的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let protoRabbit = &#123;</span><br><span class="line">speak(line) &#123;</span><br><span class="line">    console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let killerRabbit = Object.create(protoRabbit);</span><br><span class="line">killerRabbit.type = &quot;killer&quot;;</span><br><span class="line">killerRabbit.speak(&quot;SKREEEE!&quot;);</span><br><span class="line">// → The killer rabbit says &apos;SKREEEE!&apos;</span><br></pre></td></tr></table></figure>
<p>对象表达式中的<code>speak(line)</code>属性是定义方法的简便方法。它创建了一个名为<code>speak</code>的属性，并赋予它一个函数作为其值。</p>
<p>“proto”兔子充当所有兔子共有的属性的容器。像杀手兔一样，每个兔子对象包含仅适用于自身的属性–在这种情况下是其类型–且其共享属性派生自原型。</p>
<p>###Classes</p>
<p>JavaScript的原型系统可以被解释为对面向对象的概念（称为类）的一种非正式的实现。类定义了一种对象的内容–它具有哪些方法和属性。这样的对象称为类的<em>实例</em>。</p>
<p>原型可用于定义类的所有实例共享相同值的属性，例如方法。而每个实例中不同的属性，例如我们的兔子<code>type</code>属性，需要直接存储在对象本身中。</p>
<p>因此，要创建给定类的实例，你必须创建一个派生自适当原型的对象，但你还必须确保它本身具有此类实例应具有的属性。这是构造函数的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function makeRabbit(type) &#123;</span><br><span class="line">  let rabbit = Object.create(protoRabbit);</span><br><span class="line">  rabbit.type = type;</span><br><span class="line">  return rabbit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript提供了一种使定义此类函数更容易的方法。如果将关键字  <code>new</code>放在函数调用前面，则该函数将被视为构造函数。这意味着具有正确原型的对象将自动创建，在函数中绑定<code>this</code>，并在函数末尾返回。</p>
<p>构造对象时使用的原型对象是通过获取构造函数的<code>prototype</code>属性来找到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Rabbit(type) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype.speak = function(line) &#123;</span><br><span class="line">  console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let weirdRabbit = new Rabbit(&quot;weird&quot;);</span><br></pre></td></tr></table></figure>
<p>构造函数（实际上所有函数）自动获得一个名为<code>prototype</code>的属性，该属性默认包含一个从<code>Object.prototype</code>派生的普通空对象。如果需要，我们可以使用新对象覆盖它。或者，你可以向现有对象添加属性，如示例所示。</p>
<p>按照惯例，构造函数的名称需要大写，以便可以很容易地将它们与其他自定义函数区分开来。</p>
<p>重要的是要理解 原型与构造函数（通过其原型属性）相关联的方式，和 对象具有原型的方式（可以使用<code>Object.getPrototypeOf</code>查看）之间的区别。构造函数的实际原型是<code>Function.prototype</code>，因为构造函数是函数，它的原型属性包含用于通过它创建的实例的原型。</p>
<p>###Class notation</p>
<p>所以 JavaScript 的类其实是带有<code>prototype</code>属性的构造函数。这就是他们之前的工作方式，直到2015年，这就是你编写类的方式。现在，我们有一个不那么尴尬的表示法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Rabbit &#123;</span><br><span class="line">  constructor(type) &#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  speak(line) &#123;</span><br><span class="line">    console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let killerRabbit = new Rabbit(&quot;killer&quot;);</span><br><span class="line">let blackRabbit = new Rabbit(&quot;black&quot;);</span><br></pre></td></tr></table></figure>
<p><code>class</code>关键字表示开始一个类声明，它允许我们在其中定义一个构造函数和一组方法。可以在声明的大括号内写入任意数量的方法。一个名为<code>constructor</code>的被作特殊处理。它提供了实际的构造函数，它将绑定到名称<code>Rabbit</code>。其他人被打包到该构造函数的原型中。因此，早期的类声明等同于上一节中的构造函数定义。它仅仅是看起来更优雅。</p>
<p>与函数类似，类可以在语句和表达式中使用。当用作表达式时，它不定义绑定，而只是将构造函数作为值生成。你可以在类表达式中省略类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let object = new class &#123; getWord() &#123; return &quot;hello&quot;; &#125; &#125;;</span><br><span class="line">console.log(object.getWord());</span><br><span class="line">// → hello</span><br></pre></td></tr></table></figure>
<p>###Overriding derived properties</p>
<p>当你向对象添加属性时，无论它是否存在于原型中，该属性都会添加到对象自身。如果原型中已存在具有相同名称的属性，则该属性将不再影响这个得到新属性的对象，因为它现在已经隐藏在对象自身的属性后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.teeth = &quot;small&quot;;</span><br><span class="line">console.log(killerRabbit.teeth);</span><br><span class="line">// → small</span><br><span class="line">killerRabbit.teeth = &quot;long, sharp, and bloody&quot;;</span><br><span class="line">console.log(killerRabbit.teeth);</span><br><span class="line">// → long, sharp, and bloody</span><br><span class="line">console.log(blackRabbit.teeth);</span><br><span class="line">// → small</span><br><span class="line">console.log(Rabbit.prototype.teeth);</span><br><span class="line">// → small</span><br></pre></td></tr></table></figure>
<p>下图概述了此代码运行后的情况。<code>Rabbit</code>和<code>Object</code>原型位于<code>killerRabbit</code>之后，作为一种背景，可以查找对象在自身找不到的属性。</p>
<p><img src="http://eloquentjavascript.net/img/rabbits.svg" alt="img"></p>
<p>覆盖原型中存在的属性可能是一件有用的事情。正如示例中兔子牙齿所示，覆盖可用于在更通用的对象类的实例中表达异常属性，同时让非异常对象从其原型中获取标准值。</p>
<p>覆盖也用于为标准函数和数组原型提供与基本对象原型不同的toString方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.prototype.toString == Object.prototype.toString);</span><br><span class="line">// → false</span><br><span class="line">console.log([1, 2].toString());</span><br><span class="line">// → 1,2</span><br></pre></td></tr></table></figure>
<p>在数组上调用<code>toString</code>会产生类似于在其上调用<code>.join（“，”）</code>的结果–它在数组中的值之间放置逗号。直接使用数组调用Object.prototype.toString会产生不同的字符串。该函数不知道数组，因此它只是将单词object和类型名称放在方括号之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call([1, 2]));</span><br><span class="line">// → [object Array]</span><br></pre></td></tr></table></figure>
<p>###Maps</p>
<p>我们在前一章中看到了一个用于通过将函数应用于其元素来转换数据结构的操作。令人困惑的是，在编程中，相同的单词也用于相关但差异相当大的东西。</p>
<p><code>map</code>（名词）是将值（键key）与其他值相关联的数据结构。例如，你可能希望将名称映射到年龄。你可能会为此使用对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let ages = &#123;</span><br><span class="line">  Boris: 39,</span><br><span class="line">  Liang: 22,</span><br><span class="line">  Júlia: 62</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(`Júlia is $&#123;ages[&quot;Júlia&quot;]&#125;`);</span><br><span class="line">// → Júlia is 62</span><br><span class="line">console.log(&quot;Is Jack&apos;s age known?&quot;, &quot;Jack&quot; in ages);</span><br><span class="line">// → Is Jack&apos;s age known? false</span><br><span class="line">console.log(&quot;Is toString&apos;s age known?&quot;, &quot;toString&quot; in ages);</span><br><span class="line">// → Is toString&apos;s age known? true</span><br></pre></td></tr></table></figure>
<p>这里，对象的属性名称是人名，属性值是他们的年龄。但我们当然没有在对象中列出任何名为<code>toString</code>的人。然而，因为普通对象派生自<code>Object.prototype</code>，所以<code>toSting</code>属性就在那里。</p>
<p>因此，使用普通对象作为地图是危险的。有几种方法可以避免这个问题。首先，可以创建任何没有原型的对象。如果将null传递给<code>Object.create</code>，则生成的对象将不会从<code>Object.prototype</code>派生，并且可以安全地用作映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;toString&quot; in Object.create(null));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<p>对象属性名称必须是字符串。如果你需要一个其键无法轻松转换为字符串的映射（如对象），可是无法使用对象作为你自定义的映射的键。</p>
<p>幸运的是，JavaScript 附带了一个名为<code>Map</code>的类，它是为了这个目的而诞生的。它存储映射并允许任何类型的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let ages = new Map();</span><br><span class="line">ages.set(&quot;Boris&quot;, 39);</span><br><span class="line">ages.set(&quot;Liang&quot;, 22);</span><br><span class="line">ages.set(&quot;Júlia&quot;, 62);</span><br><span class="line"></span><br><span class="line">console.log(`Júlia is $&#123;ages.get(&quot;Júlia&quot;)&#125;`);</span><br><span class="line">// → Júlia is 62</span><br><span class="line">console.log(&quot;Is Jack&apos;s age known?&quot;, ages.has(&quot;Jack&quot;));</span><br><span class="line">// → Is Jack&apos;s age known? false</span><br><span class="line">console.log(ages.has(&quot;toString&quot;));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<p>方法<code>set</code>，<code>get</code>和<code>has</code>是<code>Map</code>对象接口的一部分。编写可以快速更新和搜索大量值的数据结构并不容易，但我们不必为此担心。有人已经为我们做了，我们可以通过这个简单的接口来使用他们提供的成就。</p>
<p>如果你确实因为某种原因需要将一个普通的对象视为一个映射，那么就有必要了解到<code>Object.keys</code>只返回对象自己的键值，而不是原型中的那些键。作为<code>in</code>运算符的替代，你可以使用<code>hasOwnProperty</code>方法，该方法忽略对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;x: 1&#125;.hasOwnProperty(&quot;x&quot;));</span><br><span class="line">// → true</span><br><span class="line">console.log(&#123;x: 1&#125;.hasOwnProperty(&quot;toString&quot;));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<p>###Polymorphism</p>
<p>当你在对象上调用<code>String</code>函数（将值转换为字符串）时，它将调用该对象上的<code>toString</code>方法以尝试从中创建有意义的字符串。我提到过一些标准原型定义了他们的<code>toString</code>方法，因此他们可以创建一个比<code>“[object Object]”</code>包含更多的信息的字符串。你也可以自己实现一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.toString = function() &#123;</span><br><span class="line">  return `a $&#123;this.type&#125; rabbit`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(String(blackRabbit));</span><br><span class="line">// → a black rabbit</span><br></pre></td></tr></table></figure>
<p>这是一个强大的想法的简单实例。当编写一段代码来处理具有特定接口的对象时–在上面的例子里是<code>toString</code>方法–任何支持此接口的对象都可以接入到代码中，它都可以正常工作。</p>
<p>这种技术称为“多态”。多态代码可以使用不同形式的值，只要它们支持它所期望的接口即可。</p>
<p>我在第4章中提到过<code>for</code> / <code>of</code>循环可以遍历几种数据结构。这是多态的另一种情况–这种循环期望数据结构暴露特定接口，数组和字符串都是这样做的。我们还可以将这类接口添加到你自己的对象中！ 但在我们这样做之前，我们需要知道 symbol 是什么。</p>
<p>###Symbols</p>
<p>多个接口可以针对不同的事物使用相同的属性名称。例如，我可以定义一个接口，其中<code>toString</code>方法应该将对象转换为一段纱线。对象不可能同时满足该接口和<code>toString</code>的标准用法。</p>
<p>这不是一个坏主意，这个问题并不常见。大多数 JavaScript 程序员根本就没有考虑过这种问题。但这门语言的设计者，无论如何都要考虑这些东西的人，为我们提供了解决方案。</p>
<p>当我说属性名称是字符串时，这并不完全准确。它们通常是，但它们也可以是 symbol。symbol 是使用<code>Symbol</code>函数创建的值。与字符串不同，新创建的 symbol 是唯一的，即你不能两次创建相同的 symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(&quot;name&quot;);</span><br><span class="line">console.log(sym == Symbol(&quot;name&quot;));</span><br><span class="line">// → false</span><br><span class="line">Rabbit.prototype[sym] = 55;</span><br><span class="line">console.log(blackRabbit[sym]);</span><br><span class="line">// → 55</span><br></pre></td></tr></table></figure>
<p>当你将其转换为字符串时，会包含之前传递给<code>Symbol</code>的字符串，并且可以在控制台中显示 symbol 时更容易识别 symbol。但它没有任何含义–多个符号可能具有相同的名称。</p>
<p>既独一无二又可用作属性名称，使得 symbol 适用于定义可与其他属性并存的接口，无论它们的名称是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const toStringSymbol = Symbol(&quot;toString&quot;);</span><br><span class="line">Array.prototype[toStringSymbol] = function() &#123;</span><br><span class="line">  return `$&#123;this.length&#125; cm of blue yarn`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log([1, 2].toString());</span><br><span class="line">// → 1,2</span><br><span class="line">console.log([1, 2][toStringSymbol]());</span><br><span class="line">// → 2 cm of blue yarn</span><br></pre></td></tr></table></figure>
<p>通过在属性名称周围使用方括号，可以在对象表达式和类中包含 symbol 属性。就像方括号属性访问表示法一样，将会对属性名称进行求值，因此它允许我们引用包含 symbol 的绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let stringObject = &#123;</span><br><span class="line">  [toStringSymbol]() &#123; return &quot;a jute rope&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(stringObject[toStringSymbol]());</span><br><span class="line">// → a jute rope</span><br></pre></td></tr></table></figure>
<p>###The iterator interface</p>
<p>赋予<code>for</code> / <code>of</code>循环的对象应该是可迭代的。这意味着它有一个用<code>Symbol.iterator</code>符号命名的方法（由语言定义的符号值，存储为<code>Symbol</code>函数的属性）。</p>
<p>被调用时，该方法应该返回一个提供第二个接口：迭代器，的对象。这是迭代的实际内容。它有个返回下一个结果的<code>next</code>方法。该结果应该是一个具有<code>value</code>属性的对象，该属性提供下一个值（如果有）和<code>done</code>属性，当没有更多结果时<code>done</code>应该为<code>true</code>，否则为<code>false</code>。</p>
<p>请注意，<code>next</code>，<code>value</code>和<code>done</code>属性名称是纯字符串，而不是 symbol。只有能添加到许多不同对象的<code>Symbol.iterator</code>才是真正的 symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let okIterator = &quot;OK&quot;[Symbol.iterator]();</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: &quot;O&quot;, done: false&#125;</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: &quot;K&quot;, done: false&#125;</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>让我们实现一个可迭代的数据结构。我们将构建一个 martrix 类，充当二维数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Matrix &#123;</span><br><span class="line">  constructor(width, height, element = (x, y) =&gt; undefined) &#123;</span><br><span class="line">    this.width = width;</span><br><span class="line">    this.height = height;</span><br><span class="line">    this.content = [];</span><br><span class="line"></span><br><span class="line">    for (let y = 0; y &lt; height; y++) &#123;</span><br><span class="line">      for (let x = 0; x &lt; width; x++) &#123;</span><br><span class="line">        this.content[y * width + x] = element(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(x, y) &#123;</span><br><span class="line">    return this.content[y * this.width + x];</span><br><span class="line">  &#125;</span><br><span class="line">  set(x, y, value) &#123;</span><br><span class="line">    this.content[y * this.width + x] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类将其内容存储在含有 width × height 个元素的单个数组中。元素是逐行存储的，因此，例如，第五行中的第三个元素是（使用从零开始的索引）存储在位置 4 × 宽 + 2。</p>
<p>构造函数采用<code>width</code>，<code>height</code>和可选<code>element</code>函数，用于填充初始值。有<code>get</code>和<code>set</code>方法来检索和更新矩阵中的元素。</p>
<p>在循环遍历矩阵时，你也许会对元素的位置以及元素本身感兴趣，因此我们将使用迭代器生成具有<code>x</code>，<code>y</code>和<code>value</code>属性的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MatrixIterator &#123;</span><br><span class="line">  constructor(matrix) &#123;</span><br><span class="line">    this.x = 0;</span><br><span class="line">    this.y = 0;</span><br><span class="line">    this.matrix = matrix;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    if (this.y == this.matrix.height) return &#123;done: true&#125;;</span><br><span class="line"></span><br><span class="line">    let value = &#123;x: this.x,</span><br><span class="line">                 y: this.y,</span><br><span class="line">                 value: this.matrix.get(this.x, this.y)&#125;;</span><br><span class="line">    this.x++;</span><br><span class="line">    if (this.x == this.matrix.width) &#123;</span><br><span class="line">      this.x = 0;</span><br><span class="line">      this.y++;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;value, done: false&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类通过<code>x</code>和<code>y</code>属性跟踪迭代矩阵的过程。<code>next</code>方法首先检查是否已到达矩阵的底部。如果没有，则首先创建保存当前值的对象，然后更新其位置，如果可以的话移动到下一行。</p>
<p>让我们将<code>Matrix</code>类变成可迭代的。在本书中，我偶尔会使用“马后炮”一样的原型操作来向类添加方法，以便各个代码段保持短小并各自独立。在日常编程中，不需要将代码拆分成小块，而是直接在类中声明这些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Matrix.prototype[Symbol.iterator] = function() &#123;</span><br><span class="line">  return new MatrixIterator(this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>for</code> / <code>of</code>来便利矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let matrix = new Matrix(2, 2, (x, y) =&gt; `value $&#123;x&#125;,$&#123;y&#125;`);</span><br><span class="line">for (let &#123;x, y, value&#125; of matrix) &#123;</span><br><span class="line">  console.log(x, y, value);</span><br><span class="line">&#125;</span><br><span class="line">// → 0 0 value 0,0</span><br><span class="line">// → 1 0 value 1,0</span><br><span class="line">// → 0 1 value 0,1</span><br><span class="line">// → 1 1 value 1,1</span><br></pre></td></tr></table></figure>
<p>###Getters, setters, and statics</p>
<p>接口通常由函数方法组成，但也可以包含保存非函数值的属性。例如，<code>Map</code>对象具有一个<code>size</code>属性，可以告诉你存储了多少个键。</p>
<p>这样的对象甚至不需要直接在实例中计算和存储这样的属性。即使是直接访问的属性也可能有潜在的函数调用。这些方法称为getter，它们是通过在对象表达式或类声明中的方法名称前写<code>get</code>来定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let varyingSize = &#123;</span><br><span class="line">  get size() &#123;</span><br><span class="line">    return Math.floor(Math.random() * 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(varyingSize.size);</span><br><span class="line">// → 73</span><br><span class="line">console.log(varyingSize.size);</span><br><span class="line">// → 49</span><br></pre></td></tr></table></figure>
<p>只要有人从此对象的<code>size</code>属性中读取，就会调用关联的方法。使用<code>setter</code>写入属性时，你可以执行类似的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Temperature &#123;</span><br><span class="line">  constructor(celsius) &#123;</span><br><span class="line">    this.celsius = celsius;</span><br><span class="line">  &#125;</span><br><span class="line">  get fahrenheit() &#123;</span><br><span class="line">    return this.celsius * 1.8 + 32;</span><br><span class="line">  &#125;</span><br><span class="line">  set fahrenheit(value) &#123;</span><br><span class="line">    this.celsius = (value - 32) / 1.8;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static fromFahrenheit(value) &#123;</span><br><span class="line">    return new Temperature((value - 32) / 1.8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let temp = new Temperature(22);</span><br><span class="line">console.log(temp.fahrenheit);</span><br><span class="line">// → 71.6</span><br><span class="line">temp.fahrenheit = 86;</span><br><span class="line">console.log(temp.celsius);</span><br><span class="line">// → 30</span><br></pre></td></tr></table></figure>
<p><code>Temperature</code>类允许你以摄氏度或华氏度读取和写入温度，但在内部它仅存储摄氏度并自动在<code>fahrenheit</code> getter 和 setter 中转换为摄氏温度。</p>
<p>有时你希望将一些属性直接附加到构造函数，而不是原型。此类方法无法访问类实例，但可以用于提供创建实例的其他方法。</p>
<p>在类声明中，在名称之前写有<code>static</code>的方法存储在构造函数中。因此，<code>Temperature</code>类允许你编写<code>Temperature.fromFahrenheit（100）</code>以使用华氏度创建温度。</p>
<p>###Inheritance</p>
<p>已知一些矩阵是对称的。如果以左上角到右下角的对角线镜像反转这种矩阵，它将保持不变。换句话说，存储在x，y的值总是与y，x处的值相同。</p>
<p>假设我们需要一个像 Matrix 这样的数据结构，但却强制要求矩阵是对称的。我们可以从头开始编写它，但这将涉及重复一些与我们已编写的代码非常相似的代码。</p>
<p>JavaScript 的原型系统可以创建一个就像旧类一样的新类，但是对它的一些属性可以重新定义。新类的原型来自旧的原型，但为<code>set</code>方法添加了新的定义。</p>
<p>在面向对象的编程术语中，这称为继承。新类继承旧类的属性和行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SymmetricMatrix extends Matrix &#123;</span><br><span class="line">  constructor(size, element = (x, y) =&gt; undefined) &#123;</span><br><span class="line">    super(size, size, (x, y) =&gt; &#123;</span><br><span class="line">      if (x &lt; y) return element(y, x);</span><br><span class="line">      else return element(x, y);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(x, y, value) &#123;</span><br><span class="line">    super.set(x, y, value);</span><br><span class="line">    if (x != y) &#123;</span><br><span class="line">      super.set(y, x, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let matrix = new SymmetricMatrix(5, (x, y) =&gt; `$&#123;x&#125;,$&#123;y&#125;`);</span><br><span class="line">console.log(matrix.get(2, 3));</span><br><span class="line">// → 3,2</span><br></pre></td></tr></table></figure>
<p>使用关键词<code>extends</code>表示此类不应直接基于默认的<code>Object</code>原型，而应基于其他类。这被称为超类，由它派生出的类叫子类。</p>
<p>要初始化<code>SymmetricMatrix</code>实例，构造函数通过<code>super</code>关键字调用其超类的构造函数。如果想要这个新对象的行为（大致）类似于Matrix，那么这是必要的，它将需要矩阵具有的实例属性。为了确保矩阵是对称的，构造函数包装<code>element</code>函数以交换对角线下方的值的坐标。</p>
<p><code>set</code>方法再次使用<code>super</code>，但这次不是调用构造函数，而是从超类的方法集调用特定方法。我们正在重新定义<code>set</code>但确实想要使用原始行为。因为<code>this.set</code>引用的是新的<code>set</code>方法，所以调用它不起作用。在类内部方法中，<code>super</code>提供了一种调用方法的方法，能以它们在超类中定义的形式调用。</p>
<p>继承允许我们使用相对较少的工作基于现有数据类型构建稍微不同的数据类型。它是面向对象传统的基本组成部分，包括封装和多态。在现在，后两者普遍被视为绝妙的想法，但继承更具争议性。</p>
<p>封装和多态可以用来将代码片段彼此分开，减少整个程序的纠缠，而继承从根本上将类连接在一起，创造更多的纠缠。从类继承时，你通常必须比仅使用它更多地了解它的工作原理。继承可以是一个有用的工具，我现在在我自己的程序中使用它，但它不应该是你第一个想到使用的工具，你可能不会乐意寻找机会来构建类层次结构（家庭树类）。</p>
<p>###The instanceof operator</p>
<p>有时知道对象是否来自特定类是有用的。为此，JavaScript 提供了一个名为<code>instanceof</code>的二元运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new SymmetricMatrix(2) instanceof SymmetricMatrix);</span><br><span class="line">// → true</span><br><span class="line">console.log(new SymmetricMatrix(2) instanceof Matrix);</span><br><span class="line">// → true</span><br><span class="line">console.log(new Matrix(2, 2) instanceof SymmetricMatrix);</span><br><span class="line">// → false</span><br><span class="line">console.log([1] instanceof Array);</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure>
<p>运算符将查看继承的类型，因此<code>SymmetricMatrix</code>是<code>Matrix</code>的实例。运算符也可以应用于像<code>Array</code>这样的标准构造函数。几乎每个对象都是<code>Object</code>的一个实例。</p>
<p>###Summary</p>
<p>所以对象不只是拥有自己的属性。他们有原型，是其他对象。只要他们的原型具有该属性，他们将表现得好像他们拥有他们没有的属性。简单对象将<code>Object.prototype</code>作为其原型。</p>
<p>构造函数是名称通常以大写字母开头的函数，可以与<code>new</code>操作符一起使用来创建新对象。新对象的原型将是构造函数的<code>prototype</code>属性中找到的对象。你可以充分利用这一点，将所有给定对象都要共享的属性放入其原型中。有一个<code>class</code>的声明方式，提供了一种用来定义构造函数及其原型的简明的方法。</p>
<p>每次访问对象的属性时，你都可以定义 getter 和 setter 以隐蔽地调用方法。静态方法是存储在类的构造函数中的方法，而不是其原型。</p>
<p>传入参数为对象和构造函数，<code>instanceof</code>运算符可以告诉你该对象是否是该构造函数的实例。</p>
<p>对象的一个有用的事情是为它们指定一个接口，并告诉每个人他们应该只通过该接口与你的对象交互。构成对象的其余细节现在已封装，隐藏在接口之后。</p>
<p>多个类型可以实现相同的接口。为使用接口而编写的代码知道如何与提供接口的任意数量的不同对象交互。这称为多态性。</p>
<p>当实现仅在某些细节上有所不同的多个类时，将新类编写为现有类的子类，继承其部分行为可能会有所帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/05/10/译-eloquent-javascript-Objects/" data-id="cjy2fdnv7000id0orgtgo98h1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-Biomass-Gasification" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/14/译-Biomass-Gasification/" class="article-date">
  <time datetime="2019-04-14T13:16:25.000Z" itemprop="datePublished">2019-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/14/译-Biomass-Gasification/">Biomass Gasification</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.tandfonline.com/doi/full/10.1080/15567249.2017.1410593?scroll=top&amp;needAccess=true" target="_blank" rel="noopener">原文链接</a></p>
<p>Zhiguo Li, Cheng Han, and Tianyao Gu</p>
<p>School of Economics and Management, China University of Petroleum (East), Qingdao, China</p>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><blockquote>
<p>生物质是一种非有机燃料，在气化反应中具有转化为热解和合成气反应中的有利化学物质的高潜力。然而，气化系统设计和运行中的经济问题是该领域最重要的问题。本研究旨在回顾这一过程的现状和经济特征。该研究还研究了不同生产化学品的经济特征，如氢，甲醇和乙醇。根据文献资料，发现使用2000干吨/天的工厂比使用1000干吨/天的工厂更经济地生产乙醇。</p>
</blockquote>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>近年来，气化作为一种​​清洁环保的工艺，吸引了大多数能源研究人员的注意。如今，由于强制执行严格的法律和对清洁能源的需求日益增加，对气化处理的关注度已经提高。在该方法中，通过将燃料与空气结合产生含有诸如氢气和二氧化碳的能源的气体，其可以用作燃气轮机中的燃料。尽管该过程是化石燃料燃烧的良好替代品，但它有一些亟待解决的局限性，例如，能够阻塞过滤器并引起技术问题的复杂的碳氢化合物混合物。该过程的经济缺点是延迟该过程商业化的其他问题。气化过程最重要的缺点之一是灰烬污垢，由于气化效率的显着降低，这会导致经济问题。到目前为止，已经设计了不同的气体系统，但是要达到高容量系统还有很长的路要走。</p>
<p>生物质是一种非有机燃料，在气化反应中具有转化为热解和合成气反应中的有利化学物质的高潜力。与石油相比，燃料的成本效益也是这种燃料最重要的特征之一。值得注意的是，生物质对空气中的二氧化碳量没有任何影响，因为它在气化过程中产生与光合作用过程相同量的二氧化碳。</p>
<p>如上所述，气化系统的设计和操作中的经济问题是该领域中最重要的问题。为了使这一过程商业化，已经进行了大量的经济评估和克服障碍的研究。最重要的研究如下：</p>
<p>本研究旨在回顾这一过程的现状和经济特征。该研究还研究了不同生产化学品的经济特征，如氢，甲醇和乙醇。</p>
<h4 id="Economic-assessment"><a href="#Economic-assessment" class="headerlink" title="Economic assessment"></a>Economic assessment</h4><h5 id="Economic-assessment-of-hydrogen-production"><a href="#Economic-assessment-of-hydrogen-production" class="headerlink" title="Economic assessment of hydrogen production"></a><em>Economic assessment of hydrogen production</em></h5><p>氢是一种清洁燃料，它不是地球上最纯净的燃料，必须从其他材料中提取，如水，油和生物质。有许多方法可以产生氢气，例如气化和热解。工厂规模是影响更多和更经济的氢气生产和生产量以及气化系统设计成本的另一个重要因素。Mann（1995）利用三种不同尺寸的反应器对来自小型（30吨/天），中型（300吨/天）和大型（1000吨/天）工厂的合成气的蒸汽重整的氢气生产进行经济研究，最后他意识到从小型工厂（21594立方米/天）生产的氢气可以为每天500辆汽车提供足够的燃料。他还研究了生物质价格对制氢成本的影响，发现生物质部分对制氢成本有直接和显着的影响。Mann的结果如图1所示。如图所示，生物质部分的增加将急剧增加氢生产成本。显然，即使大型和小型工厂之间存在相当大的距离，大型工厂的制氢成本也会更高。他还发现，生物质价格对氢销售价格有直接影响。尽管应用技术和工作条件可直接影响制氢成本，但生物质部分起着决定性作用。</p>
<p><img src="https://www.tandfonline.com/na101/home/literatum/publisher/tandf/journals/content/uesb20/2018/uesb20.v013.i02/15567249.2017.1410593/20171226/images/large/uesb_a_1410593_f0001_oc.jpeg" alt="Figure.1"></p>
<h5 id="Economic-assessment-of-bio-methanol-production"><a href="#Economic-assessment-of-bio-methanol-production" class="headerlink" title="Economic assessment of bio-methanol production"></a><em>Economic assessment of bio-methanol production</em></h5><p>生物甲醇是气化过程中最重要的产品之一，在工业中有很多应用。如前所述，气化过程中产生的气体可用于生产氨，甲醇和氢气，但应用前应分离气体，这需要特殊设备（Higman和van der Burgt2003）。因此，甲醇生产成本可能高于氢生产。也许这就是甲烷蒸汽重整制甲醇比生物质气化制甲醇更常见的原因。合成气合成甲醇是另一种高度放热的方法。该反应通常在Cu / ZnO / Al <sub>2</sub> O <sub>3</sub>存在下在220-270℃的温度下发生（Spathand Dayton2003）。Dong和Steinberg（1997）研究了甲醇生产的经济因素以及通过Hynol工艺减少二氧化碳排放。Hynol工艺包括三个步骤：（1）生物质气化，（2）合成气的蒸汽重整，和（3）在前一步骤中由氢气产生甲醇并产生一氧化碳。他们还发现Hynol工厂的甲醇生产成本相当于0.43（$ / gal），产能为1085（百万加仑/年），可与美国的甲醇价格进行比较。Clausen等人。（2010）利用DNA软件分析了生物质气化产甲醇的热力学性质，发现工厂能达到59-72％的最佳甲醇火用效率。</p>
<h5 id="Economic-assessment-of-biodiesel-production"><a href="#Economic-assessment-of-biodiesel-production" class="headerlink" title="Economic assessment of biodiesel production"></a><em>Economic assessment of biodiesel production</em></h5><p>生物柴油被称为生物质可再生燃料，近年来引起了人们的广泛关注。可再生性和二氧化碳和硫化氢的低产量是最重要的生物柴油特征之一（Demirbas2007）。比其他燃料更高的成本和柴油发动机中断的可能性是其最重要的缺点。已经进行了大量研究以评估生物质气化过程中生物质生产生物柴油的成本。Apostolakou等（2009）计算了不同工厂生产能力下生物柴油生产和必需生物量的成本（图2）。他们表示，工厂产能从5增加到120（kt / y）会增加生物质供应成本，但在产能增长后成本保持不变。他们还发现，增加工厂产能将降低生物柴油价格并达到120的固定数量。评估经济因素，他们还可以表明生产能力几乎与FCI（固定资本投资）呈线性关系；换句话说，增加容量会增加FCI。</p>
<p><img src="https://www.tandfonline.com/na101/home/literatum/publisher/tandf/journals/content/uesb20/2018/uesb20.v013.i02/15567249.2017.1410593/20171226/images/large/uesb_a_1410593_f0002_oc.jpeg" alt="Figure.2"></p>
<h5 id="Economic-assessment-of-bio-ethanol-production"><a href="#Economic-assessment-of-bio-ethanol-production" class="headerlink" title="Economic assessment of bio-ethanol production"></a><em>Economic assessment of bio-ethanol production</em></h5><p>乙醇是生物质气化产生的另一种潜在化学品。近年来，已经进行了许多研究以研究乙醇作为载体的添加剂或燃料的影响。众所周知，在生物柴油中加入乙醇会增加辛烷值并减少排放（Hamelinck等人，2005）。生物质可以通过气化和/或水解过程转化为乙醇。此外，催化反应可用于乙醇生产。乙醇生产量通常取决于工作条件和生物质结构。有几项经济研究可以获得影响乙醇生产气化过程商业化的经济因素。Yeon等（2013）基于独立的催化反应进行了生物质和固体废物生产乙醇的经济研究。作者认为混合燃料的热值是决定乙醇生产系统经济效率的关键参数。因此，进行了一项经济研究，通过综合热 - 生物过程分析生物质中乙醇生产的经济性。他们预测了乙醇生产的经济学资本成本，运营成本和各种生物质材料的乙醇生产成本。他们表示，随着生产率从25增加到50（百万加仑/年），木材和柳枝稷的乙醇生产成本分别从1.84降至1.63（$ / gal）和1.95降至1.75（$ / gal）。Gwak等（2016）进行了一项经济研究，以评估使用流化床生物质生物乙醇生产的潜力。他们得出结论，2000干吨/天规模的工厂的设计比两个1000干吨/天规模的工厂更经济。Gwak等（2016）探讨了运输成本对乙醇价格的影响。他们观察到，随着运输成本从0增加到15美元/吨，1000和2000干吨/天的乙醇价格分别从1.197增加到1.468 $ / L和0.75-1.02 $ / L. 这意味着使用2000干吨/天的工厂比1000干吨/天的工厂更经济。</p>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>生物质气化是生产生物甲醇，生物乙醇和生物柴油等化学品的有效方法。然而，气化系统的设计和操作中的经济问题是该领域中最重要的问题。本研究旨在回顾这一过程的现状和经济特征。该研究还研究了不同生产化学品的经济特征，如氢，甲醇和乙醇。</p>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><blockquote>
<p>Apostolakou, A. A., I. K. Kookos, C. Marazioti, and K. C. Angelopoulos. 2009. Techno-economic analysis of abiodiesel production process from vegetable oils.Fuel  Proceedings  Technological90:1023–31.<br>Clausen, L. R., N. Houbak, and B. Elmegaard. 2010. Techno-economic analysis of a methanol plant based ongasification of biomass and electrolysis of water.Energy35:2335–47.<br>Demirbas, A. 2007.Biodiesel: A Realistic Fuel Alternative for Diesel Engines. Berlin: Springer.<br>Dong, Y., and M. Steinberg. 1997. Hynol-An economical process for methanol production from biomass and naturalgas with reduced CO2emission.International Journal of Hydrogen Energy22:971–77.<br>Gwak, I. S., J. H. Hwang, J. M. Sohn, and S. H. Lee. 2016. Economic evaluation of domestic biowaste to ethanol via afluidized bed gasifier.Journal Industrial Engineering Chemical.<br>Hamelinck, C. N., G. V. Hooijdonk, and A. P. Faaij. 2005. Ethanol from lignocellulosic biomass: techno-economicperformance  in  short-,  middle-  and  long-term.Biomass&amp;Bioenergy28:384–410.<br>Higman, C., and M. Van Der Burgt. 2003.Gasification. USA: Gulf Professional Pub.<br>Mann, M. K. 1995.Technical  and  economic  assessment  of  producing  hydrogen  by  reforming  syngas  from  the  battleindirectly heated biomass gasifier. NREL/TP-431-8143. Colorado, USA:National Renewable Energy Laboratory.<br>Spath, P. L., and D. C. Dayton 2003 December.Preliminary screening–technical and economic assessment of synthesisgas to fuels and chemicals with emphasis on the potential for biomass derived syngas. NREL/TP-510-34929.Colorado,USA: National Renewable Energy Laboratory.<br>Yeon, S. H., D. H. Shin, N. S. Nho, K. H. Shin, and C. S. Jin. 2013. Economic feasibility of ethanol production frombiomass  and  waste  resources  via  catalytic  reaction.Waste   Manage   Researcher31:421–27.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/04/14/译-Biomass-Gasification/" data-id="cjy2fdnux000ad0orausdm9g5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chemistry/">Chemistry</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-Green-Chemistry-Principles-And-Practice" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/译-Green-Chemistry-Principles-And-Practice/" class="article-date">
  <time datetime="2019-03-27T04:06:33.000Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/译-Green-Chemistry-Principles-And-Practice/">译-Green-Chemistry-Principles-And-Practice</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Green-Chemistry：Principles-and-Practice"><a href="#Green-Chemistry：Principles-and-Practice" class="headerlink" title="Green Chemistry：Principles and Practice"></a>Green Chemistry：Principles and Practice</h1><blockquote>
<p><a href="https://pubs.rsc.org/en/content/articlehtml/2010/cs/b918763b" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<p>绿色化学是一个相对较新的致力于在分子水平上努力实现可持续发展的新兴领域。由于其能够驱动化学创新同时满足环境和经济需求，该领域在过去十年中受到广泛关注。绿色化学有一套具有凝聚力的十二原则框架，我们将在这篇评论性综述中进行系统的概览。本文通过一系列说明性示例介绍了绿色化学的设计理念和科学哲学。讨论了未来绿色化学的发展趋势，并提出了将这些原则作为一个有凝聚力的设计系统的挑战。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-p1.gif" alt="Paul Anastas"><br><strong>Paul Anastas</strong><br><em>Paul T. Anastas是耶鲁大学环境化学实践的Teresa和H. John Heinz III教授，以及耶鲁大学绿色化学和绿色工程中心主任。作为一名合成有机化学家，Anastas博士获得了Brandeis大学的博士学位，并在1991年建立了绿色化学领域.Anastas博士已经出版了十本关于科学可持续发展的书籍和论文。</em></p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-p2.gif" alt="Nicolas Eghbali"><br><strong>Nicolas Eghbali</strong><br><em>Nicolas Eghbali在法国波尔多一所大学获得分子生物学学士学位和化学硕士学位。2007年，在麦吉尔大学李朝军教授和David Harpp教授的监督下完成博士论文后，他加入耶鲁大学绿色化学与绿色工程中心，担任博士后研究助理。他的博士研究工作集中在二氧化碳的利用上，他目前的研究范围包括绿色有机合成，材料科学和生物催化。</em></p>
<h2 id="I-Introduction"><a href="#I-Introduction" class="headerlink" title="I Introduction"></a>I Introduction</h2><p>绿色化学被定义为“减少或消除有害物质的使用和产生的化学产品和工艺的设计”。绿色化学的定义和概念最早是在20世纪90年代初提出的。在此后的几年里，国际上提出了数以百计的绿色化学规划和政府倡议，并在美国，英国和意大利设立了最初的领先项目。这些国家在构建可持续设计方面提供了大量信息。重要的早期项目包括1995年成立的“the US Presidential Green Chemistry Challenge Awards”，1997年成立的绿色化学研究所，以及1999年皇家化学学会现已成熟的绿色化学杂志的第一卷出版物。</p>
<p>绿色化学最重要的方面是设计理念。设计是人类意图的表达，不能随意设计。“绿色化学十二原则”是旨在帮助化学家实现可持续发展的有意目标的“设计规则”。绿色化学的特点是精心规划化学合成和分子设计，以减少不良后果。通过适当的设计，人们可以实现协同效应 – 而不仅仅是等价交换。</p>
<p>绿色化学方法致力于在分子水平上实现可持续性。由于这一目标的存在，我们将绿色化学方法应用于所有工业领域。从航空航天，汽车，化妆品，电子，能源，家用产品，制药到农业，有数百个成功应用屡获殊荣的经济竞争技术的例子。绿色化学已经走出实验室，触及了工业，教育，环境和普罗大众。它的概念产生了巨大的影响。绿色化学领域展示了化学家如何设计下一代产品和工艺，使其在产出经济效益的同时，又对人类健康和环境无害。继绿色化学的科学热情之后，教学计划，政府资助以及绿色化学研究中心的建立在过去二十年中成倍增长。许多大学现在开设绿色化学和绿色工程课程，一些机构提供该领域的学位，界上一些国家的政府投资也有所增加。</p>
<h2 id="II-Framework-of-Green-Chemistry"><a href="#II-Framework-of-Green-Chemistry" class="headerlink" title="II Framework of Green Chemistry"></a>II Framework of Green Chemistry</h2><p>关于绿色化学框架的三个要点可归纳为：</p>
<ol>
<li>绿色化学设计跨越化学生命周期的所有阶段。</li>
<li>绿色化学旨在设计化学产品和工艺的固有性质，以减少其内在危害。</li>
<li>绿色化学是一个有凝聚力的原则或设计标准体系。</li>
</ol>
<p>绿色化学的十二原则是为可持续设计提供框架的设计标准或指南。它们构成了设计更安全的化学品和化学转化的总体构造。化学一直被认为是一门危险的科学，而且公众常常将“化学”这个词与“有毒”联系在一起。有一些通过使用防护服等安全预防措施来降低风险的方法。当这类安全保护失败时，风险（被定义为危险和暴露的函数）就会随之增加。如果危险很高且暴露控制失败，后果可能是灾难性的。通过最小化反应过程的危险部分而不仅仅关注暴露控制，即使在不期望的情况下，风险也可以得到控制。设计更安全的可持续化学品和工艺需要努力将内在危害降至最低，从而限制事故和损害的风险。</p>
<p>绿色化学旨在减少所有生命周期阶段的危害，已被证实是有经济效益的。危害被定义为对人类或环境造成不良后果的能力。化学物质或化学过程的内在危害可以被设计为在过程的每个层面上最小化，无论是毒性，物理危害（例如爆炸，易燃性）还是全球性危害，如平流层臭氧消耗。这些危害可能源于化学转化中使用的原料以及制造的最终产品。精心设计将减少或消除化学品和工艺中的内在危害; 基于“十二原则”的设计是一个整体。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f1.gif" alt="图1" title="图1"><br><strong>风险为危险和暴露的函数</strong></p>
<h2 id="III-The-Twelve-Principles"><a href="#III-The-Twelve-Principles" class="headerlink" title="III The Twelve Principles"></a>III The Twelve Principles</h2><p>绿色化学十二原则由Paul Anastas和John Warner于1998年提出。它们是设计新化学产品和工艺的指导框架，适用于工艺生命周期的各个方面，从原材料到转化的效率和安全性，所用产品和试剂的毒性和生物降解性。他们最近被总结为更方便和令人难忘的首字母缩写词，PRODUCTIVELY。以下部分旨在提供有关绿色化学的概览。为方便读者，每个原理都引用了技术实例。</p>
<hr>
<ol>
<li><strong>Prevention</strong>，防止污染产生比产生后治理更好。</li>
<li><strong>Atom Economy</strong>，合成方法应该被设计成掺入的原材料只会生成最终产物。</li>
<li><strong>Less Hazardous Chemical Synthesis</strong>，无论是否可行，合成方法都应设计成使用和生成对人和环境低毒或无毒的物质。</li>
<li><strong>Design Safer Chemicals</strong>，化学产品应该被设计成减少毒性的同时保留功效。</li>
<li><strong>Safer Solvents and Auxiliaries</strong>，应尽可能不使用辅助物质，当必须要使用时，需是无害的。</li>
<li><strong>Design for Energy Efficiency</strong>，化学过程的能源需求应视其环境和经济影响而改变，并应尽量减少。如果可能，合成方法应该在常温常压下进行。</li>
<li><strong>Use of Renewable Feedstocks</strong>，在技术和经济条件允许下，原材料应该是可再生的。</li>
<li><strong>Reduce Derivatives</strong>，如果可以，应减少或避免副反应，因为这会消耗掉额外的试剂和产生污染。</li>
<li><strong>Catalysis</strong>，催化剂应优于化学计量试剂。</li>
<li><strong>Design for Degradation</strong>，化学产品应该被设计为在他们的功效发挥之后降解为无毒产物并且不留存与环境中。</li>
<li><strong>Real-Time Analysis for Pollution Prevention</strong>，发展更先进的分析方法，实时监测反应过程，在危险物质产生前进行控制。</li>
<li><strong>Inherently Safer Chemistry for Accident Prevention</strong>，产物和得到产物的反应过程应该减少潜在的化学事故风险，如泄漏，爆炸，火灾</li>
</ol>
<hr>
<p><strong>1 Waste</strong></p>
<p>废物预防是绿色化学十二原则中的第一个。最好是防止废物的产生，而不是在事后清理它。任何没有实用价值的材料的产生或未利用能源的损失生都可视为浪费。如上所述，废物可以通过多种形式，各异地影响环境，这取决于其性质，毒性，数量或释放方式。当一个过程中使用的大部分初始原料由于该过程本身的原始设计而丢失时，它将不可避免地产生废物，这是由于定义不合理造成的。<br>1992年，Roger Sheldon提出了现在被广泛接受的“E因子”或称“环境影响因子”的概念。该指标有助于量化每千克产品产生的废物量。它是评估制造过程“环境可接受性”的一种手段。<br>化学工业中许多人采用的环境因素强调了某些工业过程的效率如何，并为创造性解决方案打开了大门。一个众所周知的例子是通过氯代醇中间体制备的环氧乙烷的早期合成。如上所述的整个合成的E因子等于5。对于每公斤产品，要处理5公斤废物。这没有考虑被氯副产物污染的废水。当合成被修改为使用分子氧，因此不需要氯，E因子降至0.3千克废物。新工艺产生的废物比原来的废物少16倍，从而消除了废水的形成。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f3.gif" alt="图3" title="图3"></p>
<p>当副产品无法避免时，应该考虑其他创新的解决方案，而富有成效的解决方案是寻求一种工业生态学方法，在这种方法中，废物可以成为一种新的原材料，在重新进入生命周期的过程中对另一个过程具有重要价值。该方法目前正在应用于生物燃料的生产。</p>
<p><strong>2 Atom economy</strong></p>
<p>1990年，Barry Trost提出了合成效率的概念：原子经济性（AE）也称为原子利用率。它指的是最大化原材料使用的概念，以使最终产品含有反应物中最大数量的原子。理想的反应将包含反应物的所有原子。AE的测量值是所需产物的分子量与反应中所用反应物的分子量之比。这是一个理论值，旨在快速评估反应的效率。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f4.gif" alt="图4" title="图4"></p>
<p>为了说明这个概念，下面给出一些例子，如格氏反应，A3偶联和Diels-Alder反应。格氏反应，由于其在有机合成中的重要性，而在科学界广为人知，而不幸的是，由于其需要一定量的金属反应物和必须单独制备的格氏试剂，它是个原子经济性相对较差的反应。上图显示了典型的格氏反应和格氏试剂在构建炔丙胺类结构中的应用。AE的值分别为44％和56％，这表明原料损失了一半。C.-J，李等人在2002年提出了上一个例子的解决方案，通过A3偶联（炔烃，醛和胺）。这种一步多组分偶联反应更有效并保存原子，因为92％的原始原子存在于最终产物中。Diels-Alder反应也是原子经济反应的极好例子。其AE等于100％，因为来自反应物的所有原子都被结合到最终产物中。Diels-Alder型反应属于环加成类，是传统化学中最环保的反应类型之一。</p>
<p><strong>3 Synthesis</strong></p>
<p>如下图所示，有机化学家的合成工具箱已经通过大量的创新工作得到了改进。过去十年中发展起来的许多新反应增加了上个世纪发现的已经存在的绿色反应数量。基于环加成，重排或多组分偶联的反应是已知的并且高效的反应。级联或串联反应，C-H活化，置换和酶促反应是较新的方法，向有机化学家展示了可用的更清洁，更高效的合成工具的强有力的例子。例如，Grubbs催化剂允许烯烃通过类似于Horner-Wadsworth-Emmons反应这类Wittig型反应的机制进行置换反应（形成四元环作为反应中间体，如下图）。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f5.gif" alt="图5" title="图5"></p>
<p>它是构建较大分子的重要工具。然而，与Wittig反应不同，置换反应不会产生大量废物。不幸的是，在Wittig反应的情况下形成鏻盐是不可避免的，因为它是反应设计的一部分并且是主要驱动力。<br>C-H活化是另一个相对较新的化学领域，是一个有希望的方向。在传统的偶联反应中，通常使用活性碳-卤素键，因为它们具有较高的反应性。由于卤化分子很少是天然的，因此意味着需要产生前体的额外步骤。用C-H活化代替传统的偶联反应消除了对卤化前体的需要，和因此产生的卤化副产物。<br>Murai于1993年，Fagnou于2007年分别发表了两个著名的C-H活化实例。在第一个例子中，Murai等人，使用钌催化剂将灭活的底物苯乙酮和2-甲基苯乙烯偶联。这项工作是C-H激活的第一个例子，也是该领域的一个里程碑。在第二个例子中，Fagnou和Stuart在不需要任何活化或引导基团的条件下选择性地偶联了两种芳族化合物。这些例子证明了C-H活化在推进绿色化学中的作用。</p>
<p><strong>4 Molecular design</strong></p>
<p>虽然人们大量设计了从药品到材料等各种功能的化学品，但却忽略了生产过程中的危害。了解对环境产生影响的分子的特性以及生物圈中发生的变化对可持续性至关重要。掌握了这些，化学将能够设计出真正对人类和环境更安全的分子。Ariens于1984年以及Garrett和Devito于1996年开展的工作表明，设计更安全的化学品对绿色化学的进步来说不仅是必要的，而且也是可能的。<br>近几十年来，在毒理学领域已经有大量的工作将其从一门描述性科学转变为具有大量机理的科学，并且最近逐渐朝计算机方向整合。由于这种转变，可以创建关联结构、性质和功能的相关性，方程式和模型。这些方法为制定综合设计战略所开展的工作提供了基础。例如，现有的药物化学理解已经可以帮助建立一些基本规则来设计毒性较小的化学品，这些规则通过特定的设计来阻止药物进入人体和许多生物有机体。</p>
<p><strong>5 Solvents</strong></p>
<p>溶剂可能是绿色化学研究中最活跃的领域。它们代表了绿色化学的一个重要挑战，因为它们通常占合成过程中浪费的绝大部分。而且，许多常规溶剂是有毒的、易燃的、腐蚀性的。它们的挥发性和溶解性导致了空气，水和土地的污染，增加了工人暴露其中的风险，并导致严重的事故。在可能的情况下，回收和再利用通常与能量密集型蒸馏和有时交叉污染有关。为了解决所有这些缺点，化学家们开始寻找更安全的解决方案。无溶剂体系，水，超临界流体（SCF）以及最近的离子液体是这些新的“绿色”答案的一些例子。<br>如果可能，理想的情况是不使用任何溶剂，因为使用辅助剂总是意味着从指定系统中移除它的额外的能量。因此，我们致力于开发无溶剂系统。当发现溶剂占工业废物的大多数时，这一想法得到了加强。取决于所用试剂的物理性质或转化的所需结果，该方法通常需要新的或重新设计的化学物质以允许反应在没有原始溶剂的情况下进行。<br>SCF是传统有机溶剂的另一种替代品，并且在过去几十年中得到了广泛的研究。它们是在临界点同时加热和压缩的物质。（如下图）</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f6.gif" alt="图6" title="图6"></p>
<p>常见的SCF由水，二氧化碳，甲烷，甲醇，乙醇或丙酮产生。二氧化碳是最广泛使用的SCF之一。得到的scCO2已被证明是一种多功能溶剂，安全且易于操作，Poliako ff，Leitner，Jessop，DeSimone等人的工作证明了这一点。让SCF特别是scCO2如此具有吸引力的原因，是冷却容器或降低压力时发生的状态变化。在临界点以上，二氧化碳将是一种可以在其中进行反应的液体，在以下，它将是一种气体。对系统进行脱气可以完全去除溶剂。ScCO2已经发现了广泛的工业应用，其中最着名的是绿色咖啡豆的脱色和干洗中全氯乙烯的替代品。超临界流体已被证明是传统溶剂的一种有价值的替代品。<br>另一个更环保的溶剂的例子是Seddon在现代开创的离子液体。正如其名称所强调的那样，离子液体或有时称为室温离子液体在室温下是液体盐。它们几乎没有蒸气压和非常低的可燃性。Jessop等人最近发现了什么。是一种“可切换的”离子液体。就像液体scCO2一样，就地生成“智能顺从溶剂”。将加压二氧化碳加入有机混合物中将其转化为离子液体，原位产生更安全的溶剂。释放压力可逆转该现象，并将离子液体重新转化为原始混合物，从而完全除去溶剂并消除繁琐的纯化和萃取步骤。<br>基于相同概念的另一个例子是Horvath推进的多孔双相催化的开发。含有适于所需转化的催化剂的含氟相或溶剂通常在环境温度下不与有机试剂混溶。而加热时，它们形成单一介质，使反应进行。冷却后，有机相和多孔溶剂分离，简化了纯化过程。这是一种很好的方法，但其限制是含氟溶剂昂贵。<br>这些最后的例子很好地说明了化学的一个主要挑战：分离。除了某些无溶剂体系外，新改进的绿色溶剂仍然是助剂，因此必须与所需产品分离。如果无法避免使用它们，则在选择合适的溶剂时必须考虑分离问题。</p>
<p><strong>6 Energy</strong></p>
<p>对石油原料耗尽和能源消耗增加的担忧日益增加，推动了高效能源利用和可再生能源的研究，在人类生存的时间范围内的不会耗尽的资源。<br>如第一部分（第一原则）所述，未使用的能源也可能被视为浪费。设计不需要密集能量的化学反应或系统是急需的。降低化学反应的能量壁垒或选择合适的反应物使得转化可以在室温下进行，这是化学家可以实现的一个降低能量需求的例子，带来了与之相关的所有直接和间接的好处。<br>提高化学系统的能源效率仅仅是解决方案的一部分。还需要替代能源。其中已经确认的可再生能源是生物燃料，太阳能（热能和光伏），风能，水力发电，地热能和氢燃料电池。再一次，绿色化学家在这一新挑战中发挥着重要作用，因为他们有能力设计能源高效转换的材料或化学系统，可用于收获一些可再生的自然能源。<br>太阳能是地球上主要的可持续能源，也是石油的替代能源之一。相当多的努力致力于理解和设计可将太阳辐射转换为电能的化学系统。有机，无机和混合太阳能电池倍受关注，但有机太阳能电池因其更高的效率而受到更多关注。这些电池具有从太阳辐射吸收光子能量的材料的能力，吸收导致激发态的形成，该激发态可以被传导并产生电流。创造出能高效效地将光转换成电流的建筑材料和聚合物仍然是一个挑战，并且是这种方法成功的关键。<br>使用氢气和氧气的质子交换膜（PEM）燃料电池也可以为即将到来的能源需求增加提供另一种解决方案（如下图）。在过去十年中，PEM燃料电池引起了广泛的研究兴趣，随着纳米颗粒甚至氢化酶等高效催化剂的发展，这种方法的一个重要考虑因素是处理高度易燃和易爆的氢气的危险。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f7.gif" alt="图7" title="图7"></p>
<p><strong>7 Renewable materials</strong></p>
<p>据估计，我们的绝大多数制造产品都来自石油原料或天然气。这些资源的枯竭将触及我们消费生活和经济的许多方面。现在，材料和燃料都转向可再生原料变得更加紧迫。地球上主要用于物质和能源的主要可再生原料是生物质，这种物质来自生物体，这包括木材，农作物，农业残余物，食品等。<br>可再生材料包括纤维素，木质素，木栓质和其他木材化合物，聚羟基链烷酸酯，乳酸，甲壳质，淀粉，甘油和油。例如，木质素是纸浆和造纸工业的主要浪费。它已在生产现场燃烧多年来提供能源。近年来，人们发现了它新的用途，例如，分散剂，添加剂和用于生产如vanilin，DMSO或腐殖酸的化学品的原料。几丁质是另一种丰富的天然聚合物，其构成节肢动物（例如甲壳类动物）的外骨骼。它是海产品工业的主要副产品，可通过脱乙酰化转化为壳聚糖。壳聚糖已被证实在水净化，生物医学应用和其他工业领域具有广泛用途。重新利用生物工业的这种浪费应该提供大量的原材料来取代目前的石油原料。</p>
<p><strong>8 Derivatives</strong></p>
<p>无论是用于有机合成还是分析化学，共价衍生化都是化学中普遍应用的技术。在20世纪90年代早期，一种创新的非共价衍生化的概念出现了，这种衍生化不依赖于共价键，而是分子间相互作用。华纳的工作是作为一种利用少量能量和更少材料从原始系统实现化学改性的手段而开发的。非共价衍生化的早期实例是在宝丽来胶片中使用的对苯二酚的受控分散和溶解度。宝丽来的研究人员试图在升高的pH值下释放氢醌。他们不是依赖基础不稳定的共价保护基团的传统方法，而是在氢醌和双 - （N，N-二烷基）对苯二甲酰胺之间形成共晶形式的非共价保护基团（下图）。这种方法对于工业流程是成功的和可行的。它无需修改原始对苯二酚结构，就最大限度地减少了废料和能源。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f8.gif" alt="图8" title="图8"></p>
<p><strong>9 Catalysis</strong></p>
<p>在许多情况下，废物的形成与化学计量的试剂的传统使用有关。从化学计量学方法转向催化过程被认为是提高合成工具箱效率的一种主要方式。催化可以通过降低所需的能量输入，避免使用化学计量的试剂和更高的产物选择性来提高反应的效率。这意味着更少的能源，更少的原料和更少的废物。此外，它通常为创新的化学反应打开了大门，为传统的化学挑战带来了非传统的解决方案。<br>氧化和还原反应说明了这一概念。使用DIBAL-H作为氢化物供体的还原是有机化学家使用的成熟方法。由于需要化学计算量的还原剂来完成反应，因此会产生大量的废物。像Noyori氢化那样转换为催化氢化消除了对化学计量试剂的需要，从而减少了所需原料的量和产生的废物量（下图）。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f9.gif" alt="图9" title="图9"></p>
<p>除了效率之外，催化还可以实现其他不利的反应。这是复分解反应和Grubbs催化剂开发的情况。如图5所示，复分解催化剂的开发为不饱和化合物的形成提供了开创性的方法。环境效益显著，创新很重要。<br>生物催化是“绿色”化学的另一个例子，因为它是依赖于天然或修饰酶的仿生方法。它通常指的是直接使用纯化的酶和由工程生物体完成的转化。反应条件相对温和，因为转化可在大气压和环境温度下在水中进行。此外，酶已被证明更具化学，区域和立体选择性。</p>
<p><strong>10 Biodegradation</strong></p>
<p>持久性问题已为人所知很长一段时间，并在工业发展的早期阶段变得明显。例如，在20世纪50年代，四丙烯基烷基苯磺酸盐（TPPS）用作洗衣洗涤剂的表面活性剂，并且由于不完全降解而积聚到供水中。这种情况非常严峻，以至于有一些例子表明“从水龙头出来后水往往会发泡”。公众的强烈抗议促使该行业立即寻求解决方案，并发现用直链碳链取代TPPS的甲基支链可以降低生物持久性（下图）。常见的例子是用直链烷基苯磺酸盐（LAS）代替TPPS。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f10.gif" alt="图10" title="图10"></p>
<p>从持续的环境污染问题来看，设计可生物降解的材料和化学品不是一项简单的任务。数十年的数据收集是大势所趋。某些化学结构如卤化部分，支链，季碳，叔胺和某些杂环可具有增强的持久性而被避免使用。另一方面，通过普遍存在的酶识别的官能团如酯或酰胺的整合可以帮助设计环境可降解产物。该策略适用于用作家用织物柔软剂的表面活性季铵化合物。直到20世纪90年代，长链铵盐如二（氢化）牛脂二甲基氯化铵（DHTDMAC）被释放到环境中。然后发现它们在含水沉积物中的生物降解速率低，并且内在的生态毒性很高。引入可水解的酰胺或酯键作为解决方案。已证明新的铵盐更易生物降解，如图10所示; DHTDMAC被二（乙基 - 酯）二甲基氯化铵（DEEDMAC）代替，随后生物降解性增加70％。</p>
<p><strong>11 Analysis</strong></p>
<p>绿色分析化学的目标是测量化学品而不产生废物。与分析化学相关的环境问题通常与分析方法本身有关。遗憾的是，实时直接分析并不系统，因为许多方法仍然需要对样品进行预处理，或者依赖于人们所谓的“非原位分析”。过程分析化学被定义为监测转化并立即采取行动的能力，以防止不必要的结果。并非总是可行，因此在分析样品时可能产生废物。绿色化学家必须考虑分析方法的功能要求，因为如果选择的方法导致进一步的环境问题，它将适得其反。绿色分析化学可以定义为使用分析程序，产生更少的废物，对人类健康和环境更安全。该定义包括“实时”监测化学转化的各个方面以及与传统分析相关的环境缺陷。原位监测反应在绿色化学方面具有显著优势。当可以迅速采取行动时，它可以防止事故，节省能源，和/或防止形成大量副产品，否则这些副产品需要额外的净化。<br>当涉及到分析方法本身时，它们中的大多数都存在与方法的两个主要步骤相关的两个问题：样品的预处理，包括提取，分离甚至有时要对样品进行化学修改，以及信号采集步骤。由于预处理步骤通常需要大量溶剂，因此它一直是分析化学家关注的焦点。如果在萃取步骤中无法避免使用溶剂，则应考虑使用加速溶剂萃取（ASE）或SCF萃取等良性替代品。<br>用于制造分析仪器的材料也要纳入考虑。建造新传感器的绿色化学家和绿色工程师都应该意识到他们使用的材料相关的毒性以及与任何潜在的环境问题。例如，汞电极通常用于电化学，用碳基电极（如纳米管或纳米纤维）代替它们已被证明是一种有效的解决方案。</p>
<p><strong>12 Accident prevention</strong></p>
<p>在我们的工作环境中，危险物质和过程成倍增加。根据“化学事故预防和1990年清洁空气法案修正案”，通过识别和评估危害来预防事故。所有类型的危害，无论是毒性，物理危害如爆炸性或易燃性，还是全球性危害，都应在化学品和工艺设计中加以解决，以防止诸如博帕尔或爱运河事故等事故。<br>2009年1月发生的加州大学洛杉矶分校事故是这些危险和危害的最新和令人震惊的例证。处理非常普通且高度可燃的丁基锂试剂不幸地导致研究助理的死亡。这次事故应该强烈提醒科学界，我们仍然使用的许多化学品存在严重危害，应该用更安全的替代品代替，以尽可能防止事故。</p>
<h2 id="IV-Accomplishments-by-industry"><a href="#IV-Accomplishments-by-industry" class="headerlink" title="IV Accomplishments by industry"></a>IV Accomplishments by industry</h2><p>有很多使用绿色化学成功的工业变革的例子。以下部分并不是要列出获奖者的详尽清单，而是介绍几个关键的例子来说明该行业如何适应绿色化学的新挑战。<br>第一个例子是，由伊士曼的酶促酯化而来的，一个更环保的合成途径。这种生物催化过程在温和的条件下进行，最大限度地减少副产物的形成并节省能源，从而提高效率。总共有数百升有机溶剂从之前的工艺中消除。<br>2008年，Dow AgroSciences的研究人员因绿色农药的设计而获得奖励。在试图了解天然生物农药的结构 - 活性关系以预测更活跃的类似物时，他们设计了Spinetoram。该公司预计，这种新农药的生产将在其使用的最初五年内消除“约180万磅有机磷杀虫剂”。<br>2006年，默克开发了一种更环保的西格列汀的合成途径，西格列汀是一种用于治疗2型糖尿病的手性b-氨基酸衍生物。该方法基于未保护的烯胺的新型不对称催化氢化，避免了过度衍生化的需要（下图）。默克提出了三步合成，声称总产量增加。在制造规模上实施新路线显示废物量显著减少，使新工艺成为更具成本效益的选择。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f11.gif" alt="图11" title="图11"></p>
<p>2004年，BMS开发了生产紫杉醇的新方法，紫杉醇是抗癌药物Taxols的有效成分。紫杉醇由天然存在的前体10-脱乙酰基浆果赤霉素III（10-DAB）通过11步合成而商业生产。这种“半合成途径”，最初是作为一种经济上可行的分子方法而开发的，并非没有一定的环境问题。因此，BMS使用最新的生物技术设计了一个更可持续的过程。不是从前体合成紫杉醇，而是直接从植物细胞培养物中提取活性化合物。该方法消除了所有有机溶剂，有害试剂以及与先前方法相关的其他步骤。BMS现在仅使用植物细胞培养物制造紫杉醇。<br>2002年，Pfizer为重新设计的舍曲林合成开发了一种新的绿色合成途径，舍曲林是一种用于治疗抑郁症的活性成分（下图）。新工艺在提高合成的整体效率和选择性的同时，也带来了实质性的环境效益。具体而言，原始制造过程中的三步序列简化为单一序列。原材料的使用显著减少，工艺进行了优化，以便所有步骤都可以在乙醇中进行。最后的改变消除了使用、蒸馏和回收四种有毒溶剂（二氯甲烷，四氢呋喃，甲苯和己烷）的需要。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f12.gif" alt="图12" title="图12"></p>
<p>一个最值得注意的例子是Solutia公司在1998年完成的关于从4-氨基二苯胺合成中消除氯的工作（下图）。该公司的研究人员探索了各种芳香胺的新途径，包括4-氨基二苯胺（4-ADPA），以消除含有高含量无机盐的含水废物流的形成。还有人担心储存和处理大量氯气的危险。该解决方案采用了新的4-ADPA合成方法，该方法利用碱促进的苯胺和硝基苯的直接偶联。环境效益显著，包括大幅减少废物产生。</p>
<p><img src="https://pubs.rsc.org/services/images/RSCpubs.ePlatform.Service.FreeContent.ImageService.svc/ImageService/Articleimage/2010/CS/b918763b/b918763b-f13.gif" alt="图13" title="图13"></p>
<h2 id="V-Future-challenges"><a href="#V-Future-challenges" class="headerlink" title="V Future challenges"></a>V Future challenges</h2><p>到目前为止，绿色化学领域的成就令人印象深刻，归功于世界各地的学术界，工业界和研究机构的科学家。然而，到目前为止取得的成就是该领域仍有待解决的重大挑战的前奏。下面提到了一些值得注意的挑战。</p>
<p><strong>Twelve Principles as a cohesive system</strong></p>
<p>绿色化学十二原则的设计框架已成为该领域许多进步的模板，然而，十二原则并不是十二个独立目标，而是一个集成的凝聚力设计系统。只有通过所有原则的应用才能实现真正可持续的过程。通过寻求原则之间相互加强的方面，系统的可持续设计是可能的，并且可以促进变革性创新而不是渐进式改进。</p>
<p><strong>Multi-functional catalysts</strong></p>
<p>在过去二十年中，催化作用取得了重大进展。然而，即使在今天，大多数催化剂仅设计用于一种转化，对多功能催化剂，即一种作用于一系列转化的催化体系知之甚少。如果相同的催化剂可用于各种独立反应或在一锅中实现整个合成，它将使化学达到新的水平，因为可以制造具有更高材料和能量利用率的更复杂的分子。</p>
<p><strong>Mastering weak forces for synthesis and properties</strong></p>
<p>非共价和弱力相互作用可能在化学的未来中发挥越来越重要的作用。通过弱力赋予性能并以相同方式引导合成路径，同时最小化键断裂和键合形成的量可以产生显著的优点。这些措施包括减少所需的能源数量，抑制浪费，以及提高效率。以化学领域中掌握共价力相同的方式掌握弱力，有助于在分子水平上实现可持续性。</p>
<p><strong>Integrative systems thinking</strong></p>
<p>传统的科学调查方法主要基于还原方法。这种方法带来了深刻的理解和发现，使得现代生活的一切：从交流，交通到医学，成为可能。它还导致了巨大的意外和无法预料的后果，对人类和环境造成了破坏性影响。通过对系统的思考，绿色化学可以追求显著的创新，同时避免意想不到的结果。将还原和综合思维相结合可以带来真正的变革性创新。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>几代人以来，分子科学家发明了促进经济和社会发展的分子、材料和制造过程。绿色化学确保所有这种作为化学领域悠久传统的创造力能够以对人类和地球产生良好影响的方式实施，并作为设计标准。通过这样做，绿色化学已经表明，通过创新，公司可以在经济上获得更多利益，同时更环保。虽然世界各地的绿色化学从业者已经完成了大量的工作，但过去的成就与绿色化学的力量和潜力相比显得苍白无力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/03/27/译-Green-Chemistry-Principles-And-Practice/" data-id="cjy2fdnuz000cd0oroicfk8s7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chemistry/">Chemistry</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-eloquent-javascript-Functions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/译-eloquent-javascript-Functions/" class="article-date">
  <time datetime="2019-03-27T04:05:20.000Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/译-eloquent-javascript-Functions/">译-eloquent-javascript-Functions</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>“人们认为计算机科学是天才的艺术，但实际情况恰恰相反，许多人做的事情都是建立在彼此的基础上的，就像一堵由小石头砌成的墙。”—–Donald Knuth</p>
</blockquote>
<p><img src="https://eloquentjavascript.net/img/chapter_picture_3.jpg" alt="img"></p>
<p>函数是JavaScript编程的基础。封装程序片段的理念有很多用途。它为我们提供了一种构造更大程序的方法，以减少重复工作，将命名与子程序关联起来，并将这些子程序彼此隔离开来。</p>
<p>函数最明显的应用是定义新词汇。在散文中创造新词通常是一种不好的文体。但在编程中，它是不可或缺的。</p>
<p>成年英语使用者的词汇量约为2万个。很少有编程语言内置两万个命令。与人类语言相比，可用的词汇往往定义得更精确，因此灵活性更差。因此，我们通常必须引入新的概念，以避免语义重复。</p>
<h2 id="Defining-a-function"><a href="#Defining-a-function" class="headerlink" title="Defining a function"></a>Defining a function</h2><p>函数定义是将一个值与一个函数进行绑定的行为。例如，这段代码定义<code>square</code>为一个生成给定数字的平方的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const square = function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(square(12));</span><br><span class="line">// → 144</span><br></pre></td></tr></table></figure></p>
<p>使用以关键字<code>function</code>开头的表达式创建函数。函数有一组参数(在本例中只有x)和一个函数体，函数体中包含调用函数时要执行的语句。以这种方式创建的函数的函数体必须始终用大括号括起来，即使它只包含一条语句。</p>
<p>一个函数可以有多个参数，也可以没有参数。在下面的示例中，<code>makeNoise</code>没有列出任何参数名，而<code>power</code>列出了两个参数名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const makeNoise = function() &#123;</span><br><span class="line">  console.log(&quot;Pling!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeNoise();</span><br><span class="line">// → Pling!</span><br><span class="line"></span><br><span class="line">const power = function(base, exponent) &#123;</span><br><span class="line">  let result = 1;</span><br><span class="line">  for (let count = 0; count &lt; exponent; count++) &#123;</span><br><span class="line">    result *= base;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(power(2, 10));</span><br><span class="line">// → 1024</span><br></pre></td></tr></table></figure></p>
<p>有些函数产生值，如幂和平方，而有些函数不产生值，如makeNoise，其惟一结果是额外效果。<code>return</code>语句确定函数返回的值。当控件遇到这样的语句时，它会立即跳出当前函数并将返回值返回给调用该函数的代码。<code>return</code>关键字后面没有表达式将导致函数返回<code>undefined</code>。根本没有返回语句的函数，如<code>makeNoise</code>，也会返回<code>undefined</code>。</p>
<p>函数的参数的行为类似于常规绑定，但是它们的初始值是由函数调用时才给出的，而不是函数本身中的代码。</p>
<h2 id="Bindings-and-scopes"><a href="#Bindings-and-scopes" class="headerlink" title="Bindings and scopes"></a>Bindings and scopes</h2><p>每个绑定都有一个范围，这是程序中绑定可见的部分。对于定义在任何函数或块之外的绑定，作用域是整个程序，您可以在任何地方引用这些绑定。这些被称为全局。</p>
<p>使用<code>let</code>和<code>const</code>声明的绑定实际上是声明它们所在的块的本地绑定，因此，如果您在循环中创建其中一个绑定，那么循环前后的代码将无法“看到”它。在2015年以前的JavaScript中，只有函数创建了新的作用域，所以使用<code>var</code>关键字创建的旧式绑定在整个函数中都是可见的，如果它们不在函数体中，那么它们出现在整个函数作用域中或整个全局作用域中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let x = 10;</span><br><span class="line">if (true) &#123;</span><br><span class="line">  let y = 20;</span><br><span class="line">  var z = 30;</span><br><span class="line">  console.log(x + y + z);</span><br><span class="line">  // → 60</span><br><span class="line">&#125;</span><br><span class="line">// y is not visible here</span><br><span class="line">console.log(x + z);</span><br><span class="line">// → 40</span><br></pre></td></tr></table></figure></p>
<p>每个作用域都可以查看它上层的作用域，因此在示例中的<code>if</code>块中<code>x</code>是可见的。例外情况是，当多个绑定具有相同的名称时，代码只能看到最内层的绑定。例如，当<code>halve</code>函数中的代码指向<code>n</code>时，它看到的是自己的<code>n</code>，而不是全局<code>n</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const halve = function(n) &#123;</span><br><span class="line">  return n / 2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let n = 10;</span><br><span class="line">console.log(halve(100));</span><br><span class="line">// → 50</span><br><span class="line">console.log(n);</span><br><span class="line">// → 10</span><br></pre></td></tr></table></figure></p>
<h2 id="Nested-scope"><a href="#Nested-scope" class="headerlink" title="Nested scope"></a>Nested scope</h2><p>JavaScript不仅区分全局绑定和本地绑定。块和函数可以在其他块和函数中创建，从而产生多级的局部性。</p>
<p>例如，该函数输出制作一批鹰嘴豆泥所需的配料，其中包含另一个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const hummus = function(factor) &#123;</span><br><span class="line">  const ingredient = function(amount, unit, name) &#123;</span><br><span class="line">    let ingredientAmount = amount * factor;</span><br><span class="line">    if (ingredientAmount &gt; 1) &#123;</span><br><span class="line">      unit += &quot;s&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(`$&#123;ingredientAmount&#125; $&#123;unit&#125; $&#123;name&#125;`);</span><br><span class="line">  &#125;;</span><br><span class="line">  ingredient(1, &quot;can&quot;, &quot;chickpeas&quot;);</span><br><span class="line">  ingredient(0.25, &quot;cup&quot;, &quot;tahini&quot;);</span><br><span class="line">  ingredient(0.25, &quot;cup&quot;, &quot;lemon juice&quot;);</span><br><span class="line">  ingredient(1, &quot;clove&quot;, &quot;garlic&quot;);</span><br><span class="line">  ingredient(2, &quot;tablespoon&quot;, &quot;olive oil&quot;);</span><br><span class="line">  ingredient(0.5, &quot;teaspoon&quot;, &quot;cumin&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>外部函数定义的变量<code>factor</code>在<code>ingredient</code>函数内是可见的。但它的局部变量，如<code>unit</code>和<code>ingredientAmount</code>，在外部函数中不可见。</p>
<p>在一个块中可见的变量集合由该块在程序中的位置决定。上级局部作用域对次级局部作用域都是可见的，并且全局作用域对所有作用域都是可见的。这种绑定可见性的方法称为词法作用域。</p>
<h2 id="Functions-as-values"><a href="#Functions-as-values" class="headerlink" title="Functions as values"></a>Functions as values</h2><p>函数绑定通常只是作为特定程序片段的名称。这样的绑定只定义一次，从不更改。这样让人很容易混淆函数和普通值。</p>
<p>但两者是不同的。函数值可以做所有其他普通值可以做的事情，你可以在任意表达式中使用它，而不仅仅是调用它。可以在新的绑定中存储新的函数值，将其作为参数传递给函数，等等。类似地，包含函数的绑定仍然只是常规绑定，如果不是常量，也可以赋一个新值，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let launchMissiles = function() &#123;</span><br><span class="line">  missileSystem.launch(&quot;now&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">if (safeMode) &#123;</span><br><span class="line">  launchMissiles = function() &#123;/* do nothing */&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第5章中，我们将讨论通过将函数值传递给其他函数可以完成的有趣的事情。</p>
<h2 id="Declaration-notation"><a href="#Declaration-notation" class="headerlink" title="Declaration notation"></a>Declaration notation</h2><p>创建函数绑定时有一种稍微短一些的方法。当在语句开头使用<code>function</code>关键字时，它的工作方式是不同的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function square(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个函数声明。语句定义绑定<code>square</code>并将其指向给定的函数。这样写起来稍微容易一些，而且函数后面不需要分号。</p>
<p>这种形式的函数定义有一个微妙之处。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;The future says:&quot;, future());</span><br><span class="line"></span><br><span class="line">function future() &#123;</span><br><span class="line">  return &quot;You&apos;ll never have flying cars&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面的代码可以运行，就算函数是在调用它的代码之后定义的。函数声明不是常规的自上而下控制流的一部分。它们会被移到作用域的顶部，并且可以被该作用域中的所有代码使用。这有时很有用，因为它提供了以一种似乎有意义的方式排序代码的自由，而不必担心在使用所有函数之前必须定义它们。</p>
<h2 id="Arrow-functions"><a href="#Arrow-functions" class="headerlink" title="Arrow functions"></a>Arrow functions</h2><p>函数有第三种表示法，和其他的看起来很不一样。它没有使用 <code>function</code>关键字，而是使用一个由等号和大于号组成的箭头(=&gt;)(不要与大于等于号的操作符混淆，它的写法是&gt;=)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const power = (base, exponent) =&gt; &#123;</span><br><span class="line">  let result = 1;</span><br><span class="line">  for (let count = 0; count &lt; exponent; count++) &#123;</span><br><span class="line">    result *= base;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>箭头位于参数之后，然后是函数体。它表示“这样的输入(参数)产生这样的结果(函数体)”。</p>
<p>当只有一个参数名时，可以省略参数列表周围的圆括号。如果函数体是单个表达式，而不是大括号中的块，则该表达式将直接被函数返回。所以，这两个关于平方的定义是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const square1 = (x) =&gt; &#123; return x * x; &#125;;</span><br><span class="line">const square2 = x =&gt; x * x;</span><br></pre></td></tr></table></figure></p>
<p>当一个箭头函数没有任何参数时，它的参数列表就是一个空的圆括号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const horn = () =&gt; &#123;</span><br><span class="line">  console.log(&quot;Toot&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这种语言中，没有必要同时使用箭头函数和函数表达式。除了我们将在第6章讨论的一个小细节之外，它们发挥的作用其实是一样的。2015年JavaScript添加了箭头函数，主要是为了以更简洁的方式编写函数表达式。我们将在第五章中经常用到它们。</p>
<h2 id="The-call-stack"><a href="#The-call-stack" class="headerlink" title="The call stack"></a>The call stack</h2><p>控制流经函数的方式有些复杂。让我们仔细看看。下面是一个简单的,执行一些函数调用的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function greet(who) &#123;</span><br><span class="line">  console.log(&quot;Hello &quot; + who);</span><br><span class="line">&#125;</span><br><span class="line">greet(&quot;Harry&quot;);</span><br><span class="line">console.log(&quot;Bye&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这个程序大致是这样运行的:调用<code>greet</code>会导致控件跳转到该函数的开头(第2行)。<code>console.log</code>接受控制权，完成它的工作，然后将控制权返回到第2行。在那里，它到达<code>greet</code>函数的末尾，最后回到调用它的地方，即第4行。之后的行再次调用<code>console.log</code>。所有的值都返回之后，程序就结束了。</p>
<p>我们可以像这样用图表表示控制流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">not in function</span><br><span class="line">   in greet</span><br><span class="line">        in console.log</span><br><span class="line">   in greet</span><br><span class="line">not in function</span><br><span class="line">   in console.log</span><br><span class="line">not in function</span><br></pre></td></tr></table></figure></p>
<p>因为函数返回时必须跳转回调用它的位置，所以计算机必须记住调用发生的上下文。在上面的情况下，<code>console.log</code>必须在完成后返回到<code>greet</code>函数。在下面的情况下，它返回到程序的末尾。</p>
<p>计算机存储此上下文的位置是调用堆栈。每次调用函数时，当前上下文都存储在这个堆栈的顶部。当函数返回时，它从堆栈中删除顶部上下文并使用该上下文继续执行。</p>
<p>存储这个堆栈需要计算机内存中的空间。当堆栈变得太大时，计算机将发出堆栈空间不足或递归过多之类的失败消息。下面的代码通过向计算机提出一个非常难的问题来说明这一点，这个问题会在两个函数之间无限的来回。如果计算机有一个无限堆栈，它将是无限的。但实际上，我们将耗尽空间，或者会破坏堆栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function chicken() &#123;</span><br><span class="line">  return egg();</span><br><span class="line">&#125;</span><br><span class="line">function egg() &#123;</span><br><span class="line">  return chicken();</span><br><span class="line">&#125;</span><br><span class="line">console.log(chicken() + &quot; came first.&quot;);</span><br><span class="line">// → ??</span><br></pre></td></tr></table></figure></p>
<h2 id="Optional-Arguments"><a href="#Optional-Arguments" class="headerlink" title="Optional Arguments"></a>Optional Arguments</h2><p>下面的代码将会毫无问题的执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function square(x) &#123; return x * x; &#125;</span><br><span class="line">console.log(square(4, true, &quot;hedgehog&quot;));</span><br><span class="line">// → 16</span><br></pre></td></tr></table></figure></p>
<p>我们定义了只有一个参数的<code>square</code>函数。然而，当我们传入3个参数来调用它时，它并没有抱怨。它忽略额外的参数并计算第一个参数的平方。</p>
<p>JavaScript对于传递给函数的参数的数量非常宽容。如果你传入太多参数，多余的就会被忽略。如果传递的参数太少，则会为缺少的参数分配<code>undefined</code>。</p>
<p>这样做的缺点是，很可能您会不小心将错误数量的参数传递给函数。而谁也不会告诉你。</p>
<p>好处是，这种行为可用于允许使用不同数量的参数调用函数。例如，这个减号函数试图通过运算一个或两个参数来模拟<code>-</code>运算符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function minus(a, b) &#123;</span><br><span class="line">  if (b === undefined) return -a;</span><br><span class="line">  else return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(minus(10));</span><br><span class="line">// → -10</span><br><span class="line">console.log(minus(10, 5));</span><br><span class="line">// → 5</span><br></pre></td></tr></table></figure></p>
<p>如果在参数后面加上<code>=</code>运算符和表达式，当没有给出参数时，表达式的值将被赋予该参数。</p>
<p>例如，这个版本的<code>power</code>第二个参数是可选的。如果不提供对应参数或传递<code>undefined</code>，它将默认为2，函数将表现为<code>square</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function power(base, exponent = 2) &#123;</span><br><span class="line">  let result = 1;</span><br><span class="line">  for (let count = 0; count &lt; exponent; count++) &#123;</span><br><span class="line">    result *= base;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(power(4));</span><br><span class="line">// → 16</span><br><span class="line">console.log(power(2, 6));</span><br><span class="line">// → 64</span><br></pre></td></tr></table></figure></p>
<p>在下一章中，我们将看到函数体如何获取它传递的所有参数列表。这很有帮助，因为它使函数可以接受任意数量的参数。例如，<code>console.log</code>就可以做到，它输出所有给定的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;C&quot;, &quot;O&quot;, 2);</span><br><span class="line">// → C O 2</span><br></pre></td></tr></table></figure></p>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><p>将函数视为值，以及每次调用函数都会重建本地绑定的事实，带来了一个有趣的问题。当创建本地绑定的函数调用不再活动时，本地绑定会发生什么情况？</p>
<p>下面的代码展示了一个例子。它定义了一个函数<code>wrapValue</code>，用于创建本地绑定。然后返回一个能够访问并返回这个本地绑定的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function wrapValue(n) &#123;</span><br><span class="line">  let local = n;</span><br><span class="line">  return () =&gt; local;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let wrap1 = wrapValue(1);</span><br><span class="line">let wrap2 = wrapValue(2);</span><br><span class="line">console.log(wrap1());</span><br><span class="line">// → 1</span><br><span class="line">console.log(wrap2());</span><br><span class="line">// → 2</span><br></pre></td></tr></table></figure></p>
<p>结果如你所料，两个实例的绑定都被获取到了。这种情况很好地说明了这样一个事实：每个调用都重新创建本地绑定，不同的调用不能相互践踏彼此的本地绑定。</p>
<p>这种能够在封闭作用域内引用本地绑定的特定实例的特性称为闭包。引用来自其周围的本地范围的绑定的函数称为闭包。这种行为不仅让我们不必担心绑定的生命周期，而且让我们能够以某种创造性的方式使用函数值。</p>
<p>只需稍加修改，我们就可以将前面的示例转换为创建可以乘以任意数量函数的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function multiplier(factor) &#123;</span><br><span class="line">  return number =&gt; number * factor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let twice = multiplier(2);</span><br><span class="line">console.log(twice(5));</span><br><span class="line">// → 10</span><br></pre></td></tr></table></figure></p>
<p>实际上并不需要<code>wrapValue</code>示例中显式地进行本地绑定，死板地定下哪个值，因为参数本身就是本地绑定。</p>
<p>想通这样的程序需要一些实践。一个好的理论模型是将函数值看作包含在它们的函数体和创建它们的环境中的代码。调用时，对函数体可见的是创建它的环境，而不是调用它的环境。</p>
<p>在本例中，<code>multiplier</code>被调用并创建了一个<code>factor</code>参数被绑定为2环境。它返回的函数值被存储为<code>twice</code>，会记住这个环境。当它被调用时，它将参数乘以2。</p>
<h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><p>一个函数调用它自神是完全可以的，只要它不过于频繁地这样做以至于溢出堆栈。调用自身的函数称为递归函数。递归允许以不同的风格编写一些函数。以<code>power</code>的这种实现为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function power(base, exponent) &#123;</span><br><span class="line">  if (exponent == 0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return base * power(base, exponent - 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(power(2, 3));</span><br><span class="line">// → 8</span><br></pre></td></tr></table></figure></p>
<p>这与数学家定义取幂的方式相当接近，并且可以说比循环变量更清楚地描述了这个概念。函数用更小的指数多次调用自己来实现重复乘法。</p>
<p>但是这个实现有一个问题:在JavaScript的实现中，它的运行时间大约是循环版本的三倍。运行一个简单的循环通常比多次调用一个函数开销要小。</p>
<p>速度与优雅的两难境地很有趣。你可以把它看作是人类友好型和机器友好型之间的一种连续统一体。几乎任何程序都可以通过使其更大、更复杂来加快速度。程序员必须决定一个适当的平衡。</p>
<p>在<code>power</code>函数的案例中，不优雅的(循环)版本相当简单易读。用递归版本替换它没有多大意义。然而，一个为了更直观而放弃效率的程序通常是更有帮助的。</p>
<p>担心效率会分散注意力。这是使程序设计复杂化的另一个因素，当您你在做一些已经很困难的事情时，额外需要担心的事情可能会使您陷入瘫痪。</p>
<p>因此，总是从写一些无误且容易理解的东西开始。如果你担心它太慢(通常不会)，因为大多数代码的执行频率都不够高，不足以花费大量时间进行度量，如果需要的话，你可以对其进行改进。</p>
<p>递归并不总是循环的低效替代品。有些问题用递归比循环更容易解决。大多数情况下，这些问题需要探索或处理多个分支，每个分支可能会再次扩展到更多的分支。</p>
<p>考虑这个难题：从数字1开始，反复地加5或乘以3，就可以得到一组无限多的数字。你要写一个函数，给定一个数字，试图找到一个加法和乘法的序列，得到这个数字。</p>
<p>例如，数字13可以先乘以3，然后再加两次5，而数字15根本就不能出现在其中。</p>
<p>这是递归版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function findSolution(target) &#123;</span><br><span class="line">  function find(current, history) &#123;</span><br><span class="line">    if (current == target) &#123;</span><br><span class="line">      return history;</span><br><span class="line">    &#125; else if (current &gt; target) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return find(current + 5, `($&#123;history&#125; + 5)`) ||</span><br><span class="line">             find(current * 3, `($&#123;history&#125; * 3)`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return find(1, &quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findSolution(24));</span><br><span class="line">// → (((1 * 3) + 5) * 3)</span><br></pre></td></tr></table></figure></p>
<p>注意，这个程序不一定能找到最短的操作序列。当它找到任何序列时，就满足条件了。</p>
<p>如果你不能马上看到它是如何工作的，也没关系。让我们来过一遍，因为它是一个很好的递归思维练习。</p>
<p>内部函数<code>find</code>执行实际的递归。它接受两个参数：当前数字和一个字符串，该字符串记录了我们如何达到这个数字。如果找到一个解决方案，它将返回一个字符串，该字符串显示如何到达目标。如果无法从这个数字开始找到解决方案，则返回<code>null</code>。</p>
<p>为此，函数执行以下三个操作之一。如果当前数是目标值，则当前历史记录是到达该目标的一种方法，因此将返回它。如果当前数大于目标值，则没有必要进一步研究这个分支，因为加法和乘法只会使这个数变大，因此返回<code>null</code>。最后，如果仍然低于目标值，函数将尝试从当前数开始的两种可能路径，两次调用自己，一次调用加法，一次调用乘法。如果第一个调用返回的东西不是<code>null</code>，那么它将返回。否则，将返回第二个调用，不管它生成的是字符串还是<code>null</code>。</p>
<p>为了更好地理解这个函数是如何给出我们正在寻找的值的，让我们看看在搜索数字13的解决方案时所执行的所有调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">find(1, &quot;1&quot;)</span><br><span class="line">  find(6, &quot;(1 + 5)&quot;)</span><br><span class="line">    find(11, &quot;((1 + 5) + 5)&quot;)</span><br><span class="line">      find(16, &quot;(((1 + 5) + 5) + 5)&quot;)</span><br><span class="line">        too big</span><br><span class="line">      find(33, &quot;(((1 + 5) + 5) * 3)&quot;)</span><br><span class="line">        too big</span><br><span class="line">    find(18, &quot;((1 + 5) * 3)&quot;)</span><br><span class="line">      too big</span><br><span class="line">  find(3, &quot;(1 * 3)&quot;)</span><br><span class="line">    find(8, &quot;((1 * 3) + 5)&quot;)</span><br><span class="line">      find(13, &quot;(((1 * 3) + 5) + 5)&quot;)</span><br><span class="line">        found!</span><br></pre></td></tr></table></figure></p>
<p>缩进表示调用堆栈的深度。第一次调用<code>find</code>时，它首先调用自身来探索以<code>(1 + 5)</code>开头的解决方案。该调用将进一步递归地探索每个产生小于或等于目标数字的连续解决方案。只要它没有找到命中目标的函数，它将返回<code>null</code>给第一个调用。在这里，<code>||</code>操作符导致探索<code>(1 * 3)</code>的调用发生。这个搜索有更多的运气，它的第一次递归调用，再通过另一个递归调用，恰好命中目标值。最内部的调用向上返回一个字符串，中间调用中的每个<code>||</code>操作符都传递该字符串，最终返回解决方案。</p>
<h2 id="Growing-functions"><a href="#Growing-functions" class="headerlink" title="Growing functions"></a>Growing functions</h2><p>将函数引入程序有两种或多或少比较自然的方法。</p>
<p>第一种是，你发现自己多次编写类似的代码。而你不愿意重复编写。有更多的代码意味着有更多的空间来隐藏错误，也意味着人们要理解程序需要阅读更多的内容。所以你把重复的功能合在一起，找了一个好名字，并把它放进一个函数。</p>
<p>第二种是，您发现您需要一些尚未编写的功能，而这些功能听起来应该具有自己的功能。首先给函数命名，然后写出它的主体。您甚至可以在实际定义函数本身之前就开始编写使用该函数的代码。</p>
<p>为一个函数找到一个好名字有多难，这很好地说明了您要包装的概念有多清晰。让我们看一个例子。</p>
<p>我们想要编写一个程序来打印两个数字:农场里奶牛和鸡的数字，奶牛和鸡在它们后面加上单词“Cows”和“Chickens”，在这两个数字前面加0，这样它们就总是三个数字长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">007 Cows</span><br><span class="line">011 Chickens</span><br></pre></td></tr></table></figure></p>
<p>这要求一个函数有两个参数牛的数量和鸡的数量。让我们开始编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function printFarmInventory(cows, chickens) &#123;</span><br><span class="line">  let cowString = String(cows);</span><br><span class="line">  while (cowString.length &lt; 3) &#123;</span><br><span class="line">    cowString = &quot;0&quot; + cowString;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`$&#123;cowString&#125; Cows`);</span><br><span class="line">  let chickenString = String(chickens);</span><br><span class="line">  while (chickenString.length &lt; 3) &#123;</span><br><span class="line">    chickenString = &quot;0&quot; + chickenString;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`$&#123;chickenString&#125; Chickens`);</span><br><span class="line">&#125;</span><br><span class="line">printFarmInventory(7, 11);</span><br></pre></td></tr></table></figure></p>
<p>在字符串表达式之后写入<code>.length</code>将会得到该字符串的长度。因此，<code>while</code>循环不断在数字字符串前面添加零，直到它们至少有三个字符长为止。</p>
<p>任务完成！但就在我们准备把代码(连同一份巨额发票)发送给农民时，她打电话告诉我们，她也开始养猪了，我们能否把软件扩展到打印猪的数量。</p>
<p>我们当然可以。但就在我们再次复制粘贴这四行代码的过程中，我们停下来重新考虑。一定有更好的办法。这是第一次尝试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function printZeroPaddedWithLabel(number, label) &#123;</span><br><span class="line">  let numberString = String(number);</span><br><span class="line">  while (numberString.length &lt; 3) &#123;</span><br><span class="line">    numberString = &quot;0&quot; + numberString;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`$&#123;numberString&#125; $&#123;label&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printFarmInventory(cows, chickens, pigs) &#123;</span><br><span class="line">  printZeroPaddedWithLabel(cows, &quot;Cows&quot;);</span><br><span class="line">  printZeroPaddedWithLabel(chickens, &quot;Chickens&quot;);</span><br><span class="line">  printZeroPaddedWithLabel(pigs, &quot;Pigs&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFarmInventory(7, 11, 3);</span><br></pre></td></tr></table></figure></p>
<p>它成功运行了!但是<code>printZeroPaddedWithLabel</code>这个名称有点尴尬。它将打印、补零和在单个函数中添加标签这三件事合并在一起。</p>
<p>让我们试着挑出一个概念，而不是大量地重复我们的程序的重复部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function zeroPad(number, width) &#123;</span><br><span class="line">  let string = String(number);</span><br><span class="line">  while (string.length &lt; width) &#123;</span><br><span class="line">    string = &quot;0&quot; + string;</span><br><span class="line">  &#125;</span><br><span class="line">  return string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printFarmInventory(cows, chickens, pigs) &#123;</span><br><span class="line">  console.log(`$&#123;zeroPad(cows, 3)&#125; Cows`);</span><br><span class="line">  console.log(`$&#123;zeroPad(chickens, 3)&#125; Chickens`);</span><br><span class="line">  console.log(`$&#123;zeroPad(pigs, 3)&#125; Pigs`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFarmInventory(7, 16, 3);</span><br></pre></td></tr></table></figure></p>
<p>一个具有像<code>zeroPad</code>这样漂亮而明显的名称的函数可以让读代码的人更容易地理解它的功能。这样的函数在很多情况下都是有用的而不仅仅是在这个特定的程序里。例如，您可以使用它来帮助打印排列整齐的数字表。</p>
<p>我们的函数应该有多智能和多用途？我们可以编写任何东西，从一个极其简单的函数(它只能将一个数字填充为三个字符宽)到一个复杂的通用数字格式系统(它处理小数、负数、小数点对齐，用不同字符填充等等)。</p>
<p>一个有用的原则是，除非你绝对确定你会需要它，否则不要添加聪明。为你遇到的每一个功能编写通用框架是很诱人的。抗拒这种冲动。你不会完成任何真正的工作，你只会编写一堆你用不上的代码。</p>
<h2 id="Functions-and-side-effects"><a href="#Functions-and-side-effects" class="headerlink" title="Functions and side effects"></a>Functions and side effects</h2><p>函数可以大致分为它们的额外效果而调用的函数和为了它们的返回值而调用的函数。(当然也有可能产生额外效果并返回一个值。)</p>
<p>农场示例中的第一个辅助函数<code>printZeroPaddedWithLabel</code>被调用，是为了获得它的额外效果：它打印一行字。第二个版本<code>zeroPad</code>是为了获取它的返回值而被调用。第二种方法比第一种方法在更多情况下有用，这并非巧合。有返回值的函数比直接展示额外效果的函数更容易以新方式组合。</p>
<p>纯函数是一种特殊的值生成函数，它不仅没有额外效果，且不依赖于来自其他代码的额外效果，例如，它不读取值可能发生变化的全局绑定。纯函数有一个令人愉快的特性，当使用相同的参数调用它时，它总是生成相同的值(并且不做任何其他事情)。对这样一个函数的调用可以用它的返回值代替，而不改变代码的含义。当您不确定一个纯函数是否正确工作时，您可以通过简单地调用来测试它，并知道如果它在该上下文中是否有效。非纯函数往往需要更多的脚手架来测试。</p>
<p>不过，在编写不纯的函数没有必要感到难受，或发动圣战将它们从代码中清除时。额外效果通常是有用的。没有办法编写一个纯函数版的<code>console.log</code>，<code>console.log</code>的存在很美好。当我们使用副作用时，一些操作也更容易以有效的方式表达，因此计算速度可以成为避免纯化的一个原因。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>本章教你如何编写自己的函数。<code>function</code>关键字用作表达式时，可以创建函数值。当作为语句使用时，可以使用它声明绑定并将函数作为其值。箭头函数是另一种创建函数的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Define f to hold a function value</span><br><span class="line">const f = function(a) &#123;</span><br><span class="line">  console.log(a + 2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Declare g to be a function</span><br><span class="line">function g(a, b) &#123;</span><br><span class="line">  return a * b * 3.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A less verbose function value</span><br><span class="line">let h = a =&gt; a % 3;</span><br></pre></td></tr></table></figure></p>
<p>理解函数的一个关键方面是理解作用域。每个块创建一个新的作用域。在给定作用域中声明的参数和绑定是局部的，从外部是不可见的。使用<code>var</code>声明的绑定的行为不同，它们最终位于最近的函数作用域或全局作用域。</p>
<p>将程序执行的任务分离到不同的函数中是有帮助的。您不需要重复很多次，而且函数可以通过将代码分组到执行特定任务的各个部分来帮助组织程序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/03/27/译-eloquent-javascript-Functions/" data-id="cjy2fdnv5000hd0or2pwi5z3w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-eloquent-javascript-Values-Types-and-Operators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/译-eloquent-javascript-Values-Types-and-Operators/" class="article-date">
  <time datetime="2019-03-27T04:03:34.000Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/译-eloquent-javascript-Values-Types-and-Operators/">译-eloquent-javascript-Values,Types and Operators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>“在机器的表面之下，是程序在运作。无需做功，它就会扩张和收缩。在大和谐中，电子分散重组。显示器上的图形不过是水面上的涟漪。它的本质隐藏在下面。”—-Master Yuan-Ma, The Book of Programming</p>
</blockquote>
<p><img src="https://eloquentjavascript.net/img/chapter_picture_1.jpg" alt="img"></p>
<p>在计算机的世界里，只有数据。您可以读取数据、修改数据、创建新数据，但是绝不能涉及到非数据的东西。所有这些数据都存储为长序列的比特位，因此本质上是相似的。</p>
<p>比特（Bit）是任何两值的东西，通常被描述为0和1。在计算机内部,他们把形式如高低电平,强弱信号或CD表面的明暗斑点。任何离散的信息都可以转化为一系列的0和1,从而用比特位（Bit）展现出来。</p>
<p>例如，我们可以用比特来表示数字13。它的工作原理与十进制数相同，但它用到的不是10个不同的数字，只有2个，而且每个数的权值从右到左增加了2倍。下面是组成数字13的比特位，数字的权值如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  0   0   0   0   1   1   0   1</span><br><span class="line">128  64  32  16   8   4   2   1</span><br></pre></td></tr></table></figure></p>
<p>这就是二进制数00001101。它的非零比特位意味着，8、4和1加起来是13。</p>
<h2 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h2><p>想象一片由比特的海洋一个小块的海洋。典型的现代计算机在其易失性数据存储(运行内存)中有300多亿比特。非易失性存储(硬盘或类似的存储)往往还有几个数量级。</p>
<p>为了能够在不丢失信息的情况下处理如此多的比特，我们必须将它们分割成表示信息片段的块。在JavaScript环境中，这些块称为值。虽然所有的值都是由比特组成的，但是它们发挥着不同的作用。每个值都有一个类型来决定其定位。有些值是数字，有些值是文本片段，有些值是函数，等等。</p>
<p>要创建一个值，你只需要调用它的名称。这是很方便的。你不需要为你的值收集建筑材料，也不需要为它们买单。你只要调用一下，呼，就行了。当然，它们并不是凭空产生的。每个值都必须存储在某个地方，如果您想同时运算大量的值，可能会耗尽内存。幸运的是，只有当您同时需要它们时，这个问题才会发生。一旦你不再使用一个值，它就会消失，留下它的比特回收，作为下一代的值的建筑材料。</p>
<p>本章介绍JavaScript程序的基础，即简单的数值类型以及可以对这些值进行运算的操作符。</p>
<h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><p>毫无疑问，数字类型的值是数值。在JavaScript程序中，它们是这样编写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>在程序中使用它，将导致数字13的比特在计算机内存中以一定模式形成。</p>
<p>JavaScript使用定长的位(64位)来存储单个数字值。而使用64位只能弄出这么点儿花样，这意味着可以表示出的不同数字的数量是有限的。用N位十进制数，可以表示出10<sup>N</sup>个数字。同样，用64位二进制数字，可以表示出2<sup>64</sup>个不同的数字，大约是18万兆(18后面有18个零)。那可是个大数。</p>
<p>过去，计算机内存要小得多，人们倾向于使用8位或16位的组合来表示数字。这么小的数字一不小心就很容易超出给定的大小，结果得到一个与给定位数不符的数字。今天，即使是放在口袋里的电脑也有足够的内存，所以你可以自由地使用64位的数据块，只有在处理真正天文数字时才需要担心内存溢出。</p>
<p>不过，并非所有小于18万兆的整数都可以被JavaScript表示出来。这些位空间也存储负数，所以有1位被用来表示数字的正负符号。更大的问题是，还需要表示非整数。为此，一些位被用来存储小数点的位置。实际可存储的最大整数更多地在9千兆(15个零)的范围内，这仍然是一个令人愉快的巨大数字。</p>
<p>小数是用加点来表示的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9.81</span><br></pre></td></tr></table></figure></p>
<p>对于非常大或非常小的数字，可以使用科学计数，在数字的指数前面加上e(代表指数)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.998e8</span><br></pre></td></tr></table></figure></p>
<p>这是 2.998 x 10<sup>8</sup> = 299,800,000</p>
<p>使用上述的小于9千兆的整数进行计算，可以保证结果始终是精确的。不幸的是，使用小数的计算通常不是。就像π不能用有限小数精确表达一样,许多数字因只有64位可用来存储它们而失去了一些精度。这是一个遗憾，但它只在特定的情况下造成实际问题。重要的是要意识到这一点，并将分数数字视为近似值，而不是精确值。</p>
<h2 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h2><p>与数字关系密切的事就是算术。算术运算，如加法或乘法，取两个数值，并得到一个新的数字。下面是它们在JavaScript中的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 + 4 * 11</span><br></pre></td></tr></table></figure></p>
<p><code>+</code>和<code>*</code>符号称为运算符。第一个代表加法，第二个代表乘法。将运算符放在两个值之间将作用于这些值并生成一个新值。</p>
<p>但是这个例子的意思是加4和100，再把结果乘以11，还是在加之前就做了乘法？你可能已经猜到了，乘法先运算。但就像在数学中一样，你可以通过把加法括在括号里来改变顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(100 + 4) * 11</span><br></pre></td></tr></table></figure></p>
<p>对于减法，有<code>-</code>运算符，除法有<code>/</code>运算符。</p>
<p>当运算符一起出现而没有括号时，它们的应用顺序由运算符的优先级决定。这个例子表明乘法先于加法，<code>/</code>运算符的优先级与<code>*</code>相同，<code>+</code>和<code>-</code>也相同。当具有相同优先级的多个运算符彼此相邻出现时，如在<code>1 - 2 + 1</code>中，它们从左向右运算: <code>( 1 - 2 ) + 1</code>。</p>
<p>你不用担心这些优先级规则。在不确定时，加上括号即可。</p>
<p>还有一个算术运算符，您可能不会马上认出来。<code>%</code>符号用于表示求余运算。<code>X % Y</code>是<code>X</code>除以<code>Y</code>的余数。例如，<code>314 % 100</code>得到<code>14</code>,<code>144 % 12</code>得到<code>0</code>。余数运算符的优先级与乘除运算的优先级相同。您还将经常看到这个运算符被称为模。</p>
<h2 id="Special-numbers"><a href="#Special-numbers" class="headerlink" title="Special numbers"></a>Special numbers</h2><p>JavaScript中有三个特殊值被认为是数字，但它们的行为与普通数字不同。</p>
<p>前两个是<code>Infinity</code>和<code>- Infinity</code>，它们表示正无穷和负无穷。<code>Infinity - 1</code>仍然是<code>Infinity</code>，依此类推。不过，不要过于相信基于无穷大的计算。它在数学上是不合理的，它引出了下一个特殊值：<code>NaN</code>。</p>
<p><code>NaN</code>意味着“不是数字（not a number）”，尽管如此它却是数字类型的值。例如，当你尝试计算<code>0 / 0</code> (零除以零)、<code>Infinity - Infinity</code>或任何产生无意义结果的数值运算时，就会得到这个结果。</p>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>下一个基本数据类型是字符串。字符串用于表示文本。要编写字符串需要将它们包含在引号之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`Down on the sea`</span><br><span class="line">&quot;Lie on the ocean&quot;</span><br><span class="line">&apos;Float on the ocean&apos;</span><br></pre></td></tr></table></figure></p>
<p>您可以使用单引号、双引号或反引号来标记字符串，只要字符串的开头和结尾的引号匹配即可。</p>
<p>几乎任何东西都可以放在引号之间，JavaScript会从中生成一个字符串值。但是有几个字符比较难。您可以想象为引号之间的内容加上引号是多么困难。有当字符串被反引号（`）括起来的时候‘换行’(按enter时得到的字符)才不会被弄丢。</p>
<p>为了能在字符串中表示出这样的字符，要用到以下表示法：无论何时在引用的文本中发现反斜杠（\），它都表示后面的字符具有特殊的含义。这叫做转义字符。前加反斜杠的引号（\“）不会结束字符串，而是字符串的一部分。当反斜杠后面出现一个n时，它被解释为换行符。类似地，反斜杠后面跟t表示制表符。下面的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;This is the first line\nAnd this is the second&quot;</span><br></pre></td></tr></table></figure></p>
<p>实际呈现出的文本会是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the first line</span><br><span class="line">And this is the second</span><br></pre></td></tr></table></figure></p>
<p>当然，在某些情况下，您希望字符串中的反斜杠只是反斜杠，而不是特殊代码。如果两个反斜杠紧密相依，它们就会崩塌，结果字符串值中只剩下一个反斜杠。下面就是如何将“A newline character is written like “\n”.”表示出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A newline character is written like \&quot;\\n\&quot;.&quot;</span><br></pre></td></tr></table></figure></p>
<p>字符串也必须被转换为一系列的位，才能够存在于计算机中。JavaScript基于Unicode标准实现字符串的存储。这个标准几乎为你需要的每个字符分配了一个数字，包括来自希腊、阿拉伯、日本、美国等国家的字符。如果每个字符都有一个数字，那么字符串可以由一系列数字来描述。</p>
<p>这就是JavaScript所做的。但是有一个复杂之处：JavaScript使用16比特来表示每一个字符串中的元素，最多可以描述2<sup>16</sup>个不同的字符。但是Unicode定义的字符比这个多，大约是这个数字的两倍。因此，一些字符，比如许多表情符号，在JavaScript字符串中占据两个字符位。我们将在第5章中回到这一点。</p>
<p>字符串不能被除、乘或减，但可以对其使用<code>+</code>运算符。它不执行加法，而是将两个字符串拼接在一起。下面的相加将生成字符串“concatenate”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;con&quot; + &quot;cat&quot; + &quot;e&quot; + &quot;nate&quot;</span><br></pre></td></tr></table></figure></p>
<p>字符串值有许多与之相关的，可以对其进行其他操作的函数(方法)。我将在第4章详细介绍这些。</p>
<p>使用单引号或双引号编写的字符串的行为非常相似，唯一的区别是你需要在其中显示哪种类型的引号。反引号引用的字符串，通常称为模板字符串，可以衍生出更多的技巧。除了能够跨行之外，它们还可以嵌入其他值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`half of 100 is $&#123;100 / 2&#125;`</span><br></pre></td></tr></table></figure></p>
<p>当您在模板字符串中的<code>${ }</code>中写入表达式时，JavaScript将会执行里面的内容，并将其结果转换为字符串，将其包含在该位置。这个例子的结果是 “half of 100 is 50”。</p>
<h2 id="Unary-operators"><a href="#Unary-operators" class="headerlink" title="Unary operators"></a>Unary operators</h2><p>并不是所有的运算符都是符号。有些被写成词组。其中一个例子是<code>typeof</code>操作符，它生成一个表明你给定的值的类型的字符串值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof 4.5)</span><br><span class="line">// → number</span><br><span class="line">console.log(typeof &quot;x&quot;)</span><br><span class="line">// → string</span><br></pre></td></tr></table></figure></p>
<p>在示例代码中，我们将使用<code>console.log</code>来表示我们想要看到运行结果。下一章会详细介绍。</p>
<p>其他已经出现的运算符都是对两个值进行操作的运算，但是<code>typeof</code>只接受一个值。使用两个值的运算符称为二元运算符，而使用一个值的运算符称为一元运算符。<code>-</code>既可用作二元运算符，也可用作一元运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(- (10 - 2))</span><br><span class="line">// → -8</span><br></pre></td></tr></table></figure></p>
<h2 id="Boolean-values"><a href="#Boolean-values" class="headerlink" title="Boolean values"></a>Boolean values</h2><p>用一个值可以区分仅有的两种可能性，比如“yes”和“no”或“on”和“off”，这通常是很有用的。为此，JavaScript有一个布尔类型，这种类型总共只有两个值，<code>true</code>和<code>false</code>，就以这两个单词的形式拼写。</p>
<h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><p>有一种产生Boolean值的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(3 &gt; 2)</span><br><span class="line">// → true</span><br><span class="line">console.log(3 &lt; 2)</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p>>和&lt;符号分别表示大于和小于。它们是二元运算符。它们的运算会得到一个布尔值，该值表明它们在本例中是否成立。</p>
<p>字符串可以用同样的方法进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Aardvark&quot; &lt; &quot;Zoroaster&quot;)</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure></p>
<p>字符串的排序方式大致是按字母顺序排列的，但并不严格是您所期望的在字典中看到的顺序:大写字母总是小于小写字母，因此“Z”&lt;“a”和非字母字符(!， -，等等)也包括在排序之中。当比较字符串时，JavaScript从左到右遍历字符，逐个比较Unicode码。</p>
<p>其他类似的操作符有&gt;=(大于或等于)、&lt;=(小于或等于)、==(等于)和!=(不等于)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Itchy&quot; != &quot;Scratchy&quot;)</span><br><span class="line">// → true</span><br><span class="line">console.log(&quot;Apple&quot; == &quot;Orange&quot;)</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p>JavaScript中只有一个值不等于它自己，那就是<code>NaN</code>(不是数字)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN == NaN)</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p><code>NaN</code>应该表示无意义计算的结果，因此，它不等于任何其他无意义计算的结果。</p>
<h2 id="Logical-operators"><a href="#Logical-operators" class="headerlink" title="Logical operators"></a>Logical operators</h2><p>还有一些运算可以应用到布尔值上。JavaScript支持三个逻辑操作符：<code>and</code>, <code>or</code>, 和 <code>not</code>。这些可以用来演算布尔值。</p>
<p>&amp;&amp;操作符表示逻辑与。它是一个二元运算符，只有当给定的两个值都为真时，它的结果才为真。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(true &amp;&amp; false)</span><br><span class="line">// → false</span><br><span class="line">console.log(true &amp;&amp; true)</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure></p>
<p>||操作符表示逻辑或。如果给定的值有一个为真，结果就为真。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(false || true)</span><br><span class="line">// → true</span><br><span class="line">console.log(false || false)</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p>逻辑非被写成感叹号(!)。这是一个一元运算符，它翻转给它的值，<code>!true</code>产生<code>false</code>，而<code>!false</code>给出<code>true</code>。</p>
<p>当将这些布尔运算符与算术运算符和其他运算符混合使用时，需要用到括号的时机总是不明显。在实践中，通常只会出现以上的操作符，因此有必要记一下，<code>||</code>的优先级最低，然后是<code>&amp;&amp;</code>，然后是比较操作符(&gt;，==，等等)，然后是其他操作符。选择这种顺序的原因是，在下面的典型表达式中，括号越少越好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 1 == 2 &amp;&amp; 10 * 10 &gt; 50</span><br></pre></td></tr></table></figure></p>
<p>我将提到的最后一个逻辑运算符不是一元的，也不是二元的，而是三元的，它对三个值进行运算。它由问号和冒号组成，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(true ? 1 : 2);</span><br><span class="line">// → 1</span><br><span class="line">console.log(false ? 1 : 2);</span><br><span class="line">// → 2</span><br></pre></td></tr></table></figure></p>
<p>这个操作符称为条件操作符(有时也称为三元操作符，因为它是语言中惟一的三元操作符)。问号左边的值决定表达式的最终值为另外两个值中的哪一个。当它为真时，它选择中间的值，当它为假时，它选择右边的值。</p>
<h2 id="Empty-values"><a href="#Empty-values" class="headerlink" title="Empty values"></a>Empty values</h2><p>有两个特殊值，写做<code>null</code>和<code>undefined</code>，用于表示没有有意义的值。它们本身就是价值观念，但不包含任何信息。</p>
<p>语言中的许多操作并不能产生有意义的值(稍后您将看到一些)，它们产生的结果将是<code>undefined</code>，因为它们必须产生一些值。</p>
<p><code>undefined</code>和<code>null</code>之间的含义差异是JavaScript设计的一个意外，在大多数情况下并不重要。在实际需要关注这些值的情况下，我建议将它们视为可互换的。</p>
<h2 id="Automatic-type-conversion"><a href="#Automatic-type-conversion" class="headerlink" title="Automatic type conversion"></a>Automatic type conversion</h2><p>在Introduction中，我提到JavaScript会不遗余力地接受您提供的几乎所有程序，即使是执行奇怪任务的程序。下面的表达式很好地说明了这一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(8 * null)</span><br><span class="line">// → 0</span><br><span class="line">console.log(&quot;5&quot; - 1)</span><br><span class="line">// → 4</span><br><span class="line">console.log(&quot;5&quot; + 1)</span><br><span class="line">// → 51</span><br><span class="line">console.log(&quot;five&quot; * 2)</span><br><span class="line">// → NaN</span><br><span class="line">console.log(false == 0)</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure></p>
<p>当运算符作用于错误类型的值时，JavaScript将使用一组您通常不想要或不期望的规则悄悄地将该值转换为所需的类型。这被称为“强制类型转换”。第一个表达式中的<code>null</code>变为<code>0</code>，第二个表达式中的<code>“5”</code>变为<code>5</code>(从字符串到数字)。但是在第三个表达式中，<code>+</code>尝试在数字加法之前进行字符串连接，因此<code>1</code>被转换为<code>“1”</code>(从数字到字符串)。</p>
<p>当一个不容易轻松被转换成数字的东西(如<code>“5”</code>或<code>undefined</code>)被强制转换成数字时，您将得到值<code>NaN</code>。对<code>NaN</code>的进一步算术运算将继续生成<code>NaN</code>，因此，如果您发现自己在一个意想不到的地方得到了其中的一个，请寻找意料之外的类型转换。</p>
<p>当使用<code>==</code>比较相同类型的值时，结果很容易预测:当两个值相同时，<code>NaN</code>除外，您应该得到<code>true</code>。但是当类型不同时，JavaScript使用一组复杂而令人困惑的规则来决定该做什么。在大多数情况下，它只是尝试将其中一个值转换为另一个值的类型。但是，当<code>null</code>或<code>undefined</code>出现在操作符的任意一边时，只有当两边都是<code>null</code>或<code>undefined</code>时才会产生<code>true</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(null == undefined);</span><br><span class="line">// → true</span><br><span class="line">console.log(null == 0);</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p>这种行为通常很有用的。当您想要测试一个值是否具有实值而不是<code>null</code>或<code>undefined</code>时，可以使用<code>=</code>=(或<code>!=</code>)操作符将其与<code>null</code>进行比较。</p>
<p>但是，如果您想测试某个东西是否精确地引用了<code>false</code>呢?由于自动类型转换，像<code>0 == false</code>和<code>&quot;&quot; == false</code>这样的表达式也为真。当您不希望发生任何类型转换时，有两个额外的操作符:<code>===</code>和<code>!==</code>。第一个测试值是否与另一个值完全相等，第二个测试值是否完全不相等。所以<code>&quot;&quot; === false</code>将得到<code>false</code>。</p>
<p>我建议防御性地使用三个字符比较操作符，以防止意外的类型转换阻挠你的编程。但是，当您确定两边的类型相同时，使用较短的操作符也是没有问题的。</p>
<h2 id="Short-circuiting-of-logical-operators"><a href="#Short-circuiting-of-logical-operators" class="headerlink" title="Short-circuiting of logical operators"></a>Short-circuiting of logical operators</h2><p>逻辑运算符<code>&amp;&amp;</code>和<code>||</code>以一种特殊的方式处理不同类型的值。它们将左边的值转换为Boolean类型，以便决定接下来要做什么，但是根据操作符和转换的结果的不同，它们将返回原表达式的左边值或右边值。</p>
<p>例如，当可以将<code>||</code>左边的值转换为<code>true</code>时，<code>||</code>操作符将返回它左边的值，否则将返回它右边的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(null || &quot;user&quot;)</span><br><span class="line">// → user</span><br><span class="line">console.log(&quot;Agnes&quot; || &quot;user&quot;)</span><br><span class="line">// → Agnes</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用此功能作为返回到默认值的方法。如果您有一个值可能是空值，您可以在它后面加上一个<code>||</code>和替换值。如果可以将初始值转换为<code>false</code>，则会得到替换值。将字符串和数字转换为布尔值的规则规定，<code>0</code>、<code>NaN</code>和空字符串(<code>&quot;&quot;</code>)被视为<code>false</code>，而所有其他值都被视为<code>true</code>。<code>0 | | 1</code>得到<code>-1</code>,<code>&quot;&quot;| |&quot;!?&quot;</code>得到<code>!?</code>。</p>
<p><code>&amp;&amp;</code>操作符的工作原理与此类似，但正好相反。当其左边的值被转换为false时，它返回该值（<code>false</code>），否则返回其右边的值。</p>
<p>这两个操作符的另一个重要特性是，它们右边的部分只有在需要时才会被运算。在<code>true || X</code>的情况下，不管<code>X</code>是多少，即使它是一个做了一些差劲的事情程的序，结果都将是<code>true</code>，<code>X</code>永远不会被运算。对于<code>false &amp;&amp; X</code>也是一样，它是<code>false</code>，将忽略<code>X</code>。这称为短路求值。</p>
<p>条件运算符的工作原理类似。在第二个和第三个值中，只对选中的值求值。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在本章中，我们研究了四种类型的JavaScript值:数字、字符串、布尔值和未定义值。</p>
<p>这些值是通过键入它们的名称(<code>true</code>、<code>null</code>)或值( <code>13</code>，<code>&quot;abc&quot;</code>)创建的。您可以用运算符组合和转换值。我们看到了算术( <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、和<code>%</code>)、字符串连接( <code>+</code> )、比较( <code>==</code>、<code>!=</code>，<code>===</code>，<code>!==</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> )和逻辑( <code>&amp;&amp;</code>、<code>||</code> )运算符，以及几个一元运算符( <code>-</code>表示负数，<code>!</code>表示逻辑上否定，<code>typeof</code>找到值的类型)和三元运算符(<code>?:</code> )根据第三个值从两个值中选择一个。</p>
<p>这为您提供了足够的信息来使用JavaScript作为袖珍计算器，但仅此而已。下一章将开始把这些表达式绑定到基本程序中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/03/27/译-eloquent-javascript-Values-Types-and-Operators/" data-id="cjy2fdnvd000kd0ortw85n01u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-eloquent-javascript-Introduction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/译-eloquent-javascript-Introduction/" class="article-date">
  <time datetime="2019-03-11T11:13:19.000Z" itemprop="datePublished">2019-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/译-eloquent-javascript-Introduction/">[译]Eloquent Javascript Introduction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>我们认为我们创造这个系统是为了我们自己的目的。我们相信我们正在按照自己的想象去做……但是电脑并不像我们。它是我们自身非常微小的一部分的投影:致力于逻辑、秩序、规则和清晰的那部分。—-Ellen Ullman，《Close to the Machine: Technophilia and its Discontents》</p>
</blockquote>
<p><img src="https://eloquentjavascript.net/img/chapter_picture_00.jpg" alt="img"></p>
<p>这是一本关于指挥计算机的书。如今，计算机就像螺丝刀一样常见，但它们要复杂得多，让它们做你想让它们做的事情并不总是那么容易。</p>
<p>如果你安排给电脑的是一个常见的，很容易理解的任务，比如显示你的电子邮件或发挥一个计算器的作用，你可以打开适当的应用程序开始工作。但对于独特的或开放式的任务，可能没有相应的应用程序。</p>
<p>这就是编程的用武之地。编程是建立一个程序的行为，建立一组精确的指令告诉计算机要做什么。由于计算机是愚蠢的、迂腐的野兽，编程从根本上来说是乏味和令人沮丧的。</p>
<p>幸运的是，如果你能克服这一事实，甚至能享受到用愚蠢的机器所能处理的方式进行严谨思考的乐趣，那么编程将是有益的。它可以让你在几秒钟内完成那些人力完成需要花费大量时间的事情。这是一种让你的电脑工具做它以前不能做的事情的方法。它提供了一个绝佳的抽象思维练习。</p>
<p>大多数程序都是用编程语言完成的。编程语言是一种人工构造的，用于指挥计算机的语言。有趣的是，我们所建立的与电脑沟通的最有效的方式，很大程度上借鉴了人与人之间沟通的方式。像人类语言一样，计算机语言允许单词和短语以新的方式组合在一起，使表达新的概念成为可能。</p>
<p>基于文字的界面，例如20世纪80年代和90年代的BASIC和DOS提示符，一度是与计算机交互的主要方法。它们在很大程度上已经被视觉界面所取代，视觉界面更容易学习，但提供的自由度更小。计算机语言仍然存在，如果你知道去哪里找的话。JavaScript就是这样一种语言，它内置在每个现代web浏览器中，因此几乎可以在任何设备上使用。</p>
<p>读完这本书后，你将足够熟悉这种语言，并用它做一些有用的和有趣的事情。</p>
<h2 id="On-programming"><a href="#On-programming" class="headerlink" title="On programming"></a>On programming</h2><p>除了解释JavaScript，我还将介绍编程的基本原理。事实证明，编程并不容易。基本规则简单明了，但是基于这些规则构建的程序往往会变得十分复杂，恰好展现出其规则性与复杂性。如果你正在建造自己的迷宫，你可能会迷失其中。</p>
<p>读者在阅读这本书时，有时会感到相当沮丧。如果你是编程新手，将会有很多新内容需要消化。并且之后你可以将这些内容通过额外的知识链接起来。</p>
<p>你可以做出必要的努力。当你在努力学习这本书的时候，不要对自己的能力妄下结论。你很棒-你只需要坚持下去。休息一下，重新阅读一些材料，确保你已经阅读并理解了示例程序和练习。学习是一项艰苦的工作，但你所学的一切都是你自己的，并且会让你以后的学习变得更容易。</p>
<blockquote>
<p>“当行动变得无利可图时，收集信息;当信息变得无利可图时，睡觉。”—-Ursula K. Le Guin, The Left Hand of Darkness</p>
</blockquote>
<p>程序是很多东西。它是由程序员输入的一段文本，它是使计算机做它所做的事情的指导力量，它是计算机内存中的数据，而且它还控制在同一内存上执行的操作。我们无法将程序与我们熟悉的对象进行类比。有一种看起来类似的机器，它由许多独立部件组成，为了使整个机器运转起来，我们必须考虑这些部件相互连接的方式，并对整个机器的运转做出贡献。</p>
<p>计算机是一种物理机器，充当这些非物质机器的主机。计算机本身只能做一些愚蠢而简单的事情。计算机如此有用的原因是它能以惊人的速度做这些事情。而程序可以巧妙地将大量简单的操作结合起来以完成非常复杂的事情。</p>
<p>程序就像是一座思想的大楼。它建造成本低，重量轻，而且在我们敲代码时很容易层层增高。</p>
<p>但是如不谨慎对待，程序的大小和复杂性将会失控，甚至会使创建它的人感到困惑。控制程序是编程的主要问题。当程序有用时，它是美丽的。编程的艺术是控制复杂性的技巧。伟大的计划因其复杂性而变得简单。</p>
<p>一些程序员认为，只有在他们的程序中使用一些易于理解的技巧，才能最好地管理这种复杂性。他们制定了严格的规则(最佳实践)，规定了程序该长成啥样，并留在他们的安全的小区域中。</p>
<p>这不仅无聊，而且低效。新问题往往需要新的解决方案。编程领域未发展成熟，仍在快速发展，它的多样性足以容纳各种各样的方法。在程序设计中有很多可怕的错误，你应该敢于犯这些错，这样你才能理解它们。一个好的程序该长成啥样的直觉是从实践中发现的，而不是从一堆规则中学到的。</p>
<h2 id="Why-language-matters"><a href="#Why-language-matters" class="headerlink" title="Why language matters"></a>Why language matters</h2><p>在计算机诞生之初，还没有编程语言。程序是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00110001 00000000 00000000</span><br><span class="line">00110001 00000001 00000001</span><br><span class="line">00110011 00000001 00000010</span><br><span class="line">01010001 00001011 00000010</span><br><span class="line">00100010 00000010 00001000</span><br><span class="line">01000011 00000001 00000000</span><br><span class="line">01000001 00000001 00000001</span><br><span class="line">00010000 00000010 00000000</span><br><span class="line">01100010 00000000 00000000</span><br></pre></td></tr></table></figure></p>
<p>这是一个把1到10的数字加在一起并打印出结果的程序:1 + 2 +…+ 10 = 55。它可以在一台简单的假想机器上运行。为了给早期的计算机编程，需要在正确的位置设置大量的开关阵列，或者在卡纸条上打孔，然后把它们输入计算机。你也许可以想象到这个过程是多么乏味和容易出错。即使是编写简单的程序也需要高智商和大量训练。复杂的程序更是几乎是不可想象的。</p>
<p>当然，手工输入这些神秘的比特语句(1和0组成)确实给了程序员一种成为强大巫师的强烈感觉。这在工作满意度方面还是有价值的。</p>
<p>前一个程序的每一行都包含一条指令。它可以这样用文字表述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 将数字0存储在内存位置0中。</span><br><span class="line">2. 将数字1存储在内存位置1中。</span><br><span class="line">3. 将内存位置1的值存储在内存位置2中。</span><br><span class="line">4. 从内存位置2的值中减去数字11。</span><br><span class="line">5. 如果内存位置2中的值是0，则从指令9继续执行。</span><br><span class="line">6. 将内存位置1的值加到内存位置0。</span><br><span class="line">7. 内存位置1的值加1。</span><br><span class="line">8. 从指令3继续执行。</span><br><span class="line">9. 输出内存位置0的值。</span><br></pre></td></tr></table></figure></p>
<p>尽管这已经比一堆比特更容易读懂，但它仍然相当晦涩。对指令和内存位置使用名称而不是数字会有所帮助。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set “total” to 0.</span><br><span class="line"> Set “count” to 1.</span><br><span class="line">[loop]</span><br><span class="line"> Set “compare” to “count”.</span><br><span class="line"> Subtract 11 from “compare”.</span><br><span class="line"> If “compare” is zero, continue at [end].</span><br><span class="line"> Add “count” to “total”.</span><br><span class="line"> Add 1 to “count”.</span><br><span class="line"> Continue at [loop].</span><br><span class="line">[end]</span><br><span class="line"> Output “total”.</span><br></pre></td></tr></table></figure></p>
<p>现在能看到程序是如何工作的吗？前两行给出了两个内存位置的初始值:<code>total</code>将用于构建计算结果，<code>count</code>将跟踪我们当前正在查看的数字。使用<code>compare</code>的代码行可能是最奇怪的。程序想要查看<code>count</code>是否等于11，以决定是否可以停止运行。因为我们假想机相当原始，它只能检测一个数字是否为零，然后据此做出决定。因此，它使用标记为<code>compare</code>的内存位置来计算<code>count - 11</code>的值，并根据该值做出决策。接下来的两行将<code>count</code>的值添加到结果中，每当程序确定<code>count</code>还不是11时，就将<code>count</code>增加1。</p>
<p>下面是用JavaScript编写的相同程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let total = 0, count = 1;</span><br><span class="line">while (count &lt;= 10) &#123;</span><br><span class="line">  total += count;</span><br><span class="line">  count += 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(total);  // → 55</span><br></pre></td></tr></table></figure></p>
<p>这个版本有了更多的改进。最重要的是，不再需要指定按照我们希望的方式程序来回跳转。<code>while</code>将负责处理这个问题。只要给定的条件依然成立，它就会继续执行它下面的块(大括号括起来的部分)。该条件是<code>count &lt;= 10</code>，这意味着<code>count</code>小于或等于10。我们不再需要创建一个临时值并将其与零进行比较，这只是细枝末节。编程语言的部分能力在于，它们可以为我们处理这些无趣的细节。</p>
<p>在程序的末尾，<code>while</code>执行完成后，使用<code>console.log</code>操作写出结果。</p>
<p>最后，如果我们碰巧有方便的操作<code>range</code>和<code>sum</code>可用，程序可能是这样的，它们分别在一个范围内创建一个数字集合并计算一个数字集合的和：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(range(1, 10)));</span><br><span class="line">// → 55</span><br></pre></td></tr></table></figure></p>
<p>这个故事的寓意是，同一个程序可以用长和短、不可读和可读的方式表达。该程序的第一个版本非常晦涩难懂，而最后一个版本几乎是英语版本:记录从1到10的数字的总和。（<code>log</code> the <code>sum</code> of the <code>range</code> of numbers from 1 to 10）</p>
<p>好的编程语言可以通过允许程序员讨论计算机必须在更高的层次上执行的操作来帮助他们。它有助于省略细节，提供方便的积木(如<code>while</code>和<code>console.log</code>)，允许您定义自己的积木(如<code>sum</code>和<code>range</code>)，并使这些块易于组合。</p>
<h2 id="What-is-JavaScript"><a href="#What-is-JavaScript" class="headerlink" title="What is JavaScript?"></a>What is JavaScript?</h2><p>JavaScript是在1995年发布的，用于向Netscape Navigator浏览器中向web页面添加程序。该语言自那时起已被所有其他主要的图形web浏览器所采用。它使现代web应用程序成为可能，你可以直接与之交互，而不必为每个操作重新加载页面。JavaScript也被用于更传统的网站，以提供各种形式的交互性和智能。</p>
<p>值得注意的是，JavaScript与名为Java的编程语言几乎没有任何关系。类似的名字是出于营销考虑，而不是良好的判断。当JavaScript被发布时，Java语言正被大力推广，并且越来越受欢迎。有人认为蹭名字是一个好主意，但现在我们被这个名字困住了。</p>
<p>当JavaScript在Netscape之外的环境被采用之后，一个描述JavaScript的工作方式的标准文档横空出世，以便各种声称支持JavaScript的软件使用的真的是同一种语言。这被称为ECMAScript标准，以执行标准化的Ecma国际组织命名。实际上，ECMAScript和JavaScript可以互换使用，它们是同一种语言的两个名称。</p>
<p>有些人会说JavaScript的坏话。这些事情很多都是真的。当我第一次被要求用JavaScript写东西时，我很快就开始嫌弃它。它几乎可以接受我输入的任何内容，但解释它的方式与我的本意完全不同。当然，这在很大程度上与我不知道自己在做什么有关，但是这里有一个真正的问题:JavaScript在它所允许的方面是非常自由的。这种设计的本意是使初学者更容易使用JavaScript编程。实际上，它主要使在程序中查找问题变得更加困难，因为系统不会向您指出这些问题。</p>
<p>不过，这种灵活性也有其优势。它衍生出了许多在更严格的语言中不可能出现的技巧，正如您将看到的(例如在第10章)，它可以用来克服JavaScript的一些缺点。在正确地学习了这门语言并使用它一段时间之后，我已经学会了真正喜欢JavaScript。</p>
<p>JavaScript有几个版本。ES3在JavaScript逐渐占据主导地位的时期(大约在2000年到2010年之间)得到了广泛支持。在此期间，一个雄心勃勃的版本ES4正在制定，该版本计划对该语言进行一些根本性的改进和扩展。以这样一种激进的方式改变一种被广泛使用的语言，在策略上是行不通的。2008年，ES4的开发工作被放弃，导致第5版的开发远没有那么雄心勃勃，它在2009年只做了一些毫无争议的改进。2015年，ES6发布了，这是一个重大的更新，包括了第4版计划中的一些想法。从那以后，我们每年都可以看到新的小更新。</p>
<p>语言不断发展的事实意味着浏览器必须不断跟进，如果您使用的是较老的浏览器，它可能不支持现有的所有功能。语言设计者必须非常小心，不做任何可能破坏现有程序的更改，因此新浏览器仍然可以运行旧程序。在这本书中，我使用的是2017年版的JavaScript。</p>
<p>Web浏览器并不是唯一使用JavaScript的平台。有些数据库，如MongoDB和CouchDB，使用JavaScript作为脚本和查询语言。桌面和服务器编程的几个平台，尤其是Node.js项目(第20章的主题)，为在浏览器之外编写JavaScript提供了一个环境。</p>
<h2 id="Code-and-what-to-do-with-it"><a href="#Code-and-what-to-do-with-it" class="headerlink" title="Code, and what to do with it"></a>Code, and what to do with it</h2><p>代码是组成程序的文本。这本书的大部分章节都包含了相当多的代码。我认为读代码和写代码是学习编程不可缺少的部分。试着不要只是浏览这些例子，用心阅读并理解它们。这可能在一开始是缓慢和令人困惑的，但我保证你会很快掌握它的窍门。练习也是一样。在你真正写出一个可行的解决方案之前，不要假设你已经理解了它们。</p>
<p>我建议您在实际的JavaScript解释器中尝试您的练习解决方案。这样，你就会得到关于你所做的是否有效的即时反馈，而且，我希望，你会被诱惑去尝试并超越练习。</p>
<p>许多示例都是独立的，应该可以在任何JavaScript环境中工作。但是后面章节中的代码通常是针对特定环境(浏览器或Node.js)编写的，并且只能在那里运行。此外，许多章节定义了更大的程序，其中出现的代码片段相互依赖或依赖于外部文件。网站上的<a href="https://eloquentjavascript.net/code/" target="_blank" rel="noopener">沙箱</a>提供指向Zip文件的链接，其中包含运行给定章节代码所需的所有脚本和数据文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/03/11/译-eloquent-javascript-Introduction/" data-id="cjy2fdnv0000dd0orkdrc42b4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-FCC-Program" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/03/FCC-Program/" class="article-date">
  <time datetime="2019-03-03T01:11:45.000Z" itemprop="datePublished">2019-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/03/FCC-Program/">FCC Program</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="FCC-项目实战-“随机引语生成器”-做后感"><a href="#FCC-项目实战-“随机引语生成器”-做后感" class="headerlink" title="FCC 项目实战 “随机引语生成器” 做后感"></a>FCC 项目实战 “随机引语生成器” 做后感</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>项目来源是 FCC 上的<a href="https://learn.freecodecamp.one/front-end-libraries/front-end-libraries-projects/build-a-random-quote-machine" title="FreeCodeCamp" target="_blank" rel="noopener">“随机引语生成器”</a>，花了两天时间从 0 到接近完成，完成的项目放在 <a href="https://codepen.io/freecodework/pen/moPPmW?editors=0010" title="Random Quote Machine" target="_blank" rel="noopener">CodePen</a></p>
<h3 id="意料之外的地方"><a href="#意料之外的地方" class="headerlink" title="意料之外的地方"></a>意料之外的地方</h3><p>其实应该是我目前才疏学浅，只用到 React 的冰山一角吧，有一些地方让我花了较长时间。</p>
<ol>
<li><p><code>state</code> 在改变之后，不能在同一个 <code>function</code> 里立马就可以调用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            myData: &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    doSomething()&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            myData: &apos;Strings&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        //此处myData依然是 &apos;&apos;</span><br><span class="line">        console.log(this.state.myData); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发生上面情况的原因是：想在组件渲染前，<code>fetch</code> 函数获取的数据传给 <code>state</code> ，并且开始渲染第一次加载的引语。把 <code>fetch</code> 函数放在 <code>componentWillMount()</code> 里，然而这个生命周期函数不久后的版本应该就不会再被采用了。之前本想把数据 <code>fetch</code> 到手就立即渲染到 <code>render</code> 函数里的 <code>{this.state.myData}</code> 之类的，但他们都在<code>componentWillMount()</code> 里，后来想到设置子组件的方法，并且先通过条件渲染，确认了想要的 <code>myData</code> 非空值，才开始渲染子组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; myData &amp;&amp; &lt;Quote/&gt; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 <code>&lt;body/&gt;</code> 的样式时用到的 <code>document.getElementsByTagName（）</code> 等类似方法获取到的是类数组对象，可以用数字索引 <code>[0]</code> 获取。</p>
</li>
<li><p>另外，在写的过程中发现了一些有点伤心的事情，居然有人在 <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a> 里下毒，将中文翻译与英文反着来，真是活久见。 </p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/03/03/FCC-Program/" data-id="cjy2fdnm20000d0orw4nia5ua" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-C/" style="font-size: 10px;">C/C++</a> <a href="/tags/Chemistry/" style="font-size: 15px;">Chemistry</a> <a href="/tags/ECMAscript/" style="font-size: 20px;">ECMAscript</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/14/用VS-Codeb运行其中写好的C-文件/">用VS Codeb运行其中写好的C++文件</a>
          </li>
        
          <li>
            <a href="/2019/06/08/Ubuntu-using/">Ubuntu using</a>
          </li>
        
          <li>
            <a href="/2019/06/08/译-Cargo-Sorting-DNA-Robot/">译-Cargo Sorting DNA Robot</a>
          </li>
        
          <li>
            <a href="/2019/05/10/译-eloquent-javascript-Objects/">译-eloquent-javascript-Objects</a>
          </li>
        
          <li>
            <a href="/2019/04/14/译-Biomass-Gasification/">Biomass Gasification</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>