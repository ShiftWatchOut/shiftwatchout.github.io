<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Watchout的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Watchout的博客">
<meta property="og:url" content="https://shiftwatchout.github.io/index.html">
<meta property="og:site_name" content="Watchout的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Watchout的博客">
  
    <link rel="alternate" href="/atom.xml" title="Watchout的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Watchout的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shiftwatchout.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Docker-in-WSL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/16/Docker-in-WSL/" class="article-date">
  <time datetime="2020-04-16T13:58:59.000Z" itemprop="datePublished">2020-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/16/Docker-in-WSL/">Docker in WSL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="在-WSL-2-中使用-Docker"><a href="#在-WSL-2-中使用-Docker" class="headerlink" title="在 WSL 2 中使用 Docker"></a>在 WSL 2 中使用 Docker</h1><p><a href="https://code.visualstudio.com/blogs/2020/03/02/docker-in-wsl2" target="_blank" rel="noopener">原文链接</a> 作者：马特·埃尔南德斯 <a href="https://twitter.com/fiveisprime" target="_blank" rel="noopener">@fiveisprime</a> 2020年3月2日 </p>
<p>去年6月，Docker 团队<a href="https://engineering.docker.com/2019/06/docker-hearts-wsl-2/" target="_blank" rel="noopener">宣布</a>，他们将致力于让 Docker 运行在 Windows Subsystem for Linux（WSL）上。WSL 最近的架构变动，改为在轻量虚拟机（VM）上运行，使 Docker in WSL 成为可能，这一点我们在之前一篇关于 WSL 2 的<a href="https://code.visualstudio.com/blogs/2019/09/03/wsl2" target="_blank" rel="noopener">文章</a>中谈到过。随后，Docker 团队发布了 Docker 的<a href="https://docs.docker.com/docker-for-windows/wsl-tech-preview/" target="_blank" rel="noopener">技术预览版</a>，支持 WSL 2。</p>
<p>本文介绍了 Docker Desktop 技术预览版的工作原理，以及如何将 Docker 插件与桌面应用一起使用。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>新的 Docker 架构的工作方式与 Visual Studio Code 的 <a href="https://code.visualstudio.com/docs/remote/wsl" target="_blank" rel="noopener">WSL 远程开发</a>支持类似，因为在主机上运行的 Docker CLI 在 Docker 集成包中执行命令，该集成包在远程 WSL VM 上运行。</p>
<p><img src="https://code.visualstudio.com/assets/blogs/2020/03/02/docker-in-wsl2.png" alt="Docker in WSL 2" title="Docker Engineering"></p>
<p>DockerD 直接运行在 WSL 里，因此不需要 Hyper-V VM ，并且所有 Linux 容器都运行在 Windows 的 Linux 用户空间内，提高了性能和兼容性。</p>
<h2 id="开始上手"><a href="#开始上手" class="headerlink" title="开始上手"></a>开始上手</h2><p>首先是一些必要的准备：</p>
<ul>
<li>安装 Windows 10 Insider Preview build 18975（慢速）或更高版本，要支持 WSL 2。</li>
<li>从微软商店安装 <a href="https://www.microsoft.com/p/ubuntu/9nblggh4msv6" target="_blank" rel="noopener">Ubuntu</a> 。</li>
<li>按照<a href="https://docs.microsoft.com/windows/wsl/wsl2-install" target="_blank" rel="noopener">指南</a>启用 WSL 2。</li>
<li>安装 VS Code 的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl" target="_blank" rel="noopener">Remote - WSL</a>插件 。</li>
<li>安装 <a href="https://docs.docker.com/docker-for-windows/wsl-tech-preview/#download" target="_blank" rel="noopener">Docker WSL 2 技术预览版</a>。</li>
</ul>
<p>安装完成后，Docker 将识别出已安装 WSL 并提示启用 WSL 集成包。为完成本教程您需要<strong>启用 WSL 集成</strong>。</p>
<!-- integration == 集成？ -->
<p><img src="https://code.visualstudio.com/assets/blogs/2020/03/02/docker-desktop-wsl-integration.png" alt="Docker Desktop WSL integration dialog"></p>
<p>启用这个选项意味着您可以直接从 Linux 发行版中通过 Docker CLI 访问 Docker Desktop 。</p>
<p>如果您有多个 Linux 发行版，请确保在 Docker 设置中只为正确的 WSL 打开了 WSL 集成：</p>
<p><img src="https://code.visualstudio.com/assets/blogs/2020/03/02/docker-resources-wsl-integration.png" alt="Docker settings dialog"><br>配置之后，所有命令都将在 Linux 的上下文中执行 - 包括在 PowerShell 运行的 Docker 命令，因此运行类似 <code>docker run mongo…</code> 的命令将在 WSL VM 中启动一个 Linux 容器。</p>
<p><img src="https://code.visualstudio.com/assets/blogs/2020/03/02/docker-run-mongo.png" alt="docker run mongo command"></p>
<p>前面我们都是在 Windows 环境下操作，现在切到 WSL 中运行 <code>docker ps</code> 命令，不出意外的话，您将看到容器列表。注意，容器 ID 是一致的。</p>
<p><img src="https://code.visualstudio.com/assets/blogs/2020/03/02/docker-ps-in-wsl.png" alt="docker ps command in WSL"></p>
<h2 id="使用-VS-Code"><a href="#使用-VS-Code" class="headerlink" title="使用 VS Code"></a>使用 VS Code</h2><p>经过前面的设置和试运行后，您可以安装 VS Code 的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker" target="_blank" rel="noopener">Docker</a> 插件并访问容器。如果您已经在运行 WSL 2 和 <a href="https://code.visualstudio.com/remote-tutorials/wsl/getting-started" target="_blank" rel="noopener">Remote - WSL</a> 插件，它们将帮助你把 Docker 集成到 WSL 工作流中，而不必在容器中切换。由于 Docker CLI 的上下文被设置为使用 WSL 中的 DockerD，因此无论您的 VS Code 否启用 Remote - WSL 插件，Docker 插件都能正常查看容器。</p>
<p>注意下面的屏幕截图，我连上了 WSL 并在其中工作，而且还在构建/运行容器，却无需切换我偏好的终端（Ubuntu 中的 zsh）。</p>
<p><img src="https://code.visualstudio.com/assets/blogs/2020/03/02/vscode-containers-in-wsl.png" alt="VS Code working with containers in WSL" title="Theme: Noctis Sereno"></p>
<p>我个人注意到这样配置下来，容器运行速度有了很大的提高，但我的习惯的开发工作流程都完全不变。我还试了在 WSL 中使用 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers" target="_blank" rel="noopener">Remote - Containers</a> 插件来测试特定环境，而无需直接在我的计算机上设置内容。</p>
<h2 id="欢迎反馈"><a href="#欢迎反馈" class="headerlink" title="欢迎反馈"></a>欢迎反馈</h2><p>请记住，您使用的是预览版软件，虽然 Windows 慢速预览版非常稳定，但依然可能出现一些问题。如果您发现某些地方明显未按预期的方式运行，请通过 Windows 中的反馈工具提交问题。任何有关 Docker 的问题或反馈都可以直接提交到 <a href="https://github.com/docker/for-win/issues" target="_blank" rel="noopener">Docker for Windows</a> 中。</p>
<p>纵享 Coding ！</p>
<p>马特·埃尔南德斯，VS Code项目经理 <a href="https://twitter.com/fiveisprime" target="_blank" rel="noopener">@fiveisprime</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2020/04/16/Docker-in-WSL/" data-id="ck92tz1x20001rkorou75z0sx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/translation/">translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vscode/">vscode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Git-学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/12/Git-学习/" class="article-date">
  <time datetime="2020-04-12T13:36:06.000Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/12/Git-学习/">Git 学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>鉴于前面提到的 wsl 没有图形界面的原因，如果想利用 matploblib 输出可交互的 3D 图形，肯定是不能用 <code>plt.savefig()</code> 的。那至少我们需要将在 wsl 完成的工作同步到裸机安装的 Ubuntu 上，那么就趁这个机会学习使用 Github 来同步我的代码吧。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>直接使用 <code>git init</code>，一路 yes 下来，把当前文件夹变成一个新的代码仓库，无需联网也可以完成版本控制的功能。</p>
<h4 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h4><p>为了在互联网上被唯一地识别，我们需要设置 git 的用户名和邮箱，终端输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"名字"</span></span><br><span class="line">git config --global user.email example@example.com</span><br></pre></td></tr></table></figure>
<p>设置好后可以通过 <code>git config --list</code> 查看信息。</p>
<h4 id="ssh-key-生成"><a href="#ssh-key-生成" class="headerlink" title="ssh key 生成"></a>ssh key 生成</h4><p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p>
<p>新的 ssh 公密钥会生成到用户根目录的 <code>.ssh/</code> 文件夹下，默认文件名会是<code>id_rsa</code>、<code>id_rsa.pub</code>，查看并复制 *.pub 文件的内容。</p>
<p><code>ssh-add ~/.ssh/id_rsa</code> 将 ssh 密钥添加到 ssh-agent</p>
<h4 id="Github-远端设置"><a href="#Github-远端设置" class="headerlink" title="Github 远端设置"></a>Github 远端设置</h4><p><code>Settings &gt; SSH and GPG keys &gt; New SSH key</code></p>
<p>在 Key 的输入框中粘贴 *.pub 文件里的所有内容，然后保存。可以在多个设备上生成多个独立的 ssh key 再到 GitHub New 多个远端 ssh key。</p>
<p>新建仓库，复制仓库页的 git ssh 链接，返回到终端，设置 本地仓库的远端源：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:githubusername/repo-name.git   <span class="comment">#上面复制的 git 链接</span></span><br><span class="line">git push -u origin master</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2020/04/12/Git-学习/" data-id="ck92tz1x60003rkor4h73vja3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pandas-读取Excel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/pandas-读取Excel/" class="article-date">
  <time datetime="2020-04-06T09:43:41.000Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/pandas-读取Excel/">pandas 处理 Excel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>pandas 是一个数据结构和数据分析工具。</p>
<h4 id="pandas-数据类型"><a href="#pandas-数据类型" class="headerlink" title="pandas 数据类型"></a>pandas 数据类型</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Series</td>
<td>带标签的<strong>一维</strong>同构数组</td>
</tr>
<tr>
<td>DataFrame</td>
<td>带标签的，大小可变的，<strong>二维</strong>异构表格</td>
</tr>
</tbody>
</table>
<h4 id="读取-Excel-文件"><a href="#读取-Excel-文件" class="headerlink" title="读取 Excel 文件"></a>读取 Excel 文件</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_excel(filelName, sheet_name=sheetName)</span><br><span class="line">df.keys()           <span class="comment">#用 DataFrame 下的 keys 方法遍历所有 sheet 名</span></span><br></pre></td></tr></table></figure>
<p>从 read_excel 的定义来看，可以看出它可以接收这么多的参数。不过每个参数命名风格不统一看着有点难受。<br><img src="http://yanxuan.nosdn.127.net/5c98e8b2a33cf79319e42f835c42be32.png" alt="read_excel 参数"></p>
<p>read_excel 常用的参数：</p>
<ol>
<li>io：string，文件路径</li>
<li>sheet_name：string|int，想要查看的 sheet 名字或序号（从0开始），默认查看第一页。</li>
<li>usecols：array\&lt;int>，选择整型数组中的相应列输出，当有这个参数时， sheet_name 必须显式地被声明。</li>
<li>keep_default_na: boolean，默认为 False ，可以修改 NaN 的值，不必看到大量的 NaN ，输出可以更好看（在powershell输出表格数据时，这个参数设为<code>None</code>要比设为<code>&#39;&#39;</code>空字符串好看，貌似在输出时<code>&#39;&#39;</code>会多占一定的位置）。</li>
<li>na_values：any，可以自己设定什么值是 NaN，但是新增的 NaN 不会被上面的设定的值覆盖，会直接显示 “NaN” 字符串。</li>
<li>skiprows：array\&lt;int>，从头开始要跳过的行数，接受的是数组，会直接把数组内的行都忽略掉。</li>
<li>skipfooter：int，看似与上面的对应，但接受参数类型却不同，处理方式也不一样，这个参数会使函数忽略从末行开始到倒数第 int 行的数据。</li>
</ol>
<h4 id="pandas-常用方法（DataFrame）"><a href="#pandas-常用方法（DataFrame）" class="headerlink" title="pandas 常用方法（DataFrame）"></a>pandas 常用方法（DataFrame）</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df.describe()             <span class="comment">#简要总结数据</span></span><br><span class="line">df.head(int)              <span class="comment">#前 int 行数据帧</span></span><br><span class="line">df.tail(int)              <span class="comment">#后 int 行数据帧</span></span><br><span class="line">df.T                      <span class="comment">#数据帧转置</span></span><br><span class="line">df.copy()                 <span class="comment">#复制一份数据，而不是使用 = 给予另一个变量引用，这样两份数据就互不干扰</span></span><br><span class="line">df.index                  <span class="comment">#数据帧行号</span></span><br><span class="line">df.columns                <span class="comment">#数据帧的列名的列表</span></span><br><span class="line">df.loc[int]               <span class="comment">#接受单个整数，返回第 int 行的一个 Series</span></span><br><span class="line">df.loc[<span class="number">1</span>:<span class="number">4</span>]               <span class="comment">#还可以接受切片或数组，返回相应的几个列</span></span><br><span class="line">df.loc[int, col]          <span class="comment">#行号和列名可以定位一个 cell</span></span><br><span class="line">df.at[int, col]           <span class="comment">#同上</span></span><br><span class="line">df.loc[int].at[col]       <span class="comment">#甚至还可以这样</span></span><br><span class="line">df.dropna()               <span class="comment">#删去含有 NaN 的行</span></span><br><span class="line">df.dropna(how=<span class="string">'all'</span>)      <span class="comment">#删去全是 NaN 的行</span></span><br><span class="line">df.dropna(thresh=i)       <span class="comment">#至少有 i 个 NaN 才删去该行</span></span><br><span class="line">df.fillna(x)              <span class="comment">#用 x 替换 NaN</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2020/04/06/pandas-读取Excel/" data-id="ck92tz1xh000crkorrr9r3nsa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Anaconda-VSCode环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/05/Anaconda-VSCode环境搭建/" class="article-date">
  <time datetime="2020-04-05T13:58:58.000Z" itemprop="datePublished">2020-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/05/Anaconda-VSCode环境搭建/">Anaconda+VSCode环境搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>anaconda 自带了 <code>scikit-learn</code>、<code>numpy</code>、<code>scipy</code>、<code>pandas</code>、<code>jupyter</code>等适用于python机器学习开发环境的模块，一次下载，少量配置，可以说是开封即用，搭配上 VS code 的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python" target="_blank" rel="noopener">Python</a> 拓展，可以有较为愉快的开发体验。</p>
<h4 id="Windows-安装-anaconda"><a href="#Windows-安装-anaconda" class="headerlink" title="Windows 安装 anaconda"></a>Windows 安装 anaconda</h4><p>使用迅雷下载这类支持断点续传(或者是它服务器上保存了相应文件)的下载软件，进入<a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">官网下载页面</a>，复制需要的版本链接下载链接</p>
<p>不愿意安装其他软件下载的话，可以直接从<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">清华镜像网站</a>下载较新版本，不过说新也不新，但是后面可以升级到最新版本就是了，需要花费额外的升级时间。</p>
<p>如果安装后 conda 无法被识别为可执行的命令，配置环境变量：</p>
<ul>
<li>高级系统设置 → 环境变量 → 系统变量 → 在”<code>Path</code>“中添加 anaconda 的 <code>python.exe</code> 所在文件夹和 <code>/Script</code> 文件夹的绝对路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;安装文件夹&#125;                   #根目录</span><br><span class="line">$&#123;安装文件夹&#125;\Scripts           </span><br><span class="line">$&#123;安装文件夹&#125;\Library\bin       #非必须，当出现`ImportError`时可能需要添上这个来解决问题</span><br></pre></td></tr></table></figure>
<h4 id="Ubuntu-安装-anaconda"><a href="#Ubuntu-安装-anaconda" class="headerlink" title="Ubuntu 安装 anaconda"></a>Ubuntu 安装 anaconda</h4><p>Ubuntu 环境可以选择在硬盘上安装的 Ubuntu 桌面环境，也可以在 win10 下使用 wsl ，搭配上 VS code 的<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl" target="_blank" rel="noopener">Remote - WSL</a>插件使用，果然印证了那句“ Windows 是最好的 Linux 发行版”。</p>
<p>下载镜像站中对应 Linux 版本，在下载文件夹下打开终端，执行以下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &#123;对应shell文件名&#125;.sh</span><br></pre></td></tr></table></figure></p>
<p>一路 Enter/yes ，当然 IDE 可以自行选择，清华镜像站上下载的旧版本会提醒是否联网下载 VS code ，后来的新版本成了 Anaconda and JetBrains are working together，或许 PyCharm 目前才是 较好的 anaconda 环境吧。</p>
<p><em>注意：</em></p>
<ul>
<li>VS code 链接 wsl 之后，调试用的插件还需为 wsl 安装一次</li>
<li>wsl 没有GUI，使用 matplotlib 时应该保存图片在当前文件夹下，然后就可以用 VS code 查看结果了<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plt.show()  已经无效</span></span><br><span class="line">plt.savefig(<span class="string">'matplotlib.png'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>找到 anaconda 安装目录，使用<code>sudo rm -rf anaconda3</code>删除。</p>
<h4 id="conda-换清华源"><a href="#conda-换清华源" class="headerlink" title="conda 换清华源"></a>conda 换清华源</h4><p>为了加快使用 conda 安装模块时的下载速度，配置为清华大学镜像源。在Windows环境下，先使用<code>conda config --set show_channel_urls yes</code>，生成<code>.condarc</code>文件，然后直接粘贴入以下内容即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure>
<p>运行<code>conda clean -i</code>清除索引缓存，保证用的是镜像站提供的索引。</p>
<h4 id="升级-conda-及其下模块"><a href="#升级-conda-及其下模块" class="headerlink" title="升级 conda 及其下模块"></a>升级 conda 及其下模块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br><span class="line">conda update anaconda</span><br><span class="line">conda update anaconda-navigator     #update最新版本的anaconda-navigator</span><br><span class="line">conda update --all                  #更新所有第三方包</span><br><span class="line">conda update xxx                    #更新名为xxx的相应模块</span><br><span class="line">conda list                          #查看conda所安装的所有模块</span><br></pre></td></tr></table></figure>
<p>有了 VS code 的 Python 插件，现在可以直接在 VS code 内使用 Jupyter notebook 的 Run Cell 功能，只需在需要运行的 cell 上一行添加 <code>#%%</code></p>
<h4 id="python-环境选择"><a href="#python-环境选择" class="headerlink" title="python 环境选择"></a>python 环境选择</h4><p>VS code 给予了我们选择 python 运行环境的自由。如果预先安装了其他版本的 python，且前面的环境变量也都设置无误，VS code可以自动为我们找到<code>python.exe</code>。首先要新建一个文件夹，既存项目，又要保存一些编辑器的设置。编辑保存好 python 文件后，使用快捷键<code>Ctrl + Shift + P</code>，输入<code>select interpreter</code>，也可以直接点击左下角 python 版本进行切换。</p>
<p><img src="https://code.visualstudio.com/assets/docs/python/environments/no-interpreter-selected-statusbar.png" alt="点击选择环境"></p>
<h4 id="后续遇到的一些问题"><a href="#后续遇到的一些问题" class="headerlink" title="后续遇到的一些问题"></a>后续遇到的一些问题</h4><ol>
<li><p>好歹 anaconda 有这么大个体积，这么多依赖安装着，自然它的 Hello World 也不能随随便便<code>print</code>了事。在这个 base 环境下写代码时，想引入<code>numpy</code>还有一些依赖<code>numpy</code>的包如<code>scipy</code>、<code>pandas</code>时，出现了引用错误<code>ImportError</code>，详细信息是： <code>Original error was: DLL load failed: 找不到指定的模块。</code>。解决办法是安装 numpy-base：<code>conda install numpy-base</code>。</p>
</li>
<li><p>VS code 运行 py 文件时可能会在终端执行两个命令，一个是激活当前环境 base，然后才是正式执行，可以在<code>settings.json</code>里添加/修改<code>python.terminal.activateEnvironment</code>为<code>false</code>，不用每次运行都激活 base。</p>
</li>
<li><p>意想不到的是，就连引入 sklearn 包也会出问题，网上提供了一种解决方法，然鹅终究还是担心又会因为 Windows 环境出现其他<code>DLL Failed</code>问题，于是切换到 Ubuntu 下。</p>
</li>
<li><p>在 Linux 下只遇到了升级时文件夹读写权限的问题，在终端执行<code>sudo chown -R usrname:usrname /home/usrname/miniconda3</code>，chown 的目标是 anaconda 的安装文件夹，之后就可以正常升级，完全不会遇到上面的包引入时的问题。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2020/04/05/Anaconda-VSCode环境搭建/" data-id="ck92tz1wx0000rkorjaprdisw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vscode/">vscode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo-fatal-error" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/11/hexo-fatal-error/" class="article-date">
  <time datetime="2020-03-11T02:35:57.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/11/hexo-fatal-error/">hexo fatal error</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在昨天翻译文章时，遇到了一个错误：markdown 文件已经写好，表面上看着也没什么不正常，但是只要执行<code>hexo g</code>命令就会出现下面的错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render error: (unknown path) [Line 19, Column 64]</span><br><span class="line">  expected variable end</span><br><span class="line">    at Object._prettifyError (C:\Users\Personal\Desktop\blogs\node_modules\nunjucks\src\lib.js:36:11)</span><br><span class="line">    at Template.render (C:\Users\Personal\Desktop\blogs\node_modules\nunjucks\src\environment.js:542:21)</span><br><span class="line">    at Environment.renderString (C:\Users\Personal\Desktop\blogs\node_modules\nunjucks\src\environment.js:380:17)</span><br><span class="line">    at Promise.fromCallback.cb (C:\Users\Personal\Desktop\blogs\node_modules\hexo\lib\extend\tag.js:62:48)</span><br><span class="line">    at tryCatcher (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Function.Promise.fromNode.Promise.fromCallback (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\promise.js:180:30)</span><br><span class="line">    at Tag.render (C:\Users\Personal\Desktop\blogs\node_modules\hexo\lib\extend\tag.js:62:18)</span><br><span class="line">    at Object.onRenderEnd (C:\Users\Personal\Desktop\blogs\node_modules\hexo\lib\hexo\post.js:282:20)</span><br><span class="line">    at Promise.then.then.result (C:\Users\Personal\Desktop\blogs\node_modules\hexo\lib\hexo\render.js:65:19)</span><br><span class="line">    at tryCatcher (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\promise.js:512:31)</span><br><span class="line">    at Promise._settlePromise (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\promise.js:569:18)</span><br><span class="line">    at Promise._settlePromise0 (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\promise.js:614:10)</span><br><span class="line">    at Promise._settlePromises (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\promise.js:694:18)</span><br><span class="line">    at _drainQueueStep (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\async.js:138:12)</span><br><span class="line">    at _drainQueue (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\async.js:131:9)</span><br><span class="line">    at Async._drainQueues (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\async.js:147:5)</span><br><span class="line">    at Immediate.Async.drainQueues (C:\Users\Personal\Desktop\blogs\node_modules\bluebird\js\release\async.js:17:14)</span><br><span class="line">    at runCallback (timers.js:705:18)</span><br><span class="line">    at tryOnImmediate (timers.js:676:5)</span><br><span class="line">    at processImmediate (timers.js:658:5)</span><br></pre></td></tr></table></figure></p>
<p>那么根据<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">官网</a>上对出现<code>Template render error</code>的解释是零宽字符的存在或者是 yaml 文件格式不对，查看相关文件，yaml 并无异常，而且将新写的文章删去后可以正常执行<code>hexo g</code>，就从文章内有零宽字符着手。</p>
<blockquote>
<p> 零宽度字符就是一些不可见的，不可打印的字符。它们存在于页面中主要用于调整字符的显示格式，下面就是一些常见的零宽度字符及它们的 unicode 码和原本用途：</p>
<ol>
<li>零宽度空格符 (zero-width space) <code>U+200B</code> : 用于较长单词的换行分隔</li>
<li>零宽度断字符 (zero-width non-joiner) <code>U+200C</code> : 用于阿拉伯文，德文，印度语系等文字中，阻止会发生连字的字符间的连字效果</li>
<li>零宽度连字符 (zero-width joiner) <code>U+200D</code> : 用于阿拉伯文与印度语系等文字中，使不会发生连字的字符间产生连字效果</li>
<li>左至右符 (left-to-right mark) <code>U+200E</code> : 用于在混合文字方向的多种语言文本中（例：混合左至右书写的英语与右至左书写的希伯来语），规定排版文字书写方向为左至右</li>
<li>右至左符 (right-to-left mark) <code>U+200F</code> : 用于在混合文字方向的多种语言文本中，规定排版文字书写方向为右至左</li>
<li>零宽度非断空格符 (zero width no-break space) <code>U+FEFF</code> : 用于阻止特定位置的换行分隔</li>
</ol>
</blockquote>
<p>通过在 VS code 中使用正则匹配，成功地找到了两个零宽字符，但删除之后，却仍然会出现上面的错误。便去寻找其他的可能问题来源和解决方法。</p>
<p>最后找到的造成问题的原因是我前一篇文章里在写内联 CSS 时，两个连续的<code>}</code>与 hexo 用到的某个东西语法冲突，需打上空格后才可正常解析。</p>
<p>参考链接：<a href="https://juejin.im/post/5b87a6e26fb9a019b953ee8b" target="_blank" rel="noopener">零宽字符概念</a>，<a href="https://www.jianshu.com/p/738ebe02029b" target="_blank" rel="noopener">两个紧挨着的大括号造成语法冲突</a>，<a href="https://www.c-sharpcorner.com/article/remove-u200b-zero-width-space-in-richtexthtml-field-sharepoint/" target="_blank" rel="noopener">去除零宽的正则</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2020/03/11/hexo-fatal-error/" data-id="ck92tz1xf000arkoret0626ra" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-Styling-React-Native-Apps" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/译-Styling-React-Native-Apps/" class="article-date">
  <time datetime="2020-03-10T14:16:22.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/译-Styling-React-Native-Apps/">译-Styling React Native Apps</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Styling-React-Native-Apps"><a href="#Styling-React-Native-Apps" class="headerlink" title="Styling React Native Apps"></a><em>Styling React Native Apps</em></h1><hr>
<p><a href="https://alligator.io/react/styling-react-native/" target="_blank" rel="noopener">原文链接</a></p>
<blockquote>
<p>如果您曾经开发过 React Native，您可能会意识到它不像 Web 应用程序那样使用一般的 HTML 和 CSS 。在本指南中，我们将讨论其中的差异。您将<br>看到的主要区别之一是，所有内容都是根据Flexbox自动设置的。</p>
</blockquote>
<p>现在，如果需要，您可以直接引入 <code>styled-components</code> 库，并像以前一样使用 CSS 。这是一个很棒的库，作者极力推荐。但是，如果您希望了解在<br>原生应用程序中如何进行样式设置，请接着看下去。</p>
<h3 id="StyleSheet"><a href="#StyleSheet" class="headerlink" title="StyleSheet"></a><em>StyleSheet</em></h3><p>想在 React Native 中使用样式的第一件事是使用 <code>StyleSheet</code> 组件。首先引入它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; StyleSheet &#125; from &apos;react-native&apos;;</span><br></pre></td></tr></table></figure></p>
<p>引入后像这样使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    height: 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后像下面这样装点你想要美化的组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;styles.container&#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure></p>
<p>也可以采用内联的方式，殊途同归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123; &#123;height: 100&#125; &#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Pixels"><a href="#Pixels" class="headerlink" title="Pixels?"></a><em>Pixels?</em></h3><p>看起来很像 CSS ，对吧？ 事实上，它们是名称相同，与 CSS 相对照，但是您可能会注意到，我们在 <code>height: 100</code> 中没有明示任何单位。您可能习<br>惯于写上 “px”、“vm” 等。那么问题来了，React Native 默认使用什么单位呢？</p>
<p>这是一个非常复杂的问题，需要花费多篇文章来回答。对于 iOS ，它们是 “logical points” ，而 Android 使用 DIP 。这样做的原因有很多。简而言<br>之就是，屏幕有许多不同的屏幕尺寸和分辨率。因此，如果我们使用 px ，则在某些手机上会显得点阵化。然而 “points” 的想法是使像素密集的高分<br>辨率屏幕上的内容看起来与低分辨率屏幕上的内容相对一致。</p>
<p>好在，这个设计将为您处理从 iOS 到 Android 的大多数样式。虽然它并不完美，但应用在两个平台看起来大致相同。您的应用的高度，宽度，borderWidth等在屏幕上的外观，都将在后台进行计算。</p>
<p>您也可以使用 “auto” 或百分比，但是需将其用引号引起来，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123; &#123; height: &apos;100%&apos; &#125; &#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Wrap-Entire-Screen"><a href="#Wrap-Entire-Screen" class="headerlink" title="Wrap Entire Screen"></a><em>Wrap Entire Screen</em></h3><p>现在，要了解的是关于设置<code>&lt;View&gt;</code>填充整个屏幕的一件事。像 iPhoneX 这样的异形屏手机的一部分屏幕残缺了，一些元素将被放置在刘海下面。为避<br>免这个问题，只需使用React Native组件<code>&lt;SafeAreaView&gt;</code>来包装其余的组件，就可以确保您将看到所有屏幕。</p>
<p>另一件事是直接使用<code>flex: 1</code>。记住，React Native默认使用Flexbox，因此您无需在任何元素上设置<code>display: flex</code>。但是为什么添加<code>flex: 1</code>可<br>以使元素全屏显示呢？</p>
<p>在 React Native 中，默认的<code>flexDirection</code>是<code>column</code> ，您可以设置<code>flexDirection</code> 。但如果没有先设置，则<code>flex: 1</code>使元素沿主轴向下延伸，<br>因为默认情况下为纵列。如果了解 Flexbox ，就知道没有其他元素时，设为<code>flex: 1</code>的元素将填充父容器的整个主轴。</p>
<h3 id="Margins-and-Padding"><a href="#Margins-and-Padding" class="headerlink" title="Margins and Padding"></a><em>Margins and Padding</em></h3><p>在 React Native 中，关于样式的一点好处是设置边距和填充。两者都提供了一种在一行代码设置上下或左右距离的方法。他们两个都使用了<code>Horizontal</code>和<code>Vertical</code>这个词。</p>
<p>例如，要使元素的上下边距为20，可以这样设置：<code>&lt;View style={ {marginVertical: 20} }&gt;&lt;/View&gt;</code>。您也可以使用<code>paddingVertical: 20</code>设置顶部和<br>底部填充。还有<code>paddingHorizontal</code>和<code>marginHorizontal</code>。</p>
<p>这些都还不错，但是您可能会注意到您无法完全像在前端那样去编码，例如：<code>margin: &#39;20 0 20 0&#39;</code>。这在 React Native 中无效。</p>
<!-- 您还可以在页边距和填充的结尾处标记“开始”和“结束”。每当您看到样式中的“开始”和“结束”时，就可以知道它们取决于容器的flexDirection-如
果方向是`row`则`marginStart`等于`marginLeft`。如果`flexDirection`为`row-reverse`则`marginStart`等于`marginRight`。另外，“开始”和“结束
”将覆盖掉`marginLeft`和`marginRight`，`paddingLeft`和`paddingRight`。-->
<h3 id="Shadows-and-Borders"><a href="#Shadows-and-Borders" class="headerlink" title="Shadows and Borders"></a><em>Shadows and Borders</em></h3><p>CSS 中的<code>border</code>样式在 React Native 样式中无效。您必须将其分别写为<code>borderColor</code>和<code>borderWidth</code>。使用这两个属性，足够您对边界进行设置<br>。另外，您可以选择哪一侧使用哪种颜色/宽度。</p>
<p>您可能已经习惯了<code>borderRadius</code> ，它为每个角提供了弧度。您可以使用<code>top-start</code>，<code>top-end</code>，<code>bottom-start</code>或<code>bottom-end</code>来选择每个单独的<br>弧度，例如：<code>borderTopStartRadius: 20</code>，或者可以使用更简单的<code>top-left</code>，<code>top-right</code>等等。最后，您可以使用<code>borderStyle</code>从虚线，虚线或<br>实线边框中进行选择。</p>
<p>至于 React Native 中的阴影，您将无法使用您可能熟悉<code>box-shadow</code>。相反， React Native 有的是仅在 iOS 中有效的样式。使用以下三种样式：<code>shadowOffset: { height: 3, width: 3 }, shadowColor: &#39;#0000&#39;, shadowOpacity: 0.5, shadowRadius: 5 }</code>。这些阴影效果非常好，如果您熟悉前<br>端的阴影，这些阴影将很容易搞懂。</p>
<p>但是，在 Android 中，React Native 没有一个很棒的内置解决方案。您可以设置<code>elevation</code>属性，但这不是可自定义的，因此无法与其他样式（例如<br>边框和背景色）配合使用。对于 Android ，我建议<a href="https://www.npmjs.com/package/react-native-shadow" target="_blank" rel="noopener">react-native-shadow</a> 库。</p>
<h3 id="Platform-Specific"><a href="#Platform-Specific" class="headerlink" title="Platform-Specific"></a><em>Platform-Specific</em></h3><p>在上一节中，我们看到了平台之间的第一个主要区别：一个具有阴影样式，而另一个则没有。现在的好消息是，在上面的示例中，Android将直接忽略它<br>不支持的样式。它不会生效，但是至少您不会收到任何报错。在大多数情况下，您会发现平台不支持的所有样式都将被忽略。</p>
<p>但是，即使使用完美，简洁的样式，您也会发现从一个平台到另一个平台的外观差异很大。这是必然的。为了使样式在各个平台上看起来相似，让我<br>们从 React Native 引入<code>Platform</code>组件。引入后，您可以将样式设置为动态的，跟随平台变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; View, StyleSheet, Platform &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">&#123;/* ... */&#125;</span><br><span class="line">&lt;View style=&#123;styles.container&#125;&gt;&lt;/View&gt;</span><br><span class="line">&#123;/* ... */&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    height: Platform.OS === &apos;android&apos; ? 100 : 20,</span><br><span class="line">    backgroundColor: Platform.OS === &apos;ios&apos; ? &apos;yellow&apos; : &apos;blue&apos;,</span><br><span class="line">    ...Platform.select(&#123; ios: &#123; width: 100 &#125; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>请注意此处设置平台特定样式的两种不同方式。一种方式是在样式之后，使用三元运算符<code>height: Platform.OS === &#39;ios&#39; ? 100, 20</code>。在大多数情况<br>下，此方法效果很好，但是如果您想为不止一个平台设置样式怎么办？ 这就轮到<code>...Platform.select()</code>了。这允许您在一个平台上或在两个平台上指<br>定样式：<code>...Platform.select({ ios { width: 100 }, android: { width: 75 } })</code>。</p>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a><em>Other</em></h3><p>现在，样式变得比本文涵盖的范围更深，更复杂。您会在 React Native 中注意到样式在组件之间是不同的，这与 Web 前端基本上每个元素都可以使用<br>每种样式不同。如果查看官方的<a href="https://facebook.github.io/react-native/docs/text#style" target="_blank" rel="noopener">React Native 文档</a> （这是Text组件中的样式道具）<br>，您将看到一个组件列表，并且在每个组件下都有可用于设计组件的样式列表。与前端相比，您会发现这些功能有些局限，并且某些功能（例如 Button 组件）甚至没有样式属性。</p>
<p>在很多时候，您可以使用<code>&lt;TouchableOpacity&gt;</code>类的组件 ，当然还可以使用<code>&lt;View&gt;</code>，<a href="https://alligator.io/react/react-native-basic-components/" target="_blank" rel="noopener">这些组件</a>具有大多数可用的样式道具。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2020/03/10/译-Styling-React-Native-Apps/" data-id="ck92tz1xr000jrkor7pqpyvwh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/translation/">translation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-用VS-Code运行其中写好的C-文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/用VS-Code运行其中写好的C-文件/" class="article-date">
  <time datetime="2019-07-14T03:07:07.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/用VS-Code运行其中写好的C-文件/">用VS Code运行其中写好的C++文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>VS Code 具有良好的代码补全、简洁的页面和丰富的插件。作为从前端入坑编程，开始使用 VS Code 的人，目前有了使用 C++ 的需要，想仅使用 VS Code 就满足日常的 C++ 学习需求。</p>
<h4 id="下载编译器"><a href="#下载编译器" class="headerlink" title="下载编译器"></a>下载编译器</h4><p>VS Code 仅仅是一个文本编辑器，并非一个 IDE，它没有运行 C++ 所必要的编译器，这里我选择 Mingw-w64 作为编译器，前往<a href="https://mingw-w64.org/doku.php/download" title="官网下载页面" target="_blank" rel="noopener">官网</a>选择所需版本下载。</p>
<p>下载好安装程序后，第二项选择 <code>x86_64</code>，其它选项可不改动，然后一路 <code>next</code> 下去。</p>
<p><img src="https://images2017.cnblogs.com/blog/341522/201801/341522-20180115191945506-2090768460.png" alt="POSIX"></p>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>如此安装好了之后，并不能直接在任何文件夹下直接编译运行 C++ 程序，还需要设置环境变量。用 <code>gcc -v</code> 或 <code>g++ -v</code> 检验编译器是否在安装文件夹之外可用。假设你的安装文件夹为 E 盘根目录</p>
<ul>
<li>在 <code>系统变量</code> 的 <code>Path</code> 变量中添加 <code>E:\mingw64\bin</code> 值，</li>
<li>在 <code>系统变量</code> 中添加新变量，名为 <code>C_INCLUDE_PATH</code> ，并将值设为 <code>E:\mingw64\include</code>，</li>
<li>在 <code>系统变量</code> 中添加新变量，名为 <code>CPLUS_INCLUDE_PATH</code> ，并将值设为 <code>E:\mingw64\include</code> 。</li>
</ul>
<p>环境变量设置完成之后，运行 <code>gcc -v</code> 或 <code>g++ -v</code> 命令则会得到一大串关于编译器的版本信息。</p>
<h4 id="VS-Code-插件"><a href="#VS-Code-插件" class="headerlink" title="VS Code 插件"></a>VS Code 插件</h4><p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++</a>、<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a>。</p>
<p>Code Runner 可以一键运行工作文件夹下的对应 CPP/C 文件，也就是代替人打出冗长的编译运行命令。对于本人的学习需求已经足够了，而且还很方便。</p>
<p><strong>参考链接：</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/54861567" title="[VSCode插件推荐] Code Runner: 代码一键运行，支持超过40种语言" target="_blank" rel="noopener">Code Runner 插件作者知乎文章</a><br><a href="https://www.cnblogs.com/findumars/p/8289454.html" title="在Windows中安装MinGW-w64" target="_blank" rel="noopener">网友的 MinGW-W64 安装图文教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/07/14/用VS-Code运行其中写好的C-文件/" data-id="ck92tz1x90005rkor1q5iiind" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vscode/">vscode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ubuntu-using" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/08/Ubuntu-using/" class="article-date">
  <time datetime="2019-06-08T12:55:27.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/Ubuntu-using/">Ubuntu using</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><p>目前最受推荐的便是使用系统自带包管理器来安装。</p>
<p>先设置包管理器的源</p>
<p><code>$ sudo vim /etc/apt/sources.list.d/nodesource.list</code></p>
<p>使用下方的源来代替源内的 URL</p>
<p><code>https://mirrors.ustc.edu.cn/nodesource/deb/node_{版本号，例如: 10}.x</code></p>
<p>然后</p>
<p><code>$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</code></p>
<p>更新 APT 源</p>
<p><code>$ sudo apt-get update</code></p>
<p>通过 APT 安装</p>
<p><code>$ sudo apt-get install -y nodejs</code></p>
<p>检查 nodejs 版本</p>
<p><code>$ node -v</code></p>
<p>升级 node 至最新 LTS 版本：将上面 <code>curl</code> 那一步的 node 版本改为最新的稳定版，源里的 URL 会被自动更改，再更新 APT 源，然后使用更新命令，</p>
<p><code>$ sudo apt upgrade</code></p>
<p>升级后清理掉旧版本。</p>
<p><code>$ sudo apt autoclean</code></p>
<p>本地使用 mongo 前先启动服务，不然进不了命令行工具，然后 <code>mongo</code></p>
<p><code>sudo service mongod start</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/06/08/Ubuntu-using/" data-id="ck92tz1xc0008rkorxtfcb03h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-Cargo-Sorting-DNA-Robot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/08/译-Cargo-Sorting-DNA-Robot/" class="article-date">
  <time datetime="2019-06-08T12:55:04.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/译-Cargo-Sorting-DNA-Robot/">译-Cargo Sorting DNA Robot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a href="https://science.sciencemag.org/content/357/6356/eaan6558" title="A Cargo-sorting Robot" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<blockquote>
<p><strong>Abstract</strong><br>分子机器人的设计和合成中的两个关键挑战是模块化和算法简单性。我们展示了三个模块化构建模块，用于 DNA 机器人，在分子水平上进行货物分类。通过硬编码货物与其目的地之间识别的简单算法来简化机器人设计：设计为有一条腿和两只脚用于行走的单链 DNA ，以及用于拾取和放下货物的一条臂和一个手。机器人探索 DNA 折纸平面上的测试场，拾取最初处于无序位置的两种类型的多个货物，并将它们运送到各自指定的目的地，直到所有分子分成两个不同的堆。机器人被设计为在不提供任何能量的情况下随机行走。利用此功能，一个机器人可以重复排序多个货物。将机器人局限于 DNA 折纸上允许在一个试管中同时进行不同的货物分拣任务，或者允许多个机器人共同执行相同的任务。</p>
</blockquote>
<p>执行机械任务的分子机器是所有生物有机体中的关键功能组件。自动执行复杂的纳米机械任务，同时与其环境互动的可编程分子机器人的设计，目前在分子工程中面临着两个关键挑战，即模块化和算法简单性。</p>
<p>在机电机器人中模块化的重要性最初建立于 20 世纪 70 年代。模块化机器人可以是自适应的，可以自我修复，并且只使用一些组件就能执行各种任务。例如，长期太空任务需要机器人在自主操作期间处理不可预见的情况。模块化对于分子机器人来说也很重要，不仅因为在它们运行的​​生物化学环境中存在许多不可预见的情况，而且因为开发针对特定任务而定制的新分子机器人需要大量的努力。在最近发展的蛋白质马达已经显示模块化的潜力，例如，由已知基序的蛋白质中创造出新的功能。</p>
<p>复杂的单个分子难以合成，并且更难以赋予精确控制的动力学和机械性质。因此，算法越简单，就越可能被简单分子执行，分子的合成也越简单，实验就越有可能成功。简单的算法可以产生复杂的功能，包括图灵通用计算。对蚂蚁和白蚁等社会性昆虫行为的研究表明，能力有限的个体可以完成复杂的任务。他们的行为为复杂的工程挑战提供了简单而强大的解决方案。</p>
<p>我们现在展示的是，一个简单的算法可以使一个简单的 DNA 机器人在二维（2D） DNA 折纸表面上执行复杂的货物分类任务。该系统使用三个可相互组合的构建块，可用于货物分拣以外的各种功能。</p>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>化学合成的小DNA分子是模块化设计的天然构件，因为连续的核苷酸区段可以作为杂交或链置换中的独立结构。人们已经设计并合成了由DNA分子制成的各种机械装置，包括镊子，聚合物马达和旋转装置。DNA机器人已经从非自主，发展到独立（13 - 16），并从走在指定方向，到可以转弯，选择岔路，拾取货物，并在微粒表面上行走。</p>
<p>我们选择货物分拣作为示例任务，因为该功能比先前的DNA机器人能够执行的功能复杂得多，在算法上是有趣的，并且在许多生物和工程系统中起着至关重要的作用。例如，在神经元中，不同的蛋白质，包括神经递质受体和离子通道，在细胞体中的相同位置合成，但被递送到轴突和树突中的不同位置。在蚁群中，工蚁通过在中心区域聚集卵和微型幼虫并按照大小增加的顺序将较大的幼虫推离中心来对它们的巢进行分类。排序也是计算机科学和工程中最基本的技术之一。已经开发了各种排序算法来优化数据处理。按顺序排列项目，无论它们是信息还是物理对象，都可以更轻松地完成许多其他任务，包括搜索和比较。</p>
<p>开发一种在DNA折纸表面进行货物分类的机器人有两个主要原因，而不仅仅是让货物分子在溶液中扩散到目的地。首先，货物的初始和最终几何位置可以是分拣任务的一个整体组成部分。例如，如果树突膜蛋白被错误地递送到神经元的轴突，它们就可以结合在轴突膜并导致轴突具有树突特性，从而失去其特性。其次，在自己的测试区域上工作的各个机器人的几何分离使得可以并行地进行不同的货物分拣任务并且使多个机器人共同执行相同的任务。DNA 折纸表面的定位提供了一些与生物学中的区域化分隔相同的益处，其中膜允许单个细胞并行地执行不同的局部功能，并且细胞之间的通信随后在生物体内执行复杂的全局功能。</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>货物分拣的任务定义如下：最初，每种类型具有多个分子的两种或更多种分子被放置在有限尺寸的2D空间中。这些分子的位置可以是任意的。机器人应该能够搜索整个空间，拾取任何类型的分子，并将每种类型传送到指定的目的地，直到所有分子分成不同的堆（图1A）。</p>
<p><img src="https://science.sciencemag.org/content/sci/357/6356/eaan6558/F2.large.jpg" alt="图1：货物分拣算法" title="图1：货物分拣算法"></p>
<p><em>（A）在任意指定的目的地将任意分布的分子分类成不同的堆的示意图。（B）简单货物分拣算法的流程图。在分子实现中，拾取和放下货物的选择并不总是按设计进行 - 机器人有较小的概率返回随机行走。（C）随机行走，（D）货物拾取和（E）放下货物的三个构件的机制。（F）三个构件的可组合性。三种类型的轮廓突出显示了三个构建块中使用的组件。（G.）分类多种货物的实施。波浪线表示短的立足结构，直线表示DNA链中的长链迁移结构，箭头标记其3’末端。</em></p>
<p>如果我们不受单个分子的能力限制，则需要以下简单有效的算法。机器人系统地探索相关领域。如果碰到货物，机器人将捡起货物，识别货物类型，选择指向该货物类型的指定目的地的路径，并将其放在目的地。然后，机器人将重复该过程，直到所有货物都被分拣。为了实现该算法，机器人将需要具有存储器，用于记录自己去过哪里，识别各种类型的货物，以及用于选择指向各个目的地的不同路径的处理。这些功能要求构成机器人的分子能够进行信息处理，并且具有更多类型货物的货物分拣任务将需要内置于机器人中的更复杂的信息处理电路。</p>
<p>为了实现一种实际可用的分子，我们开发了一种简单得多的算法（图1B），类似于在集体机器人学中受蚂蚁启发的排序算法，其中机器人执行随机游走。如果撞到货物，机器人会捡起它并继续随机行走。如果碰到货物的指定目的地的目标，机器人将把它甩掉。然后，机器人将重复该过程，直到所有货物都被分拣。为了实现这种算法，机器人只需要能够随机行走，拾取货物并将其丢弃。机器人既不会识别货物类型，也不会识别目的地类型。目标将识别匹配的货物并迫使机器人将其丢弃。随着货物类型的增长，机器人分子的复杂度将保持不变。只要每种类型的货物和目标之间的识别具有足够的特异性，货物和目标分子的复杂度也将保持不变。</p>
<p>使用DNA链置换反应（8，29，30）中，我们开发了三个模块化构件换随机游走，货物拾取，和货物脱落-以实现简单货物排序算法。为了在轨道上进行随机游走，设计了单链 DNA 机器人，各自含有6个核苷酸的两个足和一个含有15个核苷酸的一个腿（图1C）。该轨道由2D DNA折纸表面上的许多单链延伸组成。每个轨道链通过与机器人互补的脚和腿与机器人结合，留下机器人的另一个脚空出来。机器人通过可逆链置换反应从轨道上的一个位置移动到另一个位置。机器人的自由足首先与相邻轨道链的互补足结合。当两个相邻轨道股的互补腿部区域彼此竞争以结合到机器人的腿部时，发生分支迁移。当分支迁移进行到腿部的末尾时，机器人的先前绑定的足将解除关联，从而机器人从先前位置移动一步。有两种类型的轨道线以棋盘图案排列：每个都绑定到机器人的3’端或5’端的一英尺域。机器人应该能够在无偏差的情况下从轨道上的任何位置向任何相邻位置迈出一步，因为所有相邻位置的轨道都是相同且等距的。</p>
<p>用手臂和手扩展单链 DNA 机器人使它能拾取货物（图1D）。货物分子可以是 DNA 链，称为货物链，或与货物链的3’末端缀合的任何分子。在这里，我们使用荧光团或 DNA 链本身作为货物。货物链具有与机器人互补的手和臂。它最初与 DNA 折纸表面结合，同时互补的手暴露在外。如果机器人位于货物链的相邻位置，它将通过不可逆的链置换反应来拾取货物。通过结合手域启动反应，并通过臂结构域内的分支迁移完成反应。因为机器人的手臂和手臂域在反应结束时都会变成双股，所以机器人在携带货物时不能拿起另一个货物。货物装好后，货物的原始位置现在被认为是惰性的。这种状态变化的发生是因为单独的臂结构，没有手，不能与系统中的任何其他分子相互作用。足部和腿部区独立于手和臂起作用，因此，无论机器人是否携带货物，机器人都应该能够随机行走。</p>
<p>在货物链上添加货物段以允许卸货（图1E）。DNA 折纸表面上的目标链设计为具有手，臂和货物端的互补链。机器人通过不可逆的链置换反应来卸下货物，类似于货物拾取。通过货物链和目标链之间的货物的结合来启动反应，并且通过臂和手的链迁移来完成反应。通过这种方式，目的地主动从机器人抓取货物。货物卸下后，货物和目标区域内的所有区域都是双链的，因此在目的地不会再发生任何反应。没有了货物，机器人现在可以自由探索折纸表面上的其他位置并拾取另一个货物。</p>
<p>在三个构件中的每一个中使用的DNA链和链中的结构域可彼此直接组合（图1F）。因此，货物分拣机制简单地结合了随机行走，拾取货物和放下货物的机制。为了对多种类型的货物进行分类，我们只需要确保每种类型的货物和目标链具有独特的货物区域（图1G）。</p>
<h3 id="Random-Walk"><a href="#Random-Walk" class="headerlink" title="Random Walk"></a>Random Walk</h3><p>为了获得随机游走构建模块的定量理解，并将其与随机游走理论的基本特性进行比较，我们先在 DNA 折纸表面上使用线性轨迹进行实验演示（图2A）。为了减少机器人在轨道上任何位置卡住的可能性（如果缺少履带），我们将轨道设计为三个点的宽度。为了确定机器人行进一定距离所需的时间，我们指定了的起点和终点。机器人在起始位置等待，直到触发信号被引入，并且一旦到达目的地就停止行走。</p>
<p><img src="https://science.sciencemag.org/content/sci/357/6356/eaan6558/F3.large.jpg" alt="图2：随机游走构建块" title="图2：随机游走构建块"></p>
<p><em>（A）双层DNA折纸上的八步长轨道的3D和2D示意图。相邻轨道位置之间的线指示机器人的可能移动：两种类型的轨道线是棋盘图案，并且对于每个步骤，机器人只能在两种不同类型的轨道之间移动。因此，六边形网格在功能上就是机器人运动的方形网格（图S4A）。（B）仅在实验开始时保护机器人免于与轨道相互作用并激活机器人的机制。通过使用比抑制机器人高20倍的触发链，激活反应向前偏向。（C）机器人到达目标位置的机制。（D.）具有长度为8个单位的轨道的双层 DNA 折纸的 AFM 图像。（E）具有八个不同轨道长度的随机游走实验的荧光动力学数据和没有轨道的空白对照。在实验结束时添加相对于折纸浓度20倍过量的自由浮动机器人以测量最大可能的完成度。将三分之二的完成时间（T<sub>2/3</sub>）相对于轨道长度（l）绘制。二次函数的最小二乘拟合是T <sub>2/3</sub> = 0.38 + 0.055× l <sup>2</sup>。（F.）随机游走和空白对照的质量动作模拟。在该模型中，机器人从任意轨道位置行进到其相邻位置，k<sub>w</sub> = 3.5×10 <sup>-3</sup> s <sup>-1</sup>。最初禁用机器人并在k<sub>t</sub> = 3.2×10 <sup>4</sup> M <sup>-1</sup> s <sup>-1</sup>处触发。这两个速率常数是根据从实验数据获得的三分之二完成时间与轨道长度的二次拟合确定的。阴性对照用机器人在一个DNA折纸上模拟，与另一个相互作用，k<sub>s</sub> = 5×10 <sup>2</sup> M <sup>-1</sup>s <sup>-1</sup>。</em></p>
<p>尽管步行时不需要手和手臂，但我们使用它们来设计抑制器，迫使机器人在起始位置等待（图2B）。除了保持其与机器人稳定结合的互补的手臂和手臂区域之外，抑制剂链还具有互补的足以覆盖未连接到轨道的机器人的足部。因此，机器人不能在没有自由脚的情况下开始行走。抑制剂链还具有触发域，其可以结合自由的触发链并允许其激活机器人。触发链通过可逆链置换反应从机器人中去除抑制器 - 触发器没有手，因此，激活的机器人仍然可以与触发器和抑制剂复合物相互作用以逆转反应。如果触发线具有手域，它将像机器人一样拾取任何货物。因为我们想控制机器人的激活，不仅用于随机行走，还用于货物分拣，我们决定省略手域，而使用过量的触发链来激活反应。</p>
<p>为了让机器人在目的地停止行走，我们设计了一个类似于轨道链但具有两个互补脚域的目标链。在到达目标时，机器人将没有脚来采取进一步的步骤（图2C）。为了监测在目标位置有机器人的 DNA 折纸的分数，我们用淬灭器标记机器人的3’端，并用荧光团标记与目标相邻的钉的5’端。有和没有机器人的目标位置应分别产生低和高荧光状态。</p>
<p>有三个主要观察结果导致我们的设计选择和制作机器人成功随机行走的实验程序：（i） DNA 折纸作为机器人试验场的刚性会引发不良反应；（ii）机器人足区的 DNA 序列影响行走速度；（iii） DNA 折纸的纯度影响所需反应的完成水平。</p>
<p>我们首先使用单层矩形 DNA 折纸为DNA机器人建立一个试验场（图S1A）。在随机游走的空白对照实验中，机器人被放置在远离目标的不同距离处，但没有提供轨道 - 我们发现一小部分机器人仍然达到了目标（图S1B）。更令人惊讶的是，尽管最近的距离已经比机器人和目标之间设计的可到达距离的距离已经三倍，但是机器人越靠近目标越近，不期望的相互作用就越大。我们期望一个折纸上的目标可以与另一个折纸上的机器人互动，但如果折纸之间的相互作用是唯一的解释，我们就不会期望相互作用水平与机器人和目标之间的距离之间存在任何相关性。从而，我们假设，由于单层折纸的结构灵活性，同一折纸中的相互作用也可能在实验中发挥了作用。</p>
<p>我们并不关心折纸之间的相互作用，而是决定重新设计DNA折纸结构以减少折纸内不利的相互作用，原因如下：首先，折纸之间的相互作用可以通过降低折纸浓度来减少，但折纸内的相互作用不能。此外，折纸之间的相互作用可以简单地建模为具有已知浓度和速率常数的双分子反应，但是如果不理解折纸的结构波动如何影响折纸表面上的每个单分子反应的速率，则难以建立在折纸内不利相互作用的模型，从而使得很难预测随机行走和货物分拣的行为。为了解决这些问题，我们设计了一个双层方形 DNA 折纸（图S1D）。因为DNA结构沿着螺旋方向更加刚性并且在通过交叉连接的螺旋之间有些柔性，我们让两个层的螺旋方向彼此垂直以增加折纸的结构刚度。在双层折纸的表面上进行相同的空白对照实验，我们观察到移动到目标的机器人的比例不依赖于机器人和目标之间的距离（图S1E），表明相互作用在折纸内显著减少。单层和双层折纸之间结构灵活性的差异也与 CanDo 模拟（图S1，C和F）一致。</p>
<p>接下来，我们探索了机器人足部域的两个 DNA 序列选择：一个用于两个脚的两个不同的序列（图S2A），另一个使用相同的（图S2B）。通过一个实验，其中机器人在被触发后执行单个步骤，我们已经观察到两个选择之间的显著速率差异 - 后者更快（图S2C）。我们怀疑更快的反应速率与序列相同没什么关系，但主要是由机器人3’端附近序列的较弱结合能引起的。在这两种情况下，机器人到达目标的链置换反应是不可逆的。对于具有相同引发立足点的不可逆反应，如果反应物分子在溶液中自由漂浮，则速率应相似。然而，研究表明，如果将反应物分子束缚在固定位置，情况可能会有所不同。对于束缚分子，当解离速率变得快于分支迁移速率朝向越来越受约束的几何形状时，链置换反应可能以立足点解离而结束。因此，靠近机器人3’端的足部序列的结合能越弱，解离速率就越快。</p>
<p>我们开发了一种生物物理模型，以更好地理解行走机制，考虑DNA的几何和弹性（笔记S2.3和图S3）。该模型进一步表明，（i）当分支迁移的接合点足够接近表面时，拉伸 DNA 链的熵成本显著减慢了分支迁移到 DNA 折纸表面，和（ii） DNA 序列的标准自由能的微小差异可导致机器人一步完成率的巨大差异。有了这种理解，我们决定使用较弱序列继续推进。</p>
<p>在图S2C所示的一步实验中讲不通的，是反应的完成水平仅为约60％。什么可以阻止机器人走一步？我们假设折纸的纯度可能起了作用：在畸形的折纸结构中，激活的机器人可能仍然远离目标。为了验证这一假设，我们探索了两种净化折纸的方法，并在机器人在不同长度的线性轨道上行走的实验中将它们与未净化的折纸进行比较（图S4，A和B）。离心过滤器净化折纸（图S4D）的结果与未纯化的折纸（图S4C）非常相似，但凝胶纯化的折纸产生了更好的完成水平：接近95％（图S4E）。从凝胶和原子力显微镜（AFM）图像可以明显看出，离心过滤器净化足以去除多余的钉，但不足以去除畸形的折纸结构（图S4F）。因此，我们为后面的所有实验都将凝胶纯化折纸。</p>
<p>使用上述设计选择和实验程序，我们验证了在折纸上形成线性轨迹（图2D），并证明了在长度为1到8步的线性轨迹上的随机行走（图2E）。在理论，的步骤以随机行走的预期数量，这是从起点到长度的路径上的终点的击中时间 n ，是 n <sup>2</sup>。数值分析表明，可以直接从实验数据中获得的三分之二完成时间应该与预期的时间相似（笔记S2.5和图S5）。在我们的数据中，三分之二的完成时间与轨道的长度呈二次方相关（图2E，插图）。拟合二次函数中的常数项取决于激活机器人的时间和实际是三个单位宽度的轨道。</p>
<p>我们模拟了宽度为3的轨道上的激活和随机游走反应（图2F）。通过将三分之二的完成时间与实验数据进行比较来确定两个反应的速率常数。在机器人行走一步大约5分钟，步长6纳米，这类似于上折纸其他自治 DNA 电动机。在折纸上与机器人的抑制器相互作用的自由浮动触发链的速率比两个自由浮动分子之间的类似链置换反应慢约100倍，但与在折纸表面上测量的其他杂交和链置换速率相当。我们还模拟了空白对照 - 机器人在一个折纸上与另一个折纸相互作用而没有任何轨道的反应。这种折纸间相互作用的速率被确定为比机器人激活的反应慢大约100倍，可能是由于两种反应物的缓慢扩散速率和在碰撞事件期间分子定位以启动所需反应的概率降低所致。</p>
<h3 id="Cargo-sorting"><a href="#Cargo-sorting" class="headerlink" title="Cargo-sorting"></a>Cargo-sorting</h3><p>第二个构件，货物拾取器，与随机行走构件一起直接组成（图S6A）。因为抑制剂链不仅覆盖了行走的足部区域，而且还覆盖了用于货物拾取的手和臂区域，因此使用相同的激活反应来控制实验的开始。在这个设置中，机器人最初放置在 DNA 折纸的中心，折纸表面被轨道线完全覆盖，这样机器人就可以探索整个2D测试场。三个相同类型的货物最初位于折纸的一个边缘附近。一旦激活，机器人就开始随机行走，当它碰到一个货物时拿起货物，在运载货物时继续行走。缺乏卸货功能，机器人应该只能拿起一个货物，而将其他两个货物留在他们的初始位置。正如预期的那样，货物拣选的完成水平为27％，略低于三分之一（图S6B）。机器人还能够拾取标有不同荧光团的第二种货物链（图S6C）。</p>
<p>将卸货构件加入系统需要一种保护目标链的机制；否则，当它们混合在一起，还没装配到各自在折纸表面上的指定目的地进行定位，目标就将直接与货物相互作用（图S7）。设计目标抑制剂比设计机器人抑制剂更具挑战性。手域和货物域都不应该存在于与抑制剂结合的触发链中：臂和手一起将像机器人一样拾取货物，而货物和手臂将像目的地能做的那样拾取货物。因此，我们使用两条抑制剂链而不是一条（图3A）。与机器人激活反应类似，目标激活反应也是可逆的，并且由两个触发线的大量过量向前偏置。在激活之后，如果有机器人在其相邻位置携带匹配的货物，则目标可以从机器人抓取货物。</p>
<p><img src="https://science.sciencemag.org/content/sci/357/6356/eaan6558/F4.large.jpg" alt="图3：货物分拣示范" title="图3：货物分拣示范"></p>
<p><em>（A）保护目标免于与货物相互作用并仅在实验开始时激活目标的机制。所有货物分拣系统中两种类型轨道的布局如图S8A所示。（B）用两种不同类型的货物进行货物分类实验的荧光动力学数据。在初始状态下，货物 1-F 和货物 2-F 表示用荧光团标记的货物，而目标 1-Q 和目标 2-Q 表示用淬灭剂标记的目标。最终状态显示随机选择机器人的位置和未占用的目标。（C）每种类型的货物在其初始位置的 AFM 图像并分别被传送到它们的目标位置。所有图像的比例相同，右下图像中的比例尺为50 nm。</em></p>
<p>在货物分拣设置中，两种类型的六种货物最初位于折纸的一个边缘附近的无序位置，相应类型的八个目标位于相对边缘附近的两个分开的位置（图3B）。由于折纸合成的不完美，因此目标比货物有更多，来避免缺少目标链的可能情况。同样，机器人最初被放置在折纸的中心。两种类型的货物用两种不同的荧光团标记，但只有一种类型的目标用淬灭剂标记。在每个实验中，对于其中一种类型的货物，如果荧光信号在正确的目标位置放下，则荧光信号将减少； 对于另一种类型，只有在不正确的位置掉落时，信号才会减少。这对实验表明，两种类型的货物都在其所需的目的地下降（图3B）。观察到80％的完成水平，可能是因为机器人，货物和目标链中的合成错误抑制了期望的拾取和下落反应以及缺少机器人的不完美折纸的存在。尽管如此，机器人成功地分类了两种类型的货物，每种类型有多个货物。相比之下，没有机器人，货物在折纸处保留在其初始位置（图S8）。</p>
<p>荧光动力学实验提供了对散装货物分类行为的定量理解，但在单个折纸表面上，我们能猜到分子的位置吗？为了解决这个问题，我们进行了图3C所示的 AFM 实验。可视化货物分拣结果的挑战是区分目标货物的双链复合物与单链履带链，以及没有任何货物的部分双链目标。然而，在 AFM 成像中，不可能直接这样做； 因此，我们不得不从折纸表面移除所有没有货物的轨道和目标。因为没有货物的目标暴露了互补的货物区域（图3A），我们设计了一个目标移除链，它与它结合并使目标链远离折纸表面（图S9）。接下来，我们使用外切核酸酶I去除所有单链延伸，包括轨道链。我们将最初的货物地点留作双股，以作为折纸方向的参考。除了在目标的另一侧，这些位置也更接近折纸的右侧。在折纸落在云母上的情况下，我们根据初始货物位置的不对称性翻转图像。两个单独的 AFM 实验，每个实验都有一种类型的货物，但是两种类型的目标，都表明货物被运送到正确的目的地（图3C和图S10）。</p>
<p>为了探索我们系统的并行性，我们在一个试管中设计了两个 DNA 折纸混合群体的实验（图S11）：一个带有机器人而另一个没有。带机器人的折纸有一种用荧光团标记的货物，另一种的货物未经修饰。没有机器人的折纸与货物的标签相反。通过这种设置，如果机器人停留在最初放置的折纸上，将检测到一种货物的分类，而不是另一种。实验结果表明，一小部分（12至14％）的折纸具有不希望的串扰，但大多数情况下，两个折纸群体保持其自身的独立性（图S11）。</p>
<p>为了实际展示并行发生的两个不同的货物分拣任务，我们将机器人放置在 DNA 折纸的两个群体上，但不修饰其中一个的目标（图4A）。通过这种设置，如果两个折纸群保持其自身的独立性，则可以检测两种类型的货物的分类。否则，检测到的活性将显著降低，因为即使使用荧光团标记的货物，向未修饰的目的地的输送也不会产生荧光信号变化。我们确实观察到，与仅仅一个货物分拣群体相比，反应的完成水平比在单个群落上降低了16％至18％（图4A）（图3B）。然而，这种下降仍然远低于50％，相同货物的预期完成水平和目标在一个混合良好的解决方案中相互作用。</p>
<p><img src="https://science.sciencemag.org/content/sci/357/6356/eaan6558/F5.large.jpg" alt="图4：探索DNA折纸混合群体与单个DNA折纸表面上的多个机器人的平行度" title="图4：探索DNA折纸混合群体与单个DNA折纸表面上的多个机器人的平行度"></p>
<p><em>（A）两个DNA折纸混合群体的荧光动力学实验，每个都有两种类型的可以单独分类的货物。（B）将两类货物分类为连续时间马尔可夫链的随机模拟。 Robot <sub>x,y</sub>表示处于任意轨道位置（x，y）的机器人。（x \</em>，y *）是（x，y）的邻近位置。货物 i 和目标 i 分别表示特定类型的货物和目标。d 是（x <sub>1</sub>，y <sub>1</sub>）和（x <sub>2</sub>，y <sub>2</sub>）之间的欧几里德距离。d <sub>Min</sub>是机器人与其邻近位置的货物或目标之间的欧几里德距离。因为在最近的订书钉延伸位置之间有16个碱基对（bp），并且每三个订书钉列有 1-bp 缺失用于折纸扭曲校正，d <sub>Min</sub>计算为（16 × 3 -1）/ 3 bp × 0.34 nm / bp = 5.33 nm。如果距离在可到达的范围内，该模型允许机器人从不是其直接邻居的位置拾取货物（或将货物卸下），但是反应速率随距离呈二次方减小。因为双链足，腿和货物（或目标）附着区域中碱基对的总数是41bp，单链足和接头结构域中核苷酸的总数是16个核苷酸（nt），最大可达距离计算为每bp 41 bp×0.34 nm + 16 nt×0.5 nm / nt = 21.94 nm。随机行走的速度是k <sub>w</sub> = 3.5×10 <sup>-3</sup> s <sup>-1</sup>，最近的货物拾取和下降的速率是k <sub>c</sub> = 100 × k <sub>w</sub>。我们假设只有80％的货物可以成功地运送到目标位置，因为一小部分折纸缺少功能性机器人。该分数基于图3B中所示的实验数据确定。（C）多个机器人共同执行单个货物分拣任务的荧光动力学实验。*</p>
<p>我们建立了一个模型来模拟货物分拣系统（图4B）。轨道上处于任何位置的机器人可以以随机行走模型中确定的相同速率向任何紧邻的位置移动一步（图2F），无论它是否携带货物。如果距离货物或目标到机器人的距离足够，则任何位置的机器人都可以接载或放下货物。足够的距离是根据拾取和下降的链移位反应期间的最紧密连接计算的。我们假设拾取和卸货的最大速率是当货物或目标是机器人的直接邻居时，并且对于任何更远的距离，速率随着距离呈二次方减小。最大载货和卸货速度比步行速度快100倍，模拟（图4B）半定量地再现实验数据（图3B）。模拟表明，机器人平均需要295步才能完成货物分拣任务。</p>
<p>我们还分析了不期望的折纸间相互作用，包括机器人从一个折纸移动到另一个折纸，以及一个折纸机器人或目标在另一个折纸上拾取货物（图S12A）。使用与实验数据拟合的线性最小二乘法，我们确定了每种类型的模型化折纸间相互作用的完成水平（图S12B）。在折纸之间移动的机器人是最不重要的（1.59％），可能是因为与本地轨道股相互作用的可能性很高，而且在另一个折纸上的密集包装轨道股的可达性较低。一个折纸机上的机器人和目标在另一个折纸上拾取货物都更为重要（分别为4.56和8.25％），这可能是因为货物线远离折纸表面并高于轨道线的高度，因此更多无障碍。</p>
<p>最后，为了进一步利用折纸定位实现的并行性，我们展示了由多个机器人共同执行的单一货物分拣任务（图4C）。我们将机器人的初始位置移离货物，以增加货物分拣的难度。我们选择了五个机器人位置，并根据模拟对每个机器人单独对货物进行分类所需的时间进行排序（图S13A）。我们在每个实验中一次增加一个机器人的数量，从模拟预测的最快到最慢的机器人。通过这种方式，如果货物分拣的整体速度随着机器人的增加而增加，则应该是集体行为的结果，而不是任何特别快的机器人。增加机器人的数量将货物分拣的三分之二完成时间从超过10小时减少到不到1小时，并且四个机器人足以以接近最佳速度完成任务（图4C）。</p>
<p>多机器人实验中的一个启发性事实是，越来越多的机器人将完成水平从略低于80％提高到接近100％。这一观察结果排除了货物或目标分子出现故障的可能性，这表明是机器人本身发生故障或者一小部分折纸缺少机器人。如果单个机器人发生故障或丢失的概率为20％，那么使用 m 机器人的实验应该具有1 - 0.2 <sup>m</sup>的完成水平，这与实验数据非常吻合（图4C）。我们模拟了多机器人系统，假设每个机器人正常工作的概率为80％。模拟半定量地捕获实验结果（图S13C）。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>我们开发了一个简单的算法和三个构建块，以构建一个能在分子水平上进行货物分类的 DNA 机器人。我们证明了机器人可以在 DNA 折纸的表面上探索 2D 测试场，拾取最初在无序位置的两种类型的多个货物，并将它们运送到两个不同的目的地。我们还展示了同时在一个试管中进行的两个不同的货物分拣任务，多个机器人共同执行相同的任务。为了通过实验呈现这三个构建模块及其可组合性，我们测试了一系列子系统，这些子系统逐步整合了随机行走的构建块，然后是货物拾取，最后是货物下落。成功实现上一个构建块后，无需对先前设计的组件进行任何更改就可以添加下一个构建块。</p>
<p>原则上，使用完全相同的机器人设计，系统可以在以下方面进行推广：首先，该算法不需要机器人识别货物的类型，而是将识别嵌入目的地，因此，系统可以是适用于两种以上的货物。其次，该算法允许机器人自由探索整个2D测试场，因此货物的初始位置可以是任意的。第三，因为机器人被设计成在没有任何能量供应的情况下进行随机游走，所以应该可以对越来越多的货物进行分类。最后，因为分拣进行在单个折纸表面上，所以可以利用并行性来扩展系统以执行不同任务的许多实例，并且根据任务的难度，可以为每个任务分配不同数量的机器人。</p>
<p>通过努力，可以进一步开发机器人的以下方面。首先，机器人比最快的驱动蛋白电机慢大约100,000倍。根据我们对足部 DNA 序列如何影响行走速度的理解，我们认为通过添加单链尾部可以将速率提高至少100倍，从而提高局部链置换反应的起始速率，通过使用具有较弱结合能的序列（图S3B）。还可以通过使用酶来驱动 DNA 机器人或使用由 DNA 编程的蛋白质马达来进一步提高速率。其次，使用更大和更多样化的测试场地，例如随机 DNA 折纸阵列，可以帮助我们获得改善机器人稳健性的理解。第三，使用适体或直接结合，小化学品，金属纳米颗粒，和蛋白质可作为货物来运输的分子，使得货物分拣可用于化学合成（21，43，44）和分子器件的制造。例如，在化学合成中，一些所需的产物只有当化学基团以正确的顺序连接在一起，才能组装上。因此，货物分拣机器人可以与组装机器人一起工作，从最初随机分布的组件合成期望的产品。在分子装置中，可以触发货物分拣机器人重排诸如纳米颗粒的电路部件，使得装置的功能可以适应环境信号。最后，使分子机器人在生物环境中工作塑成可编程疗法。例如，参与疾病的 microRNA 可以被编程为用于货物分类任务的触发信号，其将蛋白质亚单位聚集在一起以用作药物。</p>
<p>更通常地说，我们的兴趣在于开发简单的算法和模块化构建模块，最终将用于系统构建可执行各种任务的分子机器人。我们相信我们在这里开发的三个构件不仅限于货物分拣任务。例如，受到蚂蚁觅食的启发，添加一个新的构建块，用于在路径上留下类信息素信号，可以对 DNA 机器人进行编程，以找到最短的路径并有效地运输货物分子。通过机器人之间的简单通信，他们可以执行更复杂的任务。类似于折纸表面上 DNA 链置换反应可以用于构建任意逻辑电路和化学反应网络，应该也可以制造一小组 DNA 链置换构建块，包括在这项工作中的那些，以执行在某个确定框架内定义的任意机械任务。通过系统化方法，分子机器人可以像宏观机器人一样轻松编程，但在微观环境中工作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/06/08/译-Cargo-Sorting-DNA-Robot/" data-id="ck92tz1xo000hrkormj9imi9z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/translation/">translation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-eloquent-javascript-Objects" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/10/译-eloquent-javascript-Objects/" class="article-date">
  <time datetime="2019-05-10T14:56:11.000Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/10/译-eloquent-javascript-Objects/">译-eloquent-javascript-Objects</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>抽象数据类型是通过编写一种特殊类型的程序来实现的，该程序根据可以对其执行的操作来定义类型。   Barbara Liskov, <em>Programming with Abstract Data Types</em></p>
</blockquote>
<p><img src="http://eloquentjavascript.net/img/chapter_picture_6.jpg" alt="img"></p>
<p>第四章介绍了 JavaScript 的对象。在编程文化中，有种称为面向对象编程的东西，一系列使用对象（和相关概念）作为程序组织的核心原则的技术。</p>
<p>虽然没有人真正同意其精确定义，但面向对象编程已经塑造了许多编程语言的设计，包括JavaScript。本章将介绍这些想法在JavaScript中的应用方式。</p>
<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>面向对象编程的核心思想是将程序划分为更小的部分，并使每个部分负责管理自己的状态。</p>
<p>这样，关于程序的一部分工作方式的信息就可以保留在该部分的本地。开发程序其余部分的人不必记住甚至了解这些信息。每当这些本地细节发生变化时，只需要更新其周围的代码。</p>
<p>这样的程序的不同部分通过接口彼此交互，提供有限的函数或绑定，这些函数或绑定在更抽象的级别提供有用的功能，隐藏它们的完整实现。</p>
<p>这类程序使用对象建模。它们的接口由一组特定的方法和属性组成。暴露在该接口的属性称为 <em>public</em> 。外部代码无法获取的其他内容称为 <em>private</em>。</p>
<p>许多语言提供了区分公共和私有属性的方法，并完全阻止外部代码访问私有属性。JavaScript，再一次采用极简主义的方法，还没有–至少现在没有区分公私变量。将其添加到该语言中的工作正在进行。（译者注：T39 委员会已于2018年10月将“#”作为表示私有变量的标记）</p>
<p>尽管语言没有内置这种区别，JavaScript 程序员却也成功地使用了这种想法。往往，可用的接口被描述在文档或注释中。在属性名称的开头加上下划线（_）字符以表示这些属性是私有的也很常见的。</p>
<p>将接口与实现分离是一个绝妙的主意，这被叫做<em>封装</em>。</p>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>方法只不过是将函数作为值保存的属性。下面是一个简单的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let rabbit = &#123;&#125;;</span><br><span class="line">rabbit.speak = function(line) &#123;</span><br><span class="line">console.log(`The rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.speak(&quot;I&apos;m alive.&quot;);</span><br><span class="line">// → The rabbit says &apos;I&apos;m alive.&apos;</span><br></pre></td></tr></table></figure>
<p>通常，方法需要对调用它的对象执行某些操作。当一个函数作为一个方法被调用–作为一个属性并被立即调用时，就像在<code>object.method()</code>中一样 - 在它的函数体中的<code>this</code>绑定会自动指向它被调用的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function speak(line) &#123;</span><br><span class="line">console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;</span><br><span class="line">let whiteRabbit = &#123;type: &quot;white&quot;, speak&#125;;</span><br><span class="line">let hungryRabbit = &#123;type: &quot;hungry&quot;, speak&#125;;</span><br><span class="line"></span><br><span class="line">whiteRabbit.speak(&quot;Oh my ears and whiskers, &quot; + &quot;how late it&apos;s getting!&quot;);</span><br><span class="line">// → The white rabbit says &apos;Oh my ears and whiskers, how</span><br><span class="line">//   late it&apos;s getting!&apos;</span><br><span class="line">hungryRabbit.speak(&quot;I could use a carrot right now.&quot;);</span><br><span class="line">// → The hungry rabbit says &apos;I could use a carrot right now.&apos;</span><br></pre></td></tr></table></figure>
<p>你可以将<code>this</code>视为以隐蔽方式传入的额外参数。如果要显式传递它，可以使用函数的<code>call</code>方法，该方法将传入的第一个参数作为其<code>this</code>值，并将其他参数视为普通参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">speak.call(hungryRabbit, &quot;Burp!&quot;);</span><br><span class="line">// → The hungry rabbit says &apos;Burp!&apos;</span><br></pre></td></tr></table></figure>
<p>由于每个函数都有自己的<code>this</code>绑定，其值取决于它的调用方式，因此不能在使用<code>function</code>关键字定义的常规函数中引用包装作用域。</p>
<p>箭头函数则不同的–它们不绑定它们自己的<code>this</code>，但可以看到它们邻近作用域的<code>this</code>绑定。因此，你可以执行类似以下代码的操作，该代码从本地函数内部引用<code>this</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function normalize() &#123;</span><br><span class="line">    console.log(this.coords.map(n =&gt; n / this.length));</span><br><span class="line">&#125;</span><br><span class="line">normalize.call(&#123;coords: [0, 2, 3], length: 5&#125;);</span><br><span class="line">// → [0, 0.4, 0.6]</span><br></pre></td></tr></table></figure>
<p>如果我在使用了<code>function</code>关键字的<code>map</code>函数里写了参数，代码将无法运行。</p>
<h3 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h3><p>仔细看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let empty = &#123;&#125;;</span><br><span class="line">console.log(empty.toString);</span><br><span class="line">// → function toString()&#123;…&#125;</span><br><span class="line">console.log(empty.toString());</span><br><span class="line">// → [object Object]</span><br></pre></td></tr></table></figure>
<p>我从空对象里提出来一个属性。嗒当！</p>
<p>好吧，非也。我只是隐瞒了有关 JavaScript 对象工作方式的信息。除了自身属性外，大多数对象还有一个<em>原型</em>。原型是另一个用作属性后备源的对象。当一个对象获得一个它没有的属性的请求时，将会去它的原型那里搜索属性，然后是原型的原型，依此类推。</p>
<p>那么谁是那个空对象的原型？ 它是伟大的祖先原型，几乎所有对象背后的实体，<code>Object.prototype</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(&#123;&#125;) == Object.prototype);</span><br><span class="line">// → true</span><br><span class="line">console.log(Object.getPrototypeOf(Object.prototype));</span><br><span class="line">// → null</span><br></pre></td></tr></table></figure>
<p>如你所料，<code>Object.getPrototypeOf</code>返回对象原型。</p>
<p>JavaScript 对象的原型关系形成一个树形结构，在这个结构的根部是<code>Object.prototype</code>。它提供了一些所有对象中都可用的方法，例如<code>toString</code>，它将对象转换为字符串形式。</p>
<p>许多对象不直接将<code>Object.prototype</code>作为其原型，而是使用另一个对象来提供不同的默认属性集。函数派生自<code>Function.prototype</code>，数组派生自<code>Array.prototype</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(Math.max) ==</span><br><span class="line">            Function.prototype);</span><br><span class="line">// → true</span><br><span class="line">console.log(Object.getPrototypeOf([]) ==</span><br><span class="line">            Array.prototype);</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure>
<p>这样的原型对象本身就有一个原型，通常是<code>Object.prototype</code>，所以它仍然间接提供像<code>toString</code>这样的方法。</p>
<p>你可以使用<code>Object.create</code>创建具有特定原型的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let protoRabbit = &#123;</span><br><span class="line">speak(line) &#123;</span><br><span class="line">    console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let killerRabbit = Object.create(protoRabbit);</span><br><span class="line">killerRabbit.type = &quot;killer&quot;;</span><br><span class="line">killerRabbit.speak(&quot;SKREEEE!&quot;);</span><br><span class="line">// → The killer rabbit says &apos;SKREEEE!&apos;</span><br></pre></td></tr></table></figure>
<p>对象表达式中的<code>speak(line)</code>属性是定义方法的简便方法。它创建了一个名为<code>speak</code>的属性，并赋予它一个函数作为其值。</p>
<p>“proto”兔子充当所有兔子共有的属性的容器。像杀手兔一样，每个兔子对象包含仅适用于自身的属性–在这种情况下是其类型–且其共享属性派生自原型。</p>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>JavaScript的原型系统可以被解释为对面向对象的概念（称为类）的一种非正式的实现。类定义了一种对象的内容–它具有哪些方法和属性。这样的对象称为类的<em>实例</em>。</p>
<p>原型可用于定义类的所有实例共享相同值的属性，例如方法。而每个实例中不同的属性，例如我们的兔子<code>type</code>属性，需要直接存储在对象本身中。</p>
<p>因此，要创建给定类的实例，你必须创建一个派生自适当原型的对象，但你还必须确保它本身具有此类实例应具有的属性。这是构造函数的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function makeRabbit(type) &#123;</span><br><span class="line">  let rabbit = Object.create(protoRabbit);</span><br><span class="line">  rabbit.type = type;</span><br><span class="line">  return rabbit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript提供了一种使定义此类函数更容易的方法。如果将关键字  <code>new</code>放在函数调用前面，则该函数将被视为构造函数。这意味着具有正确原型的对象将自动创建，在函数中绑定<code>this</code>，并在函数末尾返回。</p>
<p>构造对象时使用的原型对象是通过获取构造函数的<code>prototype</code>属性来找到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Rabbit(type) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype.speak = function(line) &#123;</span><br><span class="line">  console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let weirdRabbit = new Rabbit(&quot;weird&quot;);</span><br></pre></td></tr></table></figure>
<p>构造函数（实际上所有函数）自动获得一个名为<code>prototype</code>的属性，该属性默认包含一个从<code>Object.prototype</code>派生的普通空对象。如果需要，我们可以使用新对象覆盖它。或者，你可以向现有对象添加属性，如示例所示。</p>
<p>按照惯例，构造函数的名称需要大写，以便可以很容易地将它们与其他自定义函数区分开来。</p>
<p>重要的是要理解 原型与构造函数（通过其原型属性）相关联的方式，和 对象具有原型的方式（可以使用<code>Object.getPrototypeOf</code>查看）之间的区别。构造函数的实际原型是<code>Function.prototype</code>，因为构造函数是函数，它的原型属性包含用于通过它创建的实例的原型。</p>
<h3 id="Class-notation"><a href="#Class-notation" class="headerlink" title="Class notation"></a>Class notation</h3><p>所以 JavaScript 的类其实是带有<code>prototype</code>属性的构造函数。这就是他们之前的工作方式，直到2015年，这就是你编写类的方式。现在，我们有一个不那么尴尬的表示法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Rabbit &#123;</span><br><span class="line">  constructor(type) &#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  speak(line) &#123;</span><br><span class="line">    console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let killerRabbit = new Rabbit(&quot;killer&quot;);</span><br><span class="line">let blackRabbit = new Rabbit(&quot;black&quot;);</span><br></pre></td></tr></table></figure>
<p><code>class</code>关键字表示开始一个类声明，它允许我们在其中定义一个构造函数和一组方法。可以在声明的大括号内写入任意数量的方法。一个名为<code>constructor</code>的被作特殊处理。它提供了实际的构造函数，它将绑定到名称<code>Rabbit</code>。其他人被打包到该构造函数的原型中。因此，早期的类声明等同于上一节中的构造函数定义。它仅仅是看起来更优雅。</p>
<p>与函数类似，类可以在语句和表达式中使用。当用作表达式时，它不定义绑定，而只是将构造函数作为值生成。你可以在类表达式中省略类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let object = new class &#123; getWord() &#123; return &quot;hello&quot;; &#125; &#125;;</span><br><span class="line">console.log(object.getWord());</span><br><span class="line">// → hello</span><br></pre></td></tr></table></figure>
<h3 id="Overriding-derived-properties"><a href="#Overriding-derived-properties" class="headerlink" title="Overriding derived properties"></a>Overriding derived properties</h3><p>当你向对象添加属性时，无论它是否存在于原型中，该属性都会添加到对象自身。如果原型中已存在具有相同名称的属性，则该属性将不再影响这个得到新属性的对象，因为它现在已经隐藏在对象自身的属性后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.teeth = &quot;small&quot;;</span><br><span class="line">console.log(killerRabbit.teeth);</span><br><span class="line">// → small</span><br><span class="line">killerRabbit.teeth = &quot;long, sharp, and bloody&quot;;</span><br><span class="line">console.log(killerRabbit.teeth);</span><br><span class="line">// → long, sharp, and bloody</span><br><span class="line">console.log(blackRabbit.teeth);</span><br><span class="line">// → small</span><br><span class="line">console.log(Rabbit.prototype.teeth);</span><br><span class="line">// → small</span><br></pre></td></tr></table></figure>
<p>下图概述了此代码运行后的情况。<code>Rabbit</code>和<code>Object</code>原型位于<code>killerRabbit</code>之后，作为一种背景，可以查找对象在自身找不到的属性。</p>
<p><img src="http://eloquentjavascript.net/img/rabbits.svg" alt="img"></p>
<p>覆盖原型中存在的属性可能是一件有用的事情。正如示例中兔子牙齿所示，覆盖可用于在更通用的对象类的实例中表达异常属性，同时让非异常对象从其原型中获取标准值。</p>
<p>覆盖也用于为标准函数和数组原型提供与基本对象原型不同的toString方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.prototype.toString == Object.prototype.toString);</span><br><span class="line">// → false</span><br><span class="line">console.log([1, 2].toString());</span><br><span class="line">// → 1,2</span><br></pre></td></tr></table></figure>
<p>在数组上调用<code>toString</code>会产生类似于在其上调用<code>.join（“，”）</code>的结果–它在数组中的值之间放置逗号。直接使用数组调用Object.prototype.toString会产生不同的字符串。该函数不知道数组，因此它只是将单词object和类型名称放在方括号之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call([1, 2]));</span><br><span class="line">// → [object Array]</span><br></pre></td></tr></table></figure>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p>我们在前一章中看到了一个用于通过将函数应用于其元素来转换数据结构的操作。令人困惑的是，在编程中，相同的单词也用于相关但差异相当大的东西。</p>
<p><code>map</code>（名词）是将值（键key）与其他值相关联的数据结构。例如，你可能希望将名称映射到年龄。你可能会为此使用对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let ages = &#123;</span><br><span class="line">  Boris: 39,</span><br><span class="line">  Liang: 22,</span><br><span class="line">  Júlia: 62</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(`Júlia is $&#123;ages[&quot;Júlia&quot;]&#125;`);</span><br><span class="line">// → Júlia is 62</span><br><span class="line">console.log(&quot;Is Jack&apos;s age known?&quot;, &quot;Jack&quot; in ages);</span><br><span class="line">// → Is Jack&apos;s age known? false</span><br><span class="line">console.log(&quot;Is toString&apos;s age known?&quot;, &quot;toString&quot; in ages);</span><br><span class="line">// → Is toString&apos;s age known? true</span><br></pre></td></tr></table></figure>
<p>这里，对象的属性名称是人名，属性值是他们的年龄。但我们当然没有在对象中列出任何名为<code>toString</code>的人。然而，因为普通对象派生自<code>Object.prototype</code>，所以<code>toSting</code>属性就在那里。</p>
<p>因此，使用普通对象作为地图是危险的。有几种方法可以避免这个问题。首先，可以创建任何没有原型的对象。如果将null传递给<code>Object.create</code>，则生成的对象将不会从<code>Object.prototype</code>派生，并且可以安全地用作映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;toString&quot; in Object.create(null));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<p>对象属性名称必须是字符串。如果你需要一个其键无法轻松转换为字符串的映射（如对象），可是无法使用对象作为你自定义的映射的键。</p>
<p>幸运的是，JavaScript 附带了一个名为<code>Map</code>的类，它是为了这个目的而诞生的。它存储映射并允许任何类型的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let ages = new Map();</span><br><span class="line">ages.set(&quot;Boris&quot;, 39);</span><br><span class="line">ages.set(&quot;Liang&quot;, 22);</span><br><span class="line">ages.set(&quot;Júlia&quot;, 62);</span><br><span class="line"></span><br><span class="line">console.log(`Júlia is $&#123;ages.get(&quot;Júlia&quot;)&#125;`);</span><br><span class="line">// → Júlia is 62</span><br><span class="line">console.log(&quot;Is Jack&apos;s age known?&quot;, ages.has(&quot;Jack&quot;));</span><br><span class="line">// → Is Jack&apos;s age known? false</span><br><span class="line">console.log(ages.has(&quot;toString&quot;));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<p>方法<code>set</code>，<code>get</code>和<code>has</code>是<code>Map</code>对象接口的一部分。编写可以快速更新和搜索大量值的数据结构并不容易，但我们不必为此担心。有人已经为我们做了，我们可以通过这个简单的接口来使用他们提供的成就。</p>
<p>如果你确实因为某种原因需要将一个普通的对象视为一个映射，那么就有必要了解到<code>Object.keys</code>只返回对象自己的键值，而不是原型中的那些键。作为<code>in</code>运算符的替代，你可以使用<code>hasOwnProperty</code>方法，该方法忽略对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;x: 1&#125;.hasOwnProperty(&quot;x&quot;));</span><br><span class="line">// → true</span><br><span class="line">console.log(&#123;x: 1&#125;.hasOwnProperty(&quot;toString&quot;));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>当你在对象上调用<code>String</code>函数（将值转换为字符串）时，它将调用该对象上的<code>toString</code>方法以尝试从中创建有意义的字符串。我提到过一些标准原型定义了他们的<code>toString</code>方法，因此他们可以创建一个比<code>“[object Object]”</code>包含更多的信息的字符串。你也可以自己实现一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.toString = function() &#123;</span><br><span class="line">  return `a $&#123;this.type&#125; rabbit`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(String(blackRabbit));</span><br><span class="line">// → a black rabbit</span><br></pre></td></tr></table></figure>
<p>这是一个强大的想法的简单实例。当编写一段代码来处理具有特定接口的对象时–在上面的例子里是<code>toString</code>方法–任何支持此接口的对象都可以接入到代码中，它都可以正常工作。</p>
<p>这种技术称为“多态”。多态代码可以使用不同形式的值，只要它们支持它所期望的接口即可。</p>
<p>我在第4章中提到过<code>for...of...</code>循环可以遍历几种数据结构。这是多态的另一种情况–这种循环期望数据结构暴露特定接口，数组和字符串都是这样做的。我们还可以将这类接口添加到你自己的对象中！ 但在我们这样做之前，我们需要知道 symbol 是什么。</p>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>多个接口可以针对不同的事物使用相同的属性名称。例如，我可以定义一个接口，其中<code>toString</code>方法应该将对象转换为一段纱线。对象不可能同时满足该接口和<code>toString</code>的标准用法。</p>
<p>这不是一个坏主意，这个问题并不常见。大多数 JavaScript 程序员根本就没有考虑过这种问题。但这门语言的设计者，无论如何都要考虑这些东西的人，为我们提供了解决方案。</p>
<p>当我说属性名称是字符串时，这并不完全准确。它们通常是，但它们也可以是 symbol。symbol 是使用<code>Symbol</code>函数创建的值。与字符串不同，新创建的 symbol 是唯一的，即你不能两次创建相同的 symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(&quot;name&quot;);</span><br><span class="line">console.log(sym == Symbol(&quot;name&quot;));</span><br><span class="line">// → false</span><br><span class="line">Rabbit.prototype[sym] = 55;</span><br><span class="line">console.log(blackRabbit[sym]);</span><br><span class="line">// → 55</span><br></pre></td></tr></table></figure>
<p>当你将其转换为字符串时，会包含之前传递给<code>Symbol</code>的字符串，并且可以在控制台中显示 symbol 时更容易识别 symbol。但它没有任何含义–多个符号可能具有相同的名称。</p>
<p>既独一无二又可用作属性名称，使得 symbol 适用于定义可与其他属性并存的接口，无论它们的名称是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const toStringSymbol = Symbol(&quot;toString&quot;);</span><br><span class="line">Array.prototype[toStringSymbol] = function() &#123;</span><br><span class="line">  return `$&#123;this.length&#125; cm of blue yarn`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log([1, 2].toString());</span><br><span class="line">// → 1,2</span><br><span class="line">console.log([1, 2][toStringSymbol]());</span><br><span class="line">// → 2 cm of blue yarn</span><br></pre></td></tr></table></figure>
<p>通过在属性名称周围使用方括号，可以在对象表达式和类中包含 symbol 属性。就像方括号属性访问表示法一样，将会对属性名称进行求值，因此它允许我们引用包含 symbol 的绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let stringObject = &#123;</span><br><span class="line">  [toStringSymbol]() &#123; return &quot;a jute rope&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(stringObject[toStringSymbol]());</span><br><span class="line">// → a jute rope</span><br></pre></td></tr></table></figure>
<h3 id="The-iterator-interface"><a href="#The-iterator-interface" class="headerlink" title="The iterator interface"></a>The iterator interface</h3><p>赋予<code>for...of...</code>循环的对象应该是可迭代的。这意味着它有一个用<code>Symbol.iterator</code>符号命名的方法（由语言定义的符号值，存储为<code>Symbol</code>函数的属性）。</p>
<p>被调用时，该方法应该返回一个提供第二个接口：迭代器，的对象。这是迭代的实际内容。它有个返回下一个结果的<code>next</code>方法。该结果应该是一个具有<code>value</code>属性的对象，该属性提供下一个值（如果有）和<code>done</code>属性，当没有更多结果时<code>done</code>应该为<code>true</code>，否则为<code>false</code>。</p>
<p>请注意，<code>next</code>，<code>value</code>和<code>done</code>属性名称是纯字符串，而不是 symbol。只有能添加到许多不同对象的<code>Symbol.iterator</code>才是真正的 symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let okIterator = &quot;OK&quot;[Symbol.iterator]();</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: &quot;O&quot;, done: false&#125;</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: &quot;K&quot;, done: false&#125;</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>让我们实现一个可迭代的数据结构。我们将构建一个 martrix 类，充当二维数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Matrix &#123;</span><br><span class="line">  constructor(width, height, element = (x, y) =&gt; undefined) &#123;</span><br><span class="line">    this.width = width;</span><br><span class="line">    this.height = height;</span><br><span class="line">    this.content = [];</span><br><span class="line"></span><br><span class="line">    for (let y = 0; y &lt; height; y++) &#123;</span><br><span class="line">      for (let x = 0; x &lt; width; x++) &#123;</span><br><span class="line">        this.content[y * width + x] = element(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(x, y) &#123;</span><br><span class="line">    return this.content[y * this.width + x];</span><br><span class="line">  &#125;</span><br><span class="line">  set(x, y, value) &#123;</span><br><span class="line">    this.content[y * this.width + x] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类将其内容存储在含有 width × height 个元素的单个数组中。元素是逐行存储的，因此，例如，第五行中的第三个元素是（使用从零开始的索引）存储在位置 4 × 宽 + 2。</p>
<p>构造函数采用<code>width</code>，<code>height</code>和可选<code>element</code>函数，用于填充初始值。有<code>get</code>和<code>set</code>方法来检索和更新矩阵中的元素。</p>
<p>在循环遍历矩阵时，你也许会对元素的位置以及元素本身感兴趣，因此我们将使用迭代器生成具有<code>x</code>，<code>y</code>和<code>value</code>属性的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MatrixIterator &#123;</span><br><span class="line">  constructor(matrix) &#123;</span><br><span class="line">    this.x = 0;</span><br><span class="line">    this.y = 0;</span><br><span class="line">    this.matrix = matrix;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    if (this.y == this.matrix.height) return &#123;done: true&#125;;</span><br><span class="line"></span><br><span class="line">    let value = &#123;x: this.x,</span><br><span class="line">                 y: this.y,</span><br><span class="line">                 value: this.matrix.get(this.x, this.y)&#125;;</span><br><span class="line">    this.x++;</span><br><span class="line">    if (this.x == this.matrix.width) &#123;</span><br><span class="line">      this.x = 0;</span><br><span class="line">      this.y++;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;value, done: false&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类通过<code>x</code>和<code>y</code>属性跟踪迭代矩阵的过程。<code>next</code>方法首先检查是否已到达矩阵的底部。如果没有，则首先创建保存当前值的对象，然后更新其位置，如果可以的话移动到下一行。</p>
<p>让我们将<code>Matrix</code>类变成可迭代的。在本书中，我偶尔会使用“马后炮”一样的原型操作来向类添加方法，以便各个代码段保持短小并各自独立。在日常编程中，不需要将代码拆分成小块，而是直接在类中声明这些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Matrix.prototype[Symbol.iterator] = function() &#123;</span><br><span class="line">  return new MatrixIterator(this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>for...of...</code>来遍历矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let matrix = new Matrix(2, 2, (x, y) =&gt; `value $&#123;x&#125;,$&#123;y&#125;`);</span><br><span class="line">for (let &#123;x, y, value&#125; of matrix) &#123;</span><br><span class="line">  console.log(x, y, value);</span><br><span class="line">&#125;</span><br><span class="line">// → 0 0 value 0,0</span><br><span class="line">// → 1 0 value 1,0</span><br><span class="line">// → 0 1 value 0,1</span><br><span class="line">// → 1 1 value 1,1</span><br></pre></td></tr></table></figure>
<h3 id="Getters-setters-and-statics"><a href="#Getters-setters-and-statics" class="headerlink" title="Getters, setters, and statics"></a>Getters, setters, and statics</h3><p>接口通常由函数方法组成，但也可以包含保存非函数值的属性。例如，<code>Map</code>对象具有一个<code>size</code>属性，可以告诉你存储了多少个键。</p>
<p>这样的对象甚至不需要直接在实例中计算和存储这样的属性。即使是直接访问的属性也可能有潜在的函数调用。这些方法称为getter，它们是通过在对象表达式或类声明中的方法名称前写<code>get</code>来定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let varyingSize = &#123;</span><br><span class="line">  get size() &#123;</span><br><span class="line">    return Math.floor(Math.random() * 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(varyingSize.size);</span><br><span class="line">// → 73</span><br><span class="line">console.log(varyingSize.size);</span><br><span class="line">// → 49</span><br></pre></td></tr></table></figure>
<p>只要有人从此对象的<code>size</code>属性中读取，就会调用关联的方法。使用<code>setter</code>写入属性时，你可以执行类似的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Temperature &#123;</span><br><span class="line">  constructor(celsius) &#123;</span><br><span class="line">    this.celsius = celsius;</span><br><span class="line">  &#125;</span><br><span class="line">  get fahrenheit() &#123;</span><br><span class="line">    return this.celsius * 1.8 + 32;</span><br><span class="line">  &#125;</span><br><span class="line">  set fahrenheit(value) &#123;</span><br><span class="line">    this.celsius = (value - 32) / 1.8;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static fromFahrenheit(value) &#123;</span><br><span class="line">    return new Temperature((value - 32) / 1.8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let temp = new Temperature(22);</span><br><span class="line">console.log(temp.fahrenheit);</span><br><span class="line">// → 71.6</span><br><span class="line">temp.fahrenheit = 86;</span><br><span class="line">console.log(temp.celsius);</span><br><span class="line">// → 30</span><br></pre></td></tr></table></figure>
<p><code>Temperature</code>类允许你以摄氏度或华氏度读取和写入温度，但在内部它仅存储摄氏度并自动在<code>fahrenheit</code> getter 和 setter 中转换为摄氏温度。</p>
<p>有时你希望将一些属性直接附加到构造函数，而不是原型。此类方法无法访问类实例，但可以用于提供创建实例的其他方法。</p>
<p>在类声明中，在名称之前写有<code>static</code>的方法存储在构造函数中。因此，<code>Temperature</code>类允许你编写<code>Temperature.fromFahrenheit（100）</code>以使用华氏度创建温度。</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>已知一些矩阵是对称的。如果以左上角到右下角的对角线镜像反转这种矩阵，它将保持不变。换句话说，存储在x，y的值总是与y，x处的值相同。</p>
<p>假设我们需要一个像 Matrix 这样的数据结构，但却强制要求矩阵是对称的。我们可以从头开始编写它，但这将涉及重复一些与我们已编写的代码非常相似的代码。</p>
<p>JavaScript 的原型系统可以创建一个就像旧类一样的新类，但是对它的一些属性可以重新定义。新类的原型来自旧的原型，但为<code>set</code>方法添加了新的定义。</p>
<p>在面向对象的编程术语中，这称为继承。新类继承旧类的属性和行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SymmetricMatrix extends Matrix &#123;</span><br><span class="line">  constructor(size, element = (x, y) =&gt; undefined) &#123;</span><br><span class="line">    super(size, size, (x, y) =&gt; &#123;</span><br><span class="line">      if (x &lt; y) return element(y, x);</span><br><span class="line">      else return element(x, y);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(x, y, value) &#123;</span><br><span class="line">    super.set(x, y, value);</span><br><span class="line">    if (x != y) &#123;</span><br><span class="line">      super.set(y, x, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let matrix = new SymmetricMatrix(5, (x, y) =&gt; `$&#123;x&#125;,$&#123;y&#125;`);</span><br><span class="line">console.log(matrix.get(2, 3));</span><br><span class="line">// → 3,2</span><br></pre></td></tr></table></figure>
<p>使用关键词<code>extends</code>表示此类不应直接基于默认的<code>Object</code>原型，而应基于其他类。这被称为超类，由它派生出的类叫子类。</p>
<p>要初始化<code>SymmetricMatrix</code>实例，构造函数通过<code>super</code>关键字调用其超类的构造函数。如果想要这个新对象的行为（大致）类似于Matrix，那么这是必要的，它将需要矩阵具有的实例属性。为了确保矩阵是对称的，构造函数包装<code>element</code>函数以交换对角线下方的值的坐标。</p>
<p><code>set</code>方法再次使用<code>super</code>，但这次不是调用构造函数，而是从超类的方法集调用特定方法。我们正在重新定义<code>set</code>但确实想要使用原始行为。因为<code>this.set</code>引用的是新的<code>set</code>方法，所以调用它不起作用。在类内部方法中，<code>super</code>提供了一种调用方法的方法，能以它们在超类中定义的形式调用。</p>
<p>继承允许我们使用相对较少的工作基于现有数据类型构建稍微不同的数据类型。它是面向对象传统的基本组成部分，包括封装和多态。在现在，后两者普遍被视为绝妙的想法，但继承更具争议性。</p>
<p>封装和多态可以用来将代码片段彼此分开，减少整个程序的纠缠，而继承从根本上将类连接在一起，创造更多的纠缠。从类继承时，你通常必须比仅使用它更多地了解它的工作原理。继承可以是一个有用的工具，我现在在我自己的程序中使用它，但它不应该是你第一个想到使用的工具，你可能不会乐意寻找机会来构建类层次结构（家庭树类）。</p>
<h3 id="The-instanceof-operator"><a href="#The-instanceof-operator" class="headerlink" title="The instanceof operator"></a>The instanceof operator</h3><p>有时知道对象是否来自特定类是有用的。为此，JavaScript 提供了一个名为<code>instanceof</code>的二元运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new SymmetricMatrix(2) instanceof SymmetricMatrix);</span><br><span class="line">// → true</span><br><span class="line">console.log(new SymmetricMatrix(2) instanceof Matrix);</span><br><span class="line">// → true</span><br><span class="line">console.log(new Matrix(2, 2) instanceof SymmetricMatrix);</span><br><span class="line">// → false</span><br><span class="line">console.log([1] instanceof Array);</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure>
<p>运算符将查看继承的类型，因此<code>SymmetricMatrix</code>是<code>Matrix</code>的实例。运算符也可以应用于像<code>Array</code>这样的标准构造函数。几乎每个对象都是<code>Object</code>的一个实例。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>所以对象不只是拥有自己的属性。他们有原型，是其他对象。只要他们的原型具有该属性，他们将表现得好像他们拥有他们没有的属性。简单对象将<code>Object.prototype</code>作为其原型。</p>
<p>构造函数是名称通常以大写字母开头的函数，可以与<code>new</code>操作符一起使用来创建新对象。新对象的原型将是构造函数的<code>prototype</code>属性中找到的对象。你可以充分利用这一点，将所有给定对象都要共享的属性放入其原型中。有一个<code>class</code>的声明方式，提供了一种用来定义构造函数及其原型的简明的方法。</p>
<p>每次访问对象的属性时，你都可以定义 getter 和 setter 以隐蔽地调用方法。静态方法是存储在类的构造函数中的方法，而不是其原型。</p>
<p>传入参数为对象和构造函数，<code>instanceof</code>运算符可以告诉你该对象是否是该构造函数的实例。</p>
<p>对象的一个有用的事情是为它们指定一个接口，并告诉每个人他们应该只通过该接口与你的对象交互。构成对象的其余细节现在已封装，隐藏在接口之后。</p>
<p>多个类型可以实现相同的接口。为使用接口而编写的代码知道如何与提供接口的任意数量的不同对象交互。这称为多态性。</p>
<p>当实现仅在某些细节上有所不同的多个类时，将新类编写为现有类的子类，继承其部分行为可能会有所帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/05/10/译-eloquent-javascript-Objects/" data-id="ck92tz1xy000qrkornk08k6eu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/translation/">translation</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/translation/">translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/">vscode</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Chemistry/" style="font-size: 15px;">Chemistry</a> <a href="/tags/ECMAscript/" style="font-size: 17.5px;">ECMAscript</a> <a href="/tags/Hexo/" style="font-size: 12.5px;">Hexo</a> <a href="/tags/Python/" style="font-size: 12.5px;">Python</a> <a href="/tags/React/" style="font-size: 12.5px;">React</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/translation/" style="font-size: 20px;">translation</a> <a href="/tags/vscode/" style="font-size: 15px;">vscode</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/16/Docker-in-WSL/">Docker in WSL</a>
          </li>
        
          <li>
            <a href="/2020/04/12/Git-学习/">Git 学习</a>
          </li>
        
          <li>
            <a href="/2020/04/06/pandas-读取Excel/">pandas 处理 Excel</a>
          </li>
        
          <li>
            <a href="/2020/04/05/Anaconda-VSCode环境搭建/">Anaconda+VSCode环境搭建</a>
          </li>
        
          <li>
            <a href="/2020/03/11/hexo-fatal-error/">hexo fatal error</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Watch Out<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>