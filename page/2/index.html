<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Watchout的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Watchout的博客">
<meta property="og:url" content="https://shiftwatchout.github.io/page/2/index.html">
<meta property="og:site_name" content="Watchout的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Watchout的博客">
  
    <link rel="alternate" href="/atom.xml" title="Watchout的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Watchout的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shiftwatchout.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-译-eloquent-javascript-Values-Types-and-Operators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/译-eloquent-javascript-Values-Types-and-Operators/" class="article-date">
  <time datetime="2019-03-27T04:03:34.000Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/译-eloquent-javascript-Values-Types-and-Operators/">译-eloquent-javascript-Values,Types and Operators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>“在机器的表面之下，是程序在运作。无需做功，它就会扩张和收缩。在大和谐中，电子分散重组。显示器上的图形不过是水面上的涟漪。它的本质隐藏在下面。”—-Master Yuan-Ma, The Book of Programming</p>
</blockquote>
<p><img src="https://eloquentjavascript.net/img/chapter_picture_1.jpg" alt="img"></p>
<p>在计算机的世界里，只有数据。您可以读取数据、修改数据、创建新数据，但是绝不能涉及到非数据的东西。所有这些数据都存储为长序列的比特位，因此本质上是相似的。</p>
<p>比特（Bit）是任何两值的东西，通常被描述为0和1。在计算机内部,他们把形式如高低电平,强弱信号或CD表面的明暗斑点。任何离散的信息都可以转化为一系列的0和1,从而用比特位（Bit）展现出来。</p>
<p>例如，我们可以用比特来表示数字13。它的工作原理与十进制数相同，但它用到的不是10个不同的数字，只有2个，而且每个数的权值从右到左增加了2倍。下面是组成数字13的比特位，数字的权值如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  0   0   0   0   1   1   0   1</span><br><span class="line">128  64  32  16   8   4   2   1</span><br></pre></td></tr></table></figure></p>
<p>这就是二进制数00001101。它的非零比特位意味着，8、4和1加起来是13。</p>
<h2 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h2><p>想象一片由比特的海洋一个小块的海洋。典型的现代计算机在其易失性数据存储(运行内存)中有300多亿比特。非易失性存储(硬盘或类似的存储)往往还有几个数量级。</p>
<p>为了能够在不丢失信息的情况下处理如此多的比特，我们必须将它们分割成表示信息片段的块。在JavaScript环境中，这些块称为值。虽然所有的值都是由比特组成的，但是它们发挥着不同的作用。每个值都有一个类型来决定其定位。有些值是数字，有些值是文本片段，有些值是函数，等等。</p>
<p>要创建一个值，你只需要调用它的名称。这是很方便的。你不需要为你的值收集建筑材料，也不需要为它们买单。你只要调用一下，呼，就行了。当然，它们并不是凭空产生的。每个值都必须存储在某个地方，如果您想同时运算大量的值，可能会耗尽内存。幸运的是，只有当您同时需要它们时，这个问题才会发生。一旦你不再使用一个值，它就会消失，留下它的比特回收，作为下一代的值的建筑材料。</p>
<p>本章介绍JavaScript程序的基础，即简单的数值类型以及可以对这些值进行运算的操作符。</p>
<h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><p>毫无疑问，数字类型的值是数值。在JavaScript程序中，它们是这样编写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>在程序中使用它，将导致数字13的比特在计算机内存中以一定模式形成。</p>
<p>JavaScript使用定长的位(64位)来存储单个数字值。而使用64位只能弄出这么点儿花样，这意味着可以表示出的不同数字的数量是有限的。用N位十进制数，可以表示出10<sup>N</sup>个数字。同样，用64位二进制数字，可以表示出2<sup>64</sup>个不同的数字，大约是18万兆(18后面有18个零)。那可是个大数。</p>
<p>过去，计算机内存要小得多，人们倾向于使用8位或16位的组合来表示数字。这么小的数字一不小心就很容易超出给定的大小，结果得到一个与给定位数不符的数字。今天，即使是放在口袋里的电脑也有足够的内存，所以你可以自由地使用64位的数据块，只有在处理真正天文数字时才需要担心内存溢出。</p>
<p>不过，并非所有小于18万兆的整数都可以被JavaScript表示出来。这些位空间也存储负数，所以有1位被用来表示数字的正负符号。更大的问题是，还需要表示非整数。为此，一些位被用来存储小数点的位置。实际可存储的最大整数更多地在9千兆(15个零)的范围内，这仍然是一个令人愉快的巨大数字。</p>
<p>小数是用加点来表示的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9.81</span><br></pre></td></tr></table></figure></p>
<p>对于非常大或非常小的数字，可以使用科学计数，在数字的指数前面加上e(代表指数)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.998e8</span><br></pre></td></tr></table></figure></p>
<p>这是 2.998 x 10<sup>8</sup> = 299,800,000</p>
<p>使用上述的小于9千兆的整数进行计算，可以保证结果始终是精确的。不幸的是，使用小数的计算通常不是。就像π不能用有限小数精确表达一样,许多数字因只有64位可用来存储它们而失去了一些精度。这是一个遗憾，但它只在特定的情况下造成实际问题。重要的是要意识到这一点，并将分数数字视为近似值，而不是精确值。</p>
<h2 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h2><p>与数字关系密切的事就是算术。算术运算，如加法或乘法，取两个数值，并得到一个新的数字。下面是它们在JavaScript中的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 + 4 * 11</span><br></pre></td></tr></table></figure></p>
<p><code>+</code>和<code>*</code>符号称为运算符。第一个代表加法，第二个代表乘法。将运算符放在两个值之间将作用于这些值并生成一个新值。</p>
<p>但是这个例子的意思是加4和100，再把结果乘以11，还是在加之前就做了乘法？你可能已经猜到了，乘法先运算。但就像在数学中一样，你可以通过把加法括在括号里来改变顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(100 + 4) * 11</span><br></pre></td></tr></table></figure></p>
<p>对于减法，有<code>-</code>运算符，除法有<code>/</code>运算符。</p>
<p>当运算符一起出现而没有括号时，它们的应用顺序由运算符的优先级决定。这个例子表明乘法先于加法，<code>/</code>运算符的优先级与<code>*</code>相同，<code>+</code>和<code>-</code>也相同。当具有相同优先级的多个运算符彼此相邻出现时，如在<code>1 - 2 + 1</code>中，它们从左向右运算: <code>( 1 - 2 ) + 1</code>。</p>
<p>你不用担心这些优先级规则。在不确定时，加上括号即可。</p>
<p>还有一个算术运算符，您可能不会马上认出来。<code>%</code>符号用于表示求余运算。<code>X % Y</code>是<code>X</code>除以<code>Y</code>的余数。例如，<code>314 % 100</code>得到<code>14</code>,<code>144 % 12</code>得到<code>0</code>。余数运算符的优先级与乘除运算的优先级相同。您还将经常看到这个运算符被称为模。</p>
<h2 id="Special-numbers"><a href="#Special-numbers" class="headerlink" title="Special numbers"></a>Special numbers</h2><p>JavaScript中有三个特殊值被认为是数字，但它们的行为与普通数字不同。</p>
<p>前两个是<code>Infinity</code>和<code>- Infinity</code>，它们表示正无穷和负无穷。<code>Infinity - 1</code>仍然是<code>Infinity</code>，依此类推。不过，不要过于相信基于无穷大的计算。它在数学上是不合理的，它引出了下一个特殊值：<code>NaN</code>。</p>
<p><code>NaN</code>意味着“不是数字（not a number）”，尽管如此它却是数字类型的值。例如，当你尝试计算<code>0 / 0</code> (零除以零)、<code>Infinity - Infinity</code>或任何产生无意义结果的数值运算时，就会得到这个结果。</p>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>下一个基本数据类型是字符串。字符串用于表示文本。要编写字符串需要将它们包含在引号之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`Down on the sea`</span><br><span class="line">&quot;Lie on the ocean&quot;</span><br><span class="line">&apos;Float on the ocean&apos;</span><br></pre></td></tr></table></figure></p>
<p>您可以使用单引号、双引号或反引号来标记字符串，只要字符串的开头和结尾的引号匹配即可。</p>
<p>几乎任何东西都可以放在引号之间，JavaScript会从中生成一个字符串值。但是有几个字符比较难。您可以想象为引号之间的内容加上引号是多么困难。有当字符串被反引号（`）括起来的时候‘换行’(按enter时得到的字符)才不会被弄丢。</p>
<p>为了能在字符串中表示出这样的字符，要用到以下表示法：无论何时在引用的文本中发现反斜杠（\），它都表示后面的字符具有特殊的含义。这叫做转义字符。前加反斜杠的引号（\“）不会结束字符串，而是字符串的一部分。当反斜杠后面出现一个n时，它被解释为换行符。类似地，反斜杠后面跟t表示制表符。下面的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;This is the first line\nAnd this is the second&quot;</span><br></pre></td></tr></table></figure></p>
<p>实际呈现出的文本会是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the first line</span><br><span class="line">And this is the second</span><br></pre></td></tr></table></figure></p>
<p>当然，在某些情况下，您希望字符串中的反斜杠只是反斜杠，而不是特殊代码。如果两个反斜杠紧密相依，它们就会崩塌，结果字符串值中只剩下一个反斜杠。下面就是如何将“A newline character is written like “\n”.”表示出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A newline character is written like \&quot;\\n\&quot;.&quot;</span><br></pre></td></tr></table></figure></p>
<p>字符串也必须被转换为一系列的位，才能够存在于计算机中。JavaScript基于Unicode标准实现字符串的存储。这个标准几乎为你需要的每个字符分配了一个数字，包括来自希腊、阿拉伯、日本、美国等国家的字符。如果每个字符都有一个数字，那么字符串可以由一系列数字来描述。</p>
<p>这就是JavaScript所做的。但是有一个复杂之处：JavaScript使用16比特来表示每一个字符串中的元素，最多可以描述2<sup>16</sup>个不同的字符。但是Unicode定义的字符比这个多，大约是这个数字的两倍。因此，一些字符，比如许多表情符号，在JavaScript字符串中占据两个字符位。我们将在第5章中回到这一点。</p>
<p>字符串不能被除、乘或减，但可以对其使用<code>+</code>运算符。它不执行加法，而是将两个字符串拼接在一起。下面的相加将生成字符串“concatenate”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;con&quot; + &quot;cat&quot; + &quot;e&quot; + &quot;nate&quot;</span><br></pre></td></tr></table></figure></p>
<p>字符串值有许多与之相关的，可以对其进行其他操作的函数(方法)。我将在第4章详细介绍这些。</p>
<p>使用单引号或双引号编写的字符串的行为非常相似，唯一的区别是你需要在其中显示哪种类型的引号。反引号引用的字符串，通常称为模板字符串，可以衍生出更多的技巧。除了能够跨行之外，它们还可以嵌入其他值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`half of 100 is $&#123;100 / 2&#125;`</span><br></pre></td></tr></table></figure></p>
<p>当您在模板字符串中的<code>${ }</code>中写入表达式时，JavaScript将会执行里面的内容，并将其结果转换为字符串，将其包含在该位置。这个例子的结果是 “half of 100 is 50”。</p>
<h2 id="Unary-operators"><a href="#Unary-operators" class="headerlink" title="Unary operators"></a>Unary operators</h2><p>并不是所有的运算符都是符号。有些被写成词组。其中一个例子是<code>typeof</code>操作符，它生成一个表明你给定的值的类型的字符串值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof 4.5)</span><br><span class="line">// → number</span><br><span class="line">console.log(typeof &quot;x&quot;)</span><br><span class="line">// → string</span><br></pre></td></tr></table></figure></p>
<p>在示例代码中，我们将使用<code>console.log</code>来表示我们想要看到运行结果。下一章会详细介绍。</p>
<p>其他已经出现的运算符都是对两个值进行操作的运算，但是<code>typeof</code>只接受一个值。使用两个值的运算符称为二元运算符，而使用一个值的运算符称为一元运算符。<code>-</code>既可用作二元运算符，也可用作一元运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(- (10 - 2))</span><br><span class="line">// → -8</span><br></pre></td></tr></table></figure></p>
<h2 id="Boolean-values"><a href="#Boolean-values" class="headerlink" title="Boolean values"></a>Boolean values</h2><p>用一个值可以区分仅有的两种可能性，比如“yes”和“no”或“on”和“off”，这通常是很有用的。为此，JavaScript有一个布尔类型，这种类型总共只有两个值，<code>true</code>和<code>false</code>，就以这两个单词的形式拼写。</p>
<h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><p>有一种产生Boolean值的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(3 &gt; 2)</span><br><span class="line">// → true</span><br><span class="line">console.log(3 &lt; 2)</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p>>和&lt;符号分别表示大于和小于。它们是二元运算符。它们的运算会得到一个布尔值，该值表明它们在本例中是否成立。</p>
<p>字符串可以用同样的方法进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Aardvark&quot; &lt; &quot;Zoroaster&quot;)</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure></p>
<p>字符串的排序方式大致是按字母顺序排列的，但并不严格是您所期望的在字典中看到的顺序:大写字母总是小于小写字母，因此“Z”&lt;“a”和非字母字符(!， -，等等)也包括在排序之中。当比较字符串时，JavaScript从左到右遍历字符，逐个比较Unicode码。</p>
<p>其他类似的操作符有&gt;=(大于或等于)、&lt;=(小于或等于)、==(等于)和!=(不等于)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Itchy&quot; != &quot;Scratchy&quot;)</span><br><span class="line">// → true</span><br><span class="line">console.log(&quot;Apple&quot; == &quot;Orange&quot;)</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p>JavaScript中只有一个值不等于它自己，那就是<code>NaN</code>(不是数字)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN == NaN)</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p><code>NaN</code>应该表示无意义计算的结果，因此，它不等于任何其他无意义计算的结果。</p>
<h2 id="Logical-operators"><a href="#Logical-operators" class="headerlink" title="Logical operators"></a>Logical operators</h2><p>还有一些运算可以应用到布尔值上。JavaScript支持三个逻辑操作符：<code>and</code>, <code>or</code>, 和 <code>not</code>。这些可以用来演算布尔值。</p>
<p>&amp;&amp;操作符表示逻辑与。它是一个二元运算符，只有当给定的两个值都为真时，它的结果才为真。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(true &amp;&amp; false)</span><br><span class="line">// → false</span><br><span class="line">console.log(true &amp;&amp; true)</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure></p>
<p>||操作符表示逻辑或。如果给定的值有一个为真，结果就为真。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(false || true)</span><br><span class="line">// → true</span><br><span class="line">console.log(false || false)</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p>逻辑非被写成感叹号(!)。这是一个一元运算符，它翻转给它的值，<code>!true</code>产生<code>false</code>，而<code>!false</code>给出<code>true</code>。</p>
<p>当将这些布尔运算符与算术运算符和其他运算符混合使用时，需要用到括号的时机总是不明显。在实践中，通常只会出现以上的操作符，因此有必要记一下，<code>||</code>的优先级最低，然后是<code>&amp;&amp;</code>，然后是比较操作符(&gt;，==，等等)，然后是其他操作符。选择这种顺序的原因是，在下面的典型表达式中，括号越少越好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 1 == 2 &amp;&amp; 10 * 10 &gt; 50</span><br></pre></td></tr></table></figure></p>
<p>我将提到的最后一个逻辑运算符不是一元的，也不是二元的，而是三元的，它对三个值进行运算。它由问号和冒号组成，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(true ? 1 : 2);</span><br><span class="line">// → 1</span><br><span class="line">console.log(false ? 1 : 2);</span><br><span class="line">// → 2</span><br></pre></td></tr></table></figure></p>
<p>这个操作符称为条件操作符(有时也称为三元操作符，因为它是语言中惟一的三元操作符)。问号左边的值决定表达式的最终值为另外两个值中的哪一个。当它为真时，它选择中间的值，当它为假时，它选择右边的值。</p>
<h2 id="Empty-values"><a href="#Empty-values" class="headerlink" title="Empty values"></a>Empty values</h2><p>有两个特殊值，写做<code>null</code>和<code>undefined</code>，用于表示没有有意义的值。它们本身就是价值观念，但不包含任何信息。</p>
<p>语言中的许多操作并不能产生有意义的值(稍后您将看到一些)，它们产生的结果将是<code>undefined</code>，因为它们必须产生一些值。</p>
<p><code>undefined</code>和<code>null</code>之间的含义差异是JavaScript设计的一个意外，在大多数情况下并不重要。在实际需要关注这些值的情况下，我建议将它们视为可互换的。</p>
<h2 id="Automatic-type-conversion"><a href="#Automatic-type-conversion" class="headerlink" title="Automatic type conversion"></a>Automatic type conversion</h2><p>在Introduction中，我提到JavaScript会不遗余力地接受您提供的几乎所有程序，即使是执行奇怪任务的程序。下面的表达式很好地说明了这一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(8 * null)</span><br><span class="line">// → 0</span><br><span class="line">console.log(&quot;5&quot; - 1)</span><br><span class="line">// → 4</span><br><span class="line">console.log(&quot;5&quot; + 1)</span><br><span class="line">// → 51</span><br><span class="line">console.log(&quot;five&quot; * 2)</span><br><span class="line">// → NaN</span><br><span class="line">console.log(false == 0)</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure></p>
<p>当运算符作用于错误类型的值时，JavaScript将使用一组您通常不想要或不期望的规则悄悄地将该值转换为所需的类型。这被称为“强制类型转换”。第一个表达式中的<code>null</code>变为<code>0</code>，第二个表达式中的<code>“5”</code>变为<code>5</code>(从字符串到数字)。但是在第三个表达式中，<code>+</code>尝试在数字加法之前进行字符串连接，因此<code>1</code>被转换为<code>“1”</code>(从数字到字符串)。</p>
<p>当一个不容易轻松被转换成数字的东西(如<code>“5”</code>或<code>undefined</code>)被强制转换成数字时，您将得到值<code>NaN</code>。对<code>NaN</code>的进一步算术运算将继续生成<code>NaN</code>，因此，如果您发现自己在一个意想不到的地方得到了其中的一个，请寻找意料之外的类型转换。</p>
<p>当使用<code>==</code>比较相同类型的值时，结果很容易预测:当两个值相同时，<code>NaN</code>除外，您应该得到<code>true</code>。但是当类型不同时，JavaScript使用一组复杂而令人困惑的规则来决定该做什么。在大多数情况下，它只是尝试将其中一个值转换为另一个值的类型。但是，当<code>null</code>或<code>undefined</code>出现在操作符的任意一边时，只有当两边都是<code>null</code>或<code>undefined</code>时才会产生<code>true</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(null == undefined);</span><br><span class="line">// → true</span><br><span class="line">console.log(null == 0);</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure></p>
<p>这种行为通常很有用的。当您想要测试一个值是否具有实值而不是<code>null</code>或<code>undefined</code>时，可以使用<code>=</code>=(或<code>!=</code>)操作符将其与<code>null</code>进行比较。</p>
<p>但是，如果您想测试某个东西是否精确地引用了<code>false</code>呢?由于自动类型转换，像<code>0 == false</code>和<code>&quot;&quot; == false</code>这样的表达式也为真。当您不希望发生任何类型转换时，有两个额外的操作符:<code>===</code>和<code>!==</code>。第一个测试值是否与另一个值完全相等，第二个测试值是否完全不相等。所以<code>&quot;&quot; === false</code>将得到<code>false</code>。</p>
<p>我建议防御性地使用三个字符比较操作符，以防止意外的类型转换阻挠你的编程。但是，当您确定两边的类型相同时，使用较短的操作符也是没有问题的。</p>
<h2 id="Short-circuiting-of-logical-operators"><a href="#Short-circuiting-of-logical-operators" class="headerlink" title="Short-circuiting of logical operators"></a>Short-circuiting of logical operators</h2><p>逻辑运算符<code>&amp;&amp;</code>和<code>||</code>以一种特殊的方式处理不同类型的值。它们将左边的值转换为Boolean类型，以便决定接下来要做什么，但是根据操作符和转换的结果的不同，它们将返回原表达式的左边值或右边值。</p>
<p>例如，当可以将<code>||</code>左边的值转换为<code>true</code>时，<code>||</code>操作符将返回它左边的值，否则将返回它右边的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(null || &quot;user&quot;)</span><br><span class="line">// → user</span><br><span class="line">console.log(&quot;Agnes&quot; || &quot;user&quot;)</span><br><span class="line">// → Agnes</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用此功能作为返回到默认值的方法。如果您有一个值可能是空值，您可以在它后面加上一个<code>||</code>和替换值。如果可以将初始值转换为<code>false</code>，则会得到替换值。将字符串和数字转换为布尔值的规则规定，<code>0</code>、<code>NaN</code>和空字符串(<code>&quot;&quot;</code>)被视为<code>false</code>，而所有其他值都被视为<code>true</code>。<code>0 | | 1</code>得到<code>-1</code>,<code>&quot;&quot;| |&quot;!?&quot;</code>得到<code>!?</code>。</p>
<p><code>&amp;&amp;</code>操作符的工作原理与此类似，但正好相反。当其左边的值被转换为false时，它返回该值（<code>false</code>），否则返回其右边的值。</p>
<p>这两个操作符的另一个重要特性是，它们右边的部分只有在需要时才会被运算。在<code>true || X</code>的情况下，不管<code>X</code>是多少，即使它是一个做了一些差劲的事情程的序，结果都将是<code>true</code>，<code>X</code>永远不会被运算。对于<code>false &amp;&amp; X</code>也是一样，它是<code>false</code>，将忽略<code>X</code>。这称为短路求值。</p>
<p>条件运算符的工作原理类似。在第二个和第三个值中，只对选中的值求值。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在本章中，我们研究了四种类型的JavaScript值:数字、字符串、布尔值和未定义值。</p>
<p>这些值是通过键入它们的名称(<code>true</code>、<code>null</code>)或值( <code>13</code>，<code>&quot;abc&quot;</code>)创建的。您可以用运算符组合和转换值。我们看到了算术( <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、和<code>%</code>)、字符串连接( <code>+</code> )、比较( <code>==</code>、<code>!=</code>，<code>===</code>，<code>!==</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> )和逻辑( <code>&amp;&amp;</code>、<code>||</code> )运算符，以及几个一元运算符( <code>-</code>表示负数，<code>!</code>表示逻辑上否定，<code>typeof</code>找到值的类型)和三元运算符(<code>?:</code> )根据第三个值从两个值中选择一个。</p>
<p>这为您提供了足够的信息来使用JavaScript作为袖珍计算器，但仅此而已。下一章将开始把这些表达式绑定到基本程序中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/03/27/译-eloquent-javascript-Values-Types-and-Operators/" data-id="ck8n4bmgl000krsorni01ey2v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-译-eloquent-javascript-Introduction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/译-eloquent-javascript-Introduction/" class="article-date">
  <time datetime="2019-03-11T11:13:19.000Z" itemprop="datePublished">2019-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/译-eloquent-javascript-Introduction/">[译]Eloquent Javascript Introduction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>我们认为我们创造这个系统是为了我们自己的目的。我们相信我们正在按照自己的想象去做……但是电脑并不像我们。它是我们自身非常微小的一部分的投影:致力于逻辑、秩序、规则和清晰的那部分。—-Ellen Ullman，《Close to the Machine: Technophilia and its Discontents》</p>
</blockquote>
<p><img src="https://eloquentjavascript.net/img/chapter_picture_00.jpg" alt="img"></p>
<p>这是一本关于指挥计算机的书。如今，计算机就像螺丝刀一样常见，但它们要复杂得多，让它们做你想让它们做的事情并不总是那么容易。</p>
<p>如果你安排给电脑的是一个常见的，很容易理解的任务，比如显示你的电子邮件或发挥一个计算器的作用，你可以打开适当的应用程序开始工作。但对于独特的或开放式的任务，可能没有相应的应用程序。</p>
<p>这就是编程的用武之地。编程是建立一个程序的行为，建立一组精确的指令告诉计算机要做什么。由于计算机是愚蠢的、迂腐的野兽，编程从根本上来说是乏味和令人沮丧的。</p>
<p>幸运的是，如果你能克服这一事实，甚至能享受到用愚蠢的机器所能处理的方式进行严谨思考的乐趣，那么编程将是有益的。它可以让你在几秒钟内完成那些人力完成需要花费大量时间的事情。这是一种让你的电脑工具做它以前不能做的事情的方法。它提供了一个绝佳的抽象思维练习。</p>
<p>大多数程序都是用编程语言完成的。编程语言是一种人工构造的，用于指挥计算机的语言。有趣的是，我们所建立的与电脑沟通的最有效的方式，很大程度上借鉴了人与人之间沟通的方式。像人类语言一样，计算机语言允许单词和短语以新的方式组合在一起，使表达新的概念成为可能。</p>
<p>基于文字的界面，例如20世纪80年代和90年代的BASIC和DOS提示符，一度是与计算机交互的主要方法。它们在很大程度上已经被视觉界面所取代，视觉界面更容易学习，但提供的自由度更小。计算机语言仍然存在，如果你知道去哪里找的话。JavaScript就是这样一种语言，它内置在每个现代web浏览器中，因此几乎可以在任何设备上使用。</p>
<p>读完这本书后，你将足够熟悉这种语言，并用它做一些有用的和有趣的事情。</p>
<h2 id="On-programming"><a href="#On-programming" class="headerlink" title="On programming"></a>On programming</h2><p>除了解释JavaScript，我还将介绍编程的基本原理。事实证明，编程并不容易。基本规则简单明了，但是基于这些规则构建的程序往往会变得十分复杂，恰好展现出其规则性与复杂性。如果你正在建造自己的迷宫，你可能会迷失其中。</p>
<p>读者在阅读这本书时，有时会感到相当沮丧。如果你是编程新手，将会有很多新内容需要消化。并且之后你可以将这些内容通过额外的知识链接起来。</p>
<p>你可以做出必要的努力。当你在努力学习这本书的时候，不要对自己的能力妄下结论。你很棒-你只需要坚持下去。休息一下，重新阅读一些材料，确保你已经阅读并理解了示例程序和练习。学习是一项艰苦的工作，但你所学的一切都是你自己的，并且会让你以后的学习变得更容易。</p>
<blockquote>
<p>“当行动变得无利可图时，收集信息;当信息变得无利可图时，睡觉。”—-Ursula K. Le Guin, The Left Hand of Darkness</p>
</blockquote>
<p>程序是很多东西。它是由程序员输入的一段文本，它是使计算机做它所做的事情的指导力量，它是计算机内存中的数据，而且它还控制在同一内存上执行的操作。我们无法将程序与我们熟悉的对象进行类比。有一种看起来类似的机器，它由许多独立部件组成，为了使整个机器运转起来，我们必须考虑这些部件相互连接的方式，并对整个机器的运转做出贡献。</p>
<p>计算机是一种物理机器，充当这些非物质机器的主机。计算机本身只能做一些愚蠢而简单的事情。计算机如此有用的原因是它能以惊人的速度做这些事情。而程序可以巧妙地将大量简单的操作结合起来以完成非常复杂的事情。</p>
<p>程序就像是一座思想的大楼。它建造成本低，重量轻，而且在我们敲代码时很容易层层增高。</p>
<p>但是如不谨慎对待，程序的大小和复杂性将会失控，甚至会使创建它的人感到困惑。控制程序是编程的主要问题。当程序有用时，它是美丽的。编程的艺术是控制复杂性的技巧。伟大的计划因其复杂性而变得简单。</p>
<p>一些程序员认为，只有在他们的程序中使用一些易于理解的技巧，才能最好地管理这种复杂性。他们制定了严格的规则(最佳实践)，规定了程序该长成啥样，并留在他们的安全的小区域中。</p>
<p>这不仅无聊，而且低效。新问题往往需要新的解决方案。编程领域未发展成熟，仍在快速发展，它的多样性足以容纳各种各样的方法。在程序设计中有很多可怕的错误，你应该敢于犯这些错，这样你才能理解它们。一个好的程序该长成啥样的直觉是从实践中发现的，而不是从一堆规则中学到的。</p>
<h2 id="Why-language-matters"><a href="#Why-language-matters" class="headerlink" title="Why language matters"></a>Why language matters</h2><p>在计算机诞生之初，还没有编程语言。程序是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00110001 00000000 00000000</span><br><span class="line">00110001 00000001 00000001</span><br><span class="line">00110011 00000001 00000010</span><br><span class="line">01010001 00001011 00000010</span><br><span class="line">00100010 00000010 00001000</span><br><span class="line">01000011 00000001 00000000</span><br><span class="line">01000001 00000001 00000001</span><br><span class="line">00010000 00000010 00000000</span><br><span class="line">01100010 00000000 00000000</span><br></pre></td></tr></table></figure></p>
<p>这是一个把1到10的数字加在一起并打印出结果的程序:1 + 2 +…+ 10 = 55。它可以在一台简单的假想机器上运行。为了给早期的计算机编程，需要在正确的位置设置大量的开关阵列，或者在卡纸条上打孔，然后把它们输入计算机。你也许可以想象到这个过程是多么乏味和容易出错。即使是编写简单的程序也需要高智商和大量训练。复杂的程序更是几乎是不可想象的。</p>
<p>当然，手工输入这些神秘的比特语句(1和0组成)确实给了程序员一种成为强大巫师的强烈感觉。这在工作满意度方面还是有价值的。</p>
<p>前一个程序的每一行都包含一条指令。它可以这样用文字表述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 将数字0存储在内存位置0中。</span><br><span class="line">2. 将数字1存储在内存位置1中。</span><br><span class="line">3. 将内存位置1的值存储在内存位置2中。</span><br><span class="line">4. 从内存位置2的值中减去数字11。</span><br><span class="line">5. 如果内存位置2中的值是0，则从指令9继续执行。</span><br><span class="line">6. 将内存位置1的值加到内存位置0。</span><br><span class="line">7. 内存位置1的值加1。</span><br><span class="line">8. 从指令3继续执行。</span><br><span class="line">9. 输出内存位置0的值。</span><br></pre></td></tr></table></figure></p>
<p>尽管这已经比一堆比特更容易读懂，但它仍然相当晦涩。对指令和内存位置使用名称而不是数字会有所帮助。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set “total” to 0.</span><br><span class="line"> Set “count” to 1.</span><br><span class="line">[loop]</span><br><span class="line"> Set “compare” to “count”.</span><br><span class="line"> Subtract 11 from “compare”.</span><br><span class="line"> If “compare” is zero, continue at [end].</span><br><span class="line"> Add “count” to “total”.</span><br><span class="line"> Add 1 to “count”.</span><br><span class="line"> Continue at [loop].</span><br><span class="line">[end]</span><br><span class="line"> Output “total”.</span><br></pre></td></tr></table></figure></p>
<p>现在能看到程序是如何工作的吗？前两行给出了两个内存位置的初始值:<code>total</code>将用于构建计算结果，<code>count</code>将跟踪我们当前正在查看的数字。使用<code>compare</code>的代码行可能是最奇怪的。程序想要查看<code>count</code>是否等于11，以决定是否可以停止运行。因为我们假想机相当原始，它只能检测一个数字是否为零，然后据此做出决定。因此，它使用标记为<code>compare</code>的内存位置来计算<code>count - 11</code>的值，并根据该值做出决策。接下来的两行将<code>count</code>的值添加到结果中，每当程序确定<code>count</code>还不是11时，就将<code>count</code>增加1。</p>
<p>下面是用JavaScript编写的相同程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let total = 0, count = 1;</span><br><span class="line">while (count &lt;= 10) &#123;</span><br><span class="line">  total += count;</span><br><span class="line">  count += 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(total);  // → 55</span><br></pre></td></tr></table></figure></p>
<p>这个版本有了更多的改进。最重要的是，不再需要指定按照我们希望的方式程序来回跳转。<code>while</code>将负责处理这个问题。只要给定的条件依然成立，它就会继续执行它下面的块(大括号括起来的部分)。该条件是<code>count &lt;= 10</code>，这意味着<code>count</code>小于或等于10。我们不再需要创建一个临时值并将其与零进行比较，这只是细枝末节。编程语言的部分能力在于，它们可以为我们处理这些无趣的细节。</p>
<p>在程序的末尾，<code>while</code>执行完成后，使用<code>console.log</code>操作写出结果。</p>
<p>最后，如果我们碰巧有方便的操作<code>range</code>和<code>sum</code>可用，程序可能是这样的，它们分别在一个范围内创建一个数字集合并计算一个数字集合的和：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(range(1, 10)));</span><br><span class="line">// → 55</span><br></pre></td></tr></table></figure></p>
<p>这个故事的寓意是，同一个程序可以用长和短、不可读和可读的方式表达。该程序的第一个版本非常晦涩难懂，而最后一个版本几乎是英语版本:记录从1到10的数字的总和。（<code>log</code> the <code>sum</code> of the <code>range</code> of numbers from 1 to 10）</p>
<p>好的编程语言可以通过允许程序员讨论计算机必须在更高的层次上执行的操作来帮助他们。它有助于省略细节，提供方便的积木(如<code>while</code>和<code>console.log</code>)，允许您定义自己的积木(如<code>sum</code>和<code>range</code>)，并使这些块易于组合。</p>
<h2 id="What-is-JavaScript"><a href="#What-is-JavaScript" class="headerlink" title="What is JavaScript?"></a>What is JavaScript?</h2><p>JavaScript是在1995年发布的，用于向Netscape Navigator浏览器中向web页面添加程序。该语言自那时起已被所有其他主要的图形web浏览器所采用。它使现代web应用程序成为可能，你可以直接与之交互，而不必为每个操作重新加载页面。JavaScript也被用于更传统的网站，以提供各种形式的交互性和智能。</p>
<p>值得注意的是，JavaScript与名为Java的编程语言几乎没有任何关系。类似的名字是出于营销考虑，而不是良好的判断。当JavaScript被发布时，Java语言正被大力推广，并且越来越受欢迎。有人认为蹭名字是一个好主意，但现在我们被这个名字困住了。</p>
<p>当JavaScript在Netscape之外的环境被采用之后，一个描述JavaScript的工作方式的标准文档横空出世，以便各种声称支持JavaScript的软件使用的真的是同一种语言。这被称为ECMAScript标准，以执行标准化的Ecma国际组织命名。实际上，ECMAScript和JavaScript可以互换使用，它们是同一种语言的两个名称。</p>
<p>有些人会说JavaScript的坏话。这些事情很多都是真的。当我第一次被要求用JavaScript写东西时，我很快就开始嫌弃它。它几乎可以接受我输入的任何内容，但解释它的方式与我的本意完全不同。当然，这在很大程度上与我不知道自己在做什么有关，但是这里有一个真正的问题:JavaScript在它所允许的方面是非常自由的。这种设计的本意是使初学者更容易使用JavaScript编程。实际上，它主要使在程序中查找问题变得更加困难，因为系统不会向您指出这些问题。</p>
<p>不过，这种灵活性也有其优势。它衍生出了许多在更严格的语言中不可能出现的技巧，正如您将看到的(例如在第10章)，它可以用来克服JavaScript的一些缺点。在正确地学习了这门语言并使用它一段时间之后，我已经学会了真正喜欢JavaScript。</p>
<p>JavaScript有几个版本。ES3在JavaScript逐渐占据主导地位的时期(大约在2000年到2010年之间)得到了广泛支持。在此期间，一个雄心勃勃的版本ES4正在制定，该版本计划对该语言进行一些根本性的改进和扩展。以这样一种激进的方式改变一种被广泛使用的语言，在策略上是行不通的。2008年，ES4的开发工作被放弃，导致第5版的开发远没有那么雄心勃勃，它在2009年只做了一些毫无争议的改进。2015年，ES6发布了，这是一个重大的更新，包括了第4版计划中的一些想法。从那以后，我们每年都可以看到新的小更新。</p>
<p>语言不断发展的事实意味着浏览器必须不断跟进，如果您使用的是较老的浏览器，它可能不支持现有的所有功能。语言设计者必须非常小心，不做任何可能破坏现有程序的更改，因此新浏览器仍然可以运行旧程序。在这本书中，我使用的是2017年版的JavaScript。</p>
<p>Web浏览器并不是唯一使用JavaScript的平台。有些数据库，如MongoDB和CouchDB，使用JavaScript作为脚本和查询语言。桌面和服务器编程的几个平台，尤其是Node.js项目(第20章的主题)，为在浏览器之外编写JavaScript提供了一个环境。</p>
<h2 id="Code-and-what-to-do-with-it"><a href="#Code-and-what-to-do-with-it" class="headerlink" title="Code, and what to do with it"></a>Code, and what to do with it</h2><p>代码是组成程序的文本。这本书的大部分章节都包含了相当多的代码。我认为读代码和写代码是学习编程不可缺少的部分。试着不要只是浏览这些例子，用心阅读并理解它们。这可能在一开始是缓慢和令人困惑的，但我保证你会很快掌握它的窍门。练习也是一样。在你真正写出一个可行的解决方案之前，不要假设你已经理解了它们。</p>
<p>我建议您在实际的JavaScript解释器中尝试您的练习解决方案。这样，你就会得到关于你所做的是否有效的即时反馈，而且，我希望，你会被诱惑去尝试并超越练习。</p>
<p>许多示例都是独立的，应该可以在任何JavaScript环境中工作。但是后面章节中的代码通常是针对特定环境(浏览器或Node.js)编写的，并且只能在那里运行。此外，许多章节定义了更大的程序，其中出现的代码片段相互依赖或依赖于外部文件。网站上的<a href="https://eloquentjavascript.net/code/" target="_blank" rel="noopener">沙箱</a>提供指向Zip文件的链接，其中包含运行给定章节代码所需的所有脚本和数据文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/03/11/译-eloquent-javascript-Introduction/" data-id="ck8n4bmgn000mrsor3v29o6xp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-FCC-Program" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/03/FCC-Program/" class="article-date">
  <time datetime="2019-03-03T01:11:45.000Z" itemprop="datePublished">2019-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/03/FCC-Program/">FCC Program</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="FCC-项目实战-“随机引语生成器”-做后感"><a href="#FCC-项目实战-“随机引语生成器”-做后感" class="headerlink" title="FCC 项目实战 “随机引语生成器” 做后感"></a>FCC 项目实战 “随机引语生成器” 做后感</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>项目来源是 FCC 上的<a href="https://learn.freecodecamp.one/front-end-libraries/front-end-libraries-projects/build-a-random-quote-machine" title="FreeCodeCamp" target="_blank" rel="noopener">“随机引语生成器”</a>，花了两天时间从 0 到接近完成，完成的项目放在 <a href="https://codepen.io/freecodework/pen/moPPmW?editors=0010" title="Random Quote Machine" target="_blank" rel="noopener">CodePen</a></p>
<h3 id="意料之外的地方"><a href="#意料之外的地方" class="headerlink" title="意料之外的地方"></a>意料之外的地方</h3><p>其实应该是我目前才疏学浅，只用到 React 的冰山一角吧，有一些地方让我花了较长时间。</p>
<ol>
<li><p><code>state</code> 在改变之后，不能在同一个 <code>function</code> 里立马就可以调用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            myData: &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    doSomething()&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            myData: &apos;Strings&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        //此处myData依然是 &apos;&apos;</span><br><span class="line">        console.log(this.state.myData); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发生上面情况的原因是：想在组件渲染前，<code>fetch</code> 函数获取的数据传给 <code>state</code> ，并且开始渲染第一次加载的引语。把 <code>fetch</code> 函数放在 <code>componentWillMount()</code> 里，然而这个生命周期函数不久后的版本应该就不会再被采用了。之前本想把数据 <code>fetch</code> 到手就立即渲染到 <code>render</code> 函数里的 <code>{this.state.myData}</code> 之类的，但他们都在<code>componentWillMount()</code> 里，后来想到设置子组件的方法，并且先通过条件渲染，确认了想要的 <code>myData</code> 非空值，才开始渲染子组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; myData &amp;&amp; &lt;Quote/&gt; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 <code>&lt;body/&gt;</code> 的样式时用到的 <code>document.getElementsByTagName（）</code> 等类似方法获取到的是类数组对象，可以用数字索引 <code>[0]</code> 获取。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/03/03/FCC-Program/" data-id="ck8n4bmg10001rsordslanlmb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hexxo-World" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/10/Hexxo-World/" class="article-date">
  <time datetime="2019-02-10T15:37:38.000Z" itemprop="datePublished">2019-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/10/Hexxo-World/">Hexxo World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="在Github-Page上用Hexo搭建博客纪录"><a href="#在Github-Page上用Hexo搭建博客纪录" class="headerlink" title="在Github Page上用Hexo搭建博客纪录"></a>在Github Page上用Hexo搭建博客纪录</h2><h3 id="第一步：本地安装Hexo"><a href="#第一步：本地安装Hexo" class="headerlink" title="第一步：本地安装Hexo"></a>第一步：本地安装Hexo</h3><p>安装命令：<br><code>npm install hexo -g</code></p>
<p>初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<h3 id="第二步：推送至Github-Pages"><a href="#第二步：推送至Github-Pages" class="headerlink" title="第二步：推送至Github Pages"></a>第二步：推送至Github Pages</h3><p>设置根目录<code>_config.yml</code>：</p>
<ul>
<li><p>这样是中文，不写是英文<br><code>language: zh-CN</code></p>
</li>
<li><p><code>url: [Your website address](https://shiftwatchout.github.io/)</code></p>
</li>
<li><p>根目录在哪里，github就写斜杠，有些服务器会多一层路径<br><code>root: /</code></p>
</li>
<li><p>这样可以在 <code>/source</code> 里面放一个 README.md，推送的时候自动传到 Github 上面<br><code>skip_render: README.md</code></p>
</li>
<li><p>换主题<br><code>theme: landscape</code></p>
</li>
<li><p>推送至Github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/ShiftWatchOut/shiftwatchout.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第三步：编辑新文章"><a href="#第三步：编辑新文章" class="headerlink" title="第三步：编辑新文章"></a>第三步：编辑新文章</h3><p>在博客的根目录下才能运行以下命令，创建新article<br><code>hexo new &quot;blog name&quot;</code><br>进入<code>source/_posts</code>文件夹编辑<code>blog-name.MD</code>(空格、加号会变短横)<br>推送代码：<code>hexo g -d</code></p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ol>
<li><code>ERROR Deployer not found: git</code>，处理方法<code>npm install hexo-deployer-git --save</code></li>
</ol>
<blockquote>
<p>参考: <a href="https://hans2936.github.io/2018/06/06/HexoLog/" target="_blank" rel="noopener">Github Pages(三)：使用Hexo博客生成工具</a>、<a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">Mastering Markdown·Github</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/02/10/Hexxo-World/" data-id="ck8n4bmg40003rsori7o6zb11" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-C/" style="font-size: 10px;">C/C++</a> <a href="/tags/Chemistry/" style="font-size: 16.67px;">Chemistry</a> <a href="/tags/ECMAscript/" style="font-size: 20px;">ECMAscript</a> <a href="/tags/Hexo/" style="font-size: 13.33px;">Hexo</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/React/" style="font-size: 13.33px;">React</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/05/Anaconda-VSCode环境搭建/">Anaconda+VSCode环境搭建</a>
          </li>
        
          <li>
            <a href="/2020/03/11/hexo-fatal-error/">hexo fatal error</a>
          </li>
        
          <li>
            <a href="/2020/03/10/译-Styling-React-Native-Apps/">译-Styling React Native Apps</a>
          </li>
        
          <li>
            <a href="/2019/07/14/用VS-Codeb运行其中写好的C-文件/">用VS Codeb运行其中写好的C++文件</a>
          </li>
        
          <li>
            <a href="/2019/06/08/Ubuntu-using/">Ubuntu using</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>