<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>译-eloquent-javascript-Objects | Watchout的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="抽象数据类型是通过编写一种特殊类型的程序来实现的，该程序根据可以对其执行的操作来定义类型。   Barbara Liskov, Programming with Abstract Data Types   第四章介绍了 JavaScript 的对象。在编程文化中，有种称为面向对象编程的东西，一系列使用对象（和相关概念）作为程序组织的核心原则的技术。 虽然没有人真正同意其精确定义，但面向对象编程已">
<meta name="keywords" content="translation,ECMAscript">
<meta property="og:type" content="article">
<meta property="og:title" content="译-eloquent-javascript-Objects">
<meta property="og:url" content="https://shiftwatchout.github.io/2019/05/10/译-eloquent-javascript-Objects/index.html">
<meta property="og:site_name" content="Watchout的博客">
<meta property="og:description" content="抽象数据类型是通过编写一种特殊类型的程序来实现的，该程序根据可以对其执行的操作来定义类型。   Barbara Liskov, Programming with Abstract Data Types   第四章介绍了 JavaScript 的对象。在编程文化中，有种称为面向对象编程的东西，一系列使用对象（和相关概念）作为程序组织的核心原则的技术。 虽然没有人真正同意其精确定义，但面向对象编程已">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://eloquentjavascript.net/img/chapter_picture_6.jpg">
<meta property="og:image" content="http://eloquentjavascript.net/img/rabbits.svg">
<meta property="og:updated_time" content="2020-04-12T13:40:17.386Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="译-eloquent-javascript-Objects">
<meta name="twitter:description" content="抽象数据类型是通过编写一种特殊类型的程序来实现的，该程序根据可以对其执行的操作来定义类型。   Barbara Liskov, Programming with Abstract Data Types   第四章介绍了 JavaScript 的对象。在编程文化中，有种称为面向对象编程的东西，一系列使用对象（和相关概念）作为程序组织的核心原则的技术。 虽然没有人真正同意其精确定义，但面向对象编程已">
<meta name="twitter:image" content="http://eloquentjavascript.net/img/chapter_picture_6.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Watchout的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Watchout的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shiftwatchout.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-译-eloquent-javascript-Objects" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/10/译-eloquent-javascript-Objects/" class="article-date">
  <time datetime="2019-05-10T14:56:11.000Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      译-eloquent-javascript-Objects
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>抽象数据类型是通过编写一种特殊类型的程序来实现的，该程序根据可以对其执行的操作来定义类型。   Barbara Liskov, <em>Programming with Abstract Data Types</em></p>
</blockquote>
<p><img src="http://eloquentjavascript.net/img/chapter_picture_6.jpg" alt="img"></p>
<p>第四章介绍了 JavaScript 的对象。在编程文化中，有种称为面向对象编程的东西，一系列使用对象（和相关概念）作为程序组织的核心原则的技术。</p>
<p>虽然没有人真正同意其精确定义，但面向对象编程已经塑造了许多编程语言的设计，包括JavaScript。本章将介绍这些想法在JavaScript中的应用方式。</p>
<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>面向对象编程的核心思想是将程序划分为更小的部分，并使每个部分负责管理自己的状态。</p>
<p>这样，关于程序的一部分工作方式的信息就可以保留在该部分的本地。开发程序其余部分的人不必记住甚至了解这些信息。每当这些本地细节发生变化时，只需要更新其周围的代码。</p>
<p>这样的程序的不同部分通过接口彼此交互，提供有限的函数或绑定，这些函数或绑定在更抽象的级别提供有用的功能，隐藏它们的完整实现。</p>
<p>这类程序使用对象建模。它们的接口由一组特定的方法和属性组成。暴露在该接口的属性称为 <em>public</em> 。外部代码无法获取的其他内容称为 <em>private</em>。</p>
<p>许多语言提供了区分公共和私有属性的方法，并完全阻止外部代码访问私有属性。JavaScript，再一次采用极简主义的方法，还没有–至少现在没有区分公私变量。将其添加到该语言中的工作正在进行。（译者注：T39 委员会已于2018年10月将“#”作为表示私有变量的标记）</p>
<p>尽管语言没有内置这种区别，JavaScript 程序员却也成功地使用了这种想法。往往，可用的接口被描述在文档或注释中。在属性名称的开头加上下划线（_）字符以表示这些属性是私有的也很常见的。</p>
<p>将接口与实现分离是一个绝妙的主意，这被叫做<em>封装</em>。</p>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>方法只不过是将函数作为值保存的属性。下面是一个简单的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let rabbit = &#123;&#125;;</span><br><span class="line">rabbit.speak = function(line) &#123;</span><br><span class="line">console.log(`The rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.speak(&quot;I&apos;m alive.&quot;);</span><br><span class="line">// → The rabbit says &apos;I&apos;m alive.&apos;</span><br></pre></td></tr></table></figure>
<p>通常，方法需要对调用它的对象执行某些操作。当一个函数作为一个方法被调用–作为一个属性并被立即调用时，就像在<code>object.method()</code>中一样 - 在它的函数体中的<code>this</code>绑定会自动指向它被调用的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function speak(line) &#123;</span><br><span class="line">console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;</span><br><span class="line">let whiteRabbit = &#123;type: &quot;white&quot;, speak&#125;;</span><br><span class="line">let hungryRabbit = &#123;type: &quot;hungry&quot;, speak&#125;;</span><br><span class="line"></span><br><span class="line">whiteRabbit.speak(&quot;Oh my ears and whiskers, &quot; + &quot;how late it&apos;s getting!&quot;);</span><br><span class="line">// → The white rabbit says &apos;Oh my ears and whiskers, how</span><br><span class="line">//   late it&apos;s getting!&apos;</span><br><span class="line">hungryRabbit.speak(&quot;I could use a carrot right now.&quot;);</span><br><span class="line">// → The hungry rabbit says &apos;I could use a carrot right now.&apos;</span><br></pre></td></tr></table></figure>
<p>你可以将<code>this</code>视为以隐蔽方式传入的额外参数。如果要显式传递它，可以使用函数的<code>call</code>方法，该方法将传入的第一个参数作为其<code>this</code>值，并将其他参数视为普通参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">speak.call(hungryRabbit, &quot;Burp!&quot;);</span><br><span class="line">// → The hungry rabbit says &apos;Burp!&apos;</span><br></pre></td></tr></table></figure>
<p>由于每个函数都有自己的<code>this</code>绑定，其值取决于它的调用方式，因此不能在使用<code>function</code>关键字定义的常规函数中引用包装作用域。</p>
<p>箭头函数则不同的–它们不绑定它们自己的<code>this</code>，但可以看到它们邻近作用域的<code>this</code>绑定。因此，你可以执行类似以下代码的操作，该代码从本地函数内部引用<code>this</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function normalize() &#123;</span><br><span class="line">    console.log(this.coords.map(n =&gt; n / this.length));</span><br><span class="line">&#125;</span><br><span class="line">normalize.call(&#123;coords: [0, 2, 3], length: 5&#125;);</span><br><span class="line">// → [0, 0.4, 0.6]</span><br></pre></td></tr></table></figure>
<p>如果我在使用了<code>function</code>关键字的<code>map</code>函数里写了参数，代码将无法运行。</p>
<h3 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h3><p>仔细看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let empty = &#123;&#125;;</span><br><span class="line">console.log(empty.toString);</span><br><span class="line">// → function toString()&#123;…&#125;</span><br><span class="line">console.log(empty.toString());</span><br><span class="line">// → [object Object]</span><br></pre></td></tr></table></figure>
<p>我从空对象里提出来一个属性。嗒当！</p>
<p>好吧，非也。我只是隐瞒了有关 JavaScript 对象工作方式的信息。除了自身属性外，大多数对象还有一个<em>原型</em>。原型是另一个用作属性后备源的对象。当一个对象获得一个它没有的属性的请求时，将会去它的原型那里搜索属性，然后是原型的原型，依此类推。</p>
<p>那么谁是那个空对象的原型？ 它是伟大的祖先原型，几乎所有对象背后的实体，<code>Object.prototype</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(&#123;&#125;) == Object.prototype);</span><br><span class="line">// → true</span><br><span class="line">console.log(Object.getPrototypeOf(Object.prototype));</span><br><span class="line">// → null</span><br></pre></td></tr></table></figure>
<p>如你所料，<code>Object.getPrototypeOf</code>返回对象原型。</p>
<p>JavaScript 对象的原型关系形成一个树形结构，在这个结构的根部是<code>Object.prototype</code>。它提供了一些所有对象中都可用的方法，例如<code>toString</code>，它将对象转换为字符串形式。</p>
<p>许多对象不直接将<code>Object.prototype</code>作为其原型，而是使用另一个对象来提供不同的默认属性集。函数派生自<code>Function.prototype</code>，数组派生自<code>Array.prototype</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(Math.max) ==</span><br><span class="line">            Function.prototype);</span><br><span class="line">// → true</span><br><span class="line">console.log(Object.getPrototypeOf([]) ==</span><br><span class="line">            Array.prototype);</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure>
<p>这样的原型对象本身就有一个原型，通常是<code>Object.prototype</code>，所以它仍然间接提供像<code>toString</code>这样的方法。</p>
<p>你可以使用<code>Object.create</code>创建具有特定原型的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let protoRabbit = &#123;</span><br><span class="line">speak(line) &#123;</span><br><span class="line">    console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let killerRabbit = Object.create(protoRabbit);</span><br><span class="line">killerRabbit.type = &quot;killer&quot;;</span><br><span class="line">killerRabbit.speak(&quot;SKREEEE!&quot;);</span><br><span class="line">// → The killer rabbit says &apos;SKREEEE!&apos;</span><br></pre></td></tr></table></figure>
<p>对象表达式中的<code>speak(line)</code>属性是定义方法的简便方法。它创建了一个名为<code>speak</code>的属性，并赋予它一个函数作为其值。</p>
<p>“proto”兔子充当所有兔子共有的属性的容器。像杀手兔一样，每个兔子对象包含仅适用于自身的属性–在这种情况下是其类型–且其共享属性派生自原型。</p>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>JavaScript的原型系统可以被解释为对面向对象的概念（称为类）的一种非正式的实现。类定义了一种对象的内容–它具有哪些方法和属性。这样的对象称为类的<em>实例</em>。</p>
<p>原型可用于定义类的所有实例共享相同值的属性，例如方法。而每个实例中不同的属性，例如我们的兔子<code>type</code>属性，需要直接存储在对象本身中。</p>
<p>因此，要创建给定类的实例，你必须创建一个派生自适当原型的对象，但你还必须确保它本身具有此类实例应具有的属性。这是构造函数的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function makeRabbit(type) &#123;</span><br><span class="line">  let rabbit = Object.create(protoRabbit);</span><br><span class="line">  rabbit.type = type;</span><br><span class="line">  return rabbit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript提供了一种使定义此类函数更容易的方法。如果将关键字  <code>new</code>放在函数调用前面，则该函数将被视为构造函数。这意味着具有正确原型的对象将自动创建，在函数中绑定<code>this</code>，并在函数末尾返回。</p>
<p>构造对象时使用的原型对象是通过获取构造函数的<code>prototype</code>属性来找到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Rabbit(type) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype.speak = function(line) &#123;</span><br><span class="line">  console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let weirdRabbit = new Rabbit(&quot;weird&quot;);</span><br></pre></td></tr></table></figure>
<p>构造函数（实际上所有函数）自动获得一个名为<code>prototype</code>的属性，该属性默认包含一个从<code>Object.prototype</code>派生的普通空对象。如果需要，我们可以使用新对象覆盖它。或者，你可以向现有对象添加属性，如示例所示。</p>
<p>按照惯例，构造函数的名称需要大写，以便可以很容易地将它们与其他自定义函数区分开来。</p>
<p>重要的是要理解 原型与构造函数（通过其原型属性）相关联的方式，和 对象具有原型的方式（可以使用<code>Object.getPrototypeOf</code>查看）之间的区别。构造函数的实际原型是<code>Function.prototype</code>，因为构造函数是函数，它的原型属性包含用于通过它创建的实例的原型。</p>
<h3 id="Class-notation"><a href="#Class-notation" class="headerlink" title="Class notation"></a>Class notation</h3><p>所以 JavaScript 的类其实是带有<code>prototype</code>属性的构造函数。这就是他们之前的工作方式，直到2015年，这就是你编写类的方式。现在，我们有一个不那么尴尬的表示法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Rabbit &#123;</span><br><span class="line">  constructor(type) &#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  speak(line) &#123;</span><br><span class="line">    console.log(`The $&#123;this.type&#125; rabbit says &apos;$&#123;line&#125;&apos;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let killerRabbit = new Rabbit(&quot;killer&quot;);</span><br><span class="line">let blackRabbit = new Rabbit(&quot;black&quot;);</span><br></pre></td></tr></table></figure>
<p><code>class</code>关键字表示开始一个类声明，它允许我们在其中定义一个构造函数和一组方法。可以在声明的大括号内写入任意数量的方法。一个名为<code>constructor</code>的被作特殊处理。它提供了实际的构造函数，它将绑定到名称<code>Rabbit</code>。其他人被打包到该构造函数的原型中。因此，早期的类声明等同于上一节中的构造函数定义。它仅仅是看起来更优雅。</p>
<p>与函数类似，类可以在语句和表达式中使用。当用作表达式时，它不定义绑定，而只是将构造函数作为值生成。你可以在类表达式中省略类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let object = new class &#123; getWord() &#123; return &quot;hello&quot;; &#125; &#125;;</span><br><span class="line">console.log(object.getWord());</span><br><span class="line">// → hello</span><br></pre></td></tr></table></figure>
<h3 id="Overriding-derived-properties"><a href="#Overriding-derived-properties" class="headerlink" title="Overriding derived properties"></a>Overriding derived properties</h3><p>当你向对象添加属性时，无论它是否存在于原型中，该属性都会添加到对象自身。如果原型中已存在具有相同名称的属性，则该属性将不再影响这个得到新属性的对象，因为它现在已经隐藏在对象自身的属性后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.teeth = &quot;small&quot;;</span><br><span class="line">console.log(killerRabbit.teeth);</span><br><span class="line">// → small</span><br><span class="line">killerRabbit.teeth = &quot;long, sharp, and bloody&quot;;</span><br><span class="line">console.log(killerRabbit.teeth);</span><br><span class="line">// → long, sharp, and bloody</span><br><span class="line">console.log(blackRabbit.teeth);</span><br><span class="line">// → small</span><br><span class="line">console.log(Rabbit.prototype.teeth);</span><br><span class="line">// → small</span><br></pre></td></tr></table></figure>
<p>下图概述了此代码运行后的情况。<code>Rabbit</code>和<code>Object</code>原型位于<code>killerRabbit</code>之后，作为一种背景，可以查找对象在自身找不到的属性。</p>
<p><img src="http://eloquentjavascript.net/img/rabbits.svg" alt="img"></p>
<p>覆盖原型中存在的属性可能是一件有用的事情。正如示例中兔子牙齿所示，覆盖可用于在更通用的对象类的实例中表达异常属性，同时让非异常对象从其原型中获取标准值。</p>
<p>覆盖也用于为标准函数和数组原型提供与基本对象原型不同的toString方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.prototype.toString == Object.prototype.toString);</span><br><span class="line">// → false</span><br><span class="line">console.log([1, 2].toString());</span><br><span class="line">// → 1,2</span><br></pre></td></tr></table></figure>
<p>在数组上调用<code>toString</code>会产生类似于在其上调用<code>.join（“，”）</code>的结果–它在数组中的值之间放置逗号。直接使用数组调用Object.prototype.toString会产生不同的字符串。该函数不知道数组，因此它只是将单词object和类型名称放在方括号之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call([1, 2]));</span><br><span class="line">// → [object Array]</span><br></pre></td></tr></table></figure>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p>我们在前一章中看到了一个用于通过将函数应用于其元素来转换数据结构的操作。令人困惑的是，在编程中，相同的单词也用于相关但差异相当大的东西。</p>
<p><code>map</code>（名词）是将值（键key）与其他值相关联的数据结构。例如，你可能希望将名称映射到年龄。你可能会为此使用对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let ages = &#123;</span><br><span class="line">  Boris: 39,</span><br><span class="line">  Liang: 22,</span><br><span class="line">  Júlia: 62</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(`Júlia is $&#123;ages[&quot;Júlia&quot;]&#125;`);</span><br><span class="line">// → Júlia is 62</span><br><span class="line">console.log(&quot;Is Jack&apos;s age known?&quot;, &quot;Jack&quot; in ages);</span><br><span class="line">// → Is Jack&apos;s age known? false</span><br><span class="line">console.log(&quot;Is toString&apos;s age known?&quot;, &quot;toString&quot; in ages);</span><br><span class="line">// → Is toString&apos;s age known? true</span><br></pre></td></tr></table></figure>
<p>这里，对象的属性名称是人名，属性值是他们的年龄。但我们当然没有在对象中列出任何名为<code>toString</code>的人。然而，因为普通对象派生自<code>Object.prototype</code>，所以<code>toSting</code>属性就在那里。</p>
<p>因此，使用普通对象作为地图是危险的。有几种方法可以避免这个问题。首先，可以创建任何没有原型的对象。如果将null传递给<code>Object.create</code>，则生成的对象将不会从<code>Object.prototype</code>派生，并且可以安全地用作映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;toString&quot; in Object.create(null));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<p>对象属性名称必须是字符串。如果你需要一个其键无法轻松转换为字符串的映射（如对象），可是无法使用对象作为你自定义的映射的键。</p>
<p>幸运的是，JavaScript 附带了一个名为<code>Map</code>的类，它是为了这个目的而诞生的。它存储映射并允许任何类型的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let ages = new Map();</span><br><span class="line">ages.set(&quot;Boris&quot;, 39);</span><br><span class="line">ages.set(&quot;Liang&quot;, 22);</span><br><span class="line">ages.set(&quot;Júlia&quot;, 62);</span><br><span class="line"></span><br><span class="line">console.log(`Júlia is $&#123;ages.get(&quot;Júlia&quot;)&#125;`);</span><br><span class="line">// → Júlia is 62</span><br><span class="line">console.log(&quot;Is Jack&apos;s age known?&quot;, ages.has(&quot;Jack&quot;));</span><br><span class="line">// → Is Jack&apos;s age known? false</span><br><span class="line">console.log(ages.has(&quot;toString&quot;));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<p>方法<code>set</code>，<code>get</code>和<code>has</code>是<code>Map</code>对象接口的一部分。编写可以快速更新和搜索大量值的数据结构并不容易，但我们不必为此担心。有人已经为我们做了，我们可以通过这个简单的接口来使用他们提供的成就。</p>
<p>如果你确实因为某种原因需要将一个普通的对象视为一个映射，那么就有必要了解到<code>Object.keys</code>只返回对象自己的键值，而不是原型中的那些键。作为<code>in</code>运算符的替代，你可以使用<code>hasOwnProperty</code>方法，该方法忽略对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;x: 1&#125;.hasOwnProperty(&quot;x&quot;));</span><br><span class="line">// → true</span><br><span class="line">console.log(&#123;x: 1&#125;.hasOwnProperty(&quot;toString&quot;));</span><br><span class="line">// → false</span><br></pre></td></tr></table></figure>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>当你在对象上调用<code>String</code>函数（将值转换为字符串）时，它将调用该对象上的<code>toString</code>方法以尝试从中创建有意义的字符串。我提到过一些标准原型定义了他们的<code>toString</code>方法，因此他们可以创建一个比<code>“[object Object]”</code>包含更多的信息的字符串。你也可以自己实现一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.toString = function() &#123;</span><br><span class="line">  return `a $&#123;this.type&#125; rabbit`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(String(blackRabbit));</span><br><span class="line">// → a black rabbit</span><br></pre></td></tr></table></figure>
<p>这是一个强大的想法的简单实例。当编写一段代码来处理具有特定接口的对象时–在上面的例子里是<code>toString</code>方法–任何支持此接口的对象都可以接入到代码中，它都可以正常工作。</p>
<p>这种技术称为“多态”。多态代码可以使用不同形式的值，只要它们支持它所期望的接口即可。</p>
<p>我在第4章中提到过<code>for...of...</code>循环可以遍历几种数据结构。这是多态的另一种情况–这种循环期望数据结构暴露特定接口，数组和字符串都是这样做的。我们还可以将这类接口添加到你自己的对象中！ 但在我们这样做之前，我们需要知道 symbol 是什么。</p>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>多个接口可以针对不同的事物使用相同的属性名称。例如，我可以定义一个接口，其中<code>toString</code>方法应该将对象转换为一段纱线。对象不可能同时满足该接口和<code>toString</code>的标准用法。</p>
<p>这不是一个坏主意，这个问题并不常见。大多数 JavaScript 程序员根本就没有考虑过这种问题。但这门语言的设计者，无论如何都要考虑这些东西的人，为我们提供了解决方案。</p>
<p>当我说属性名称是字符串时，这并不完全准确。它们通常是，但它们也可以是 symbol。symbol 是使用<code>Symbol</code>函数创建的值。与字符串不同，新创建的 symbol 是唯一的，即你不能两次创建相同的 symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(&quot;name&quot;);</span><br><span class="line">console.log(sym == Symbol(&quot;name&quot;));</span><br><span class="line">// → false</span><br><span class="line">Rabbit.prototype[sym] = 55;</span><br><span class="line">console.log(blackRabbit[sym]);</span><br><span class="line">// → 55</span><br></pre></td></tr></table></figure>
<p>当你将其转换为字符串时，会包含之前传递给<code>Symbol</code>的字符串，并且可以在控制台中显示 symbol 时更容易识别 symbol。但它没有任何含义–多个符号可能具有相同的名称。</p>
<p>既独一无二又可用作属性名称，使得 symbol 适用于定义可与其他属性并存的接口，无论它们的名称是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const toStringSymbol = Symbol(&quot;toString&quot;);</span><br><span class="line">Array.prototype[toStringSymbol] = function() &#123;</span><br><span class="line">  return `$&#123;this.length&#125; cm of blue yarn`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log([1, 2].toString());</span><br><span class="line">// → 1,2</span><br><span class="line">console.log([1, 2][toStringSymbol]());</span><br><span class="line">// → 2 cm of blue yarn</span><br></pre></td></tr></table></figure>
<p>通过在属性名称周围使用方括号，可以在对象表达式和类中包含 symbol 属性。就像方括号属性访问表示法一样，将会对属性名称进行求值，因此它允许我们引用包含 symbol 的绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let stringObject = &#123;</span><br><span class="line">  [toStringSymbol]() &#123; return &quot;a jute rope&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(stringObject[toStringSymbol]());</span><br><span class="line">// → a jute rope</span><br></pre></td></tr></table></figure>
<h3 id="The-iterator-interface"><a href="#The-iterator-interface" class="headerlink" title="The iterator interface"></a>The iterator interface</h3><p>赋予<code>for...of...</code>循环的对象应该是可迭代的。这意味着它有一个用<code>Symbol.iterator</code>符号命名的方法（由语言定义的符号值，存储为<code>Symbol</code>函数的属性）。</p>
<p>被调用时，该方法应该返回一个提供第二个接口：迭代器，的对象。这是迭代的实际内容。它有个返回下一个结果的<code>next</code>方法。该结果应该是一个具有<code>value</code>属性的对象，该属性提供下一个值（如果有）和<code>done</code>属性，当没有更多结果时<code>done</code>应该为<code>true</code>，否则为<code>false</code>。</p>
<p>请注意，<code>next</code>，<code>value</code>和<code>done</code>属性名称是纯字符串，而不是 symbol。只有能添加到许多不同对象的<code>Symbol.iterator</code>才是真正的 symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let okIterator = &quot;OK&quot;[Symbol.iterator]();</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: &quot;O&quot;, done: false&#125;</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: &quot;K&quot;, done: false&#125;</span><br><span class="line">console.log(okIterator.next());</span><br><span class="line">// → &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>让我们实现一个可迭代的数据结构。我们将构建一个 martrix 类，充当二维数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Matrix &#123;</span><br><span class="line">  constructor(width, height, element = (x, y) =&gt; undefined) &#123;</span><br><span class="line">    this.width = width;</span><br><span class="line">    this.height = height;</span><br><span class="line">    this.content = [];</span><br><span class="line"></span><br><span class="line">    for (let y = 0; y &lt; height; y++) &#123;</span><br><span class="line">      for (let x = 0; x &lt; width; x++) &#123;</span><br><span class="line">        this.content[y * width + x] = element(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(x, y) &#123;</span><br><span class="line">    return this.content[y * this.width + x];</span><br><span class="line">  &#125;</span><br><span class="line">  set(x, y, value) &#123;</span><br><span class="line">    this.content[y * this.width + x] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类将其内容存储在含有 width × height 个元素的单个数组中。元素是逐行存储的，因此，例如，第五行中的第三个元素是（使用从零开始的索引）存储在位置 4 × 宽 + 2。</p>
<p>构造函数采用<code>width</code>，<code>height</code>和可选<code>element</code>函数，用于填充初始值。有<code>get</code>和<code>set</code>方法来检索和更新矩阵中的元素。</p>
<p>在循环遍历矩阵时，你也许会对元素的位置以及元素本身感兴趣，因此我们将使用迭代器生成具有<code>x</code>，<code>y</code>和<code>value</code>属性的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MatrixIterator &#123;</span><br><span class="line">  constructor(matrix) &#123;</span><br><span class="line">    this.x = 0;</span><br><span class="line">    this.y = 0;</span><br><span class="line">    this.matrix = matrix;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    if (this.y == this.matrix.height) return &#123;done: true&#125;;</span><br><span class="line"></span><br><span class="line">    let value = &#123;x: this.x,</span><br><span class="line">                 y: this.y,</span><br><span class="line">                 value: this.matrix.get(this.x, this.y)&#125;;</span><br><span class="line">    this.x++;</span><br><span class="line">    if (this.x == this.matrix.width) &#123;</span><br><span class="line">      this.x = 0;</span><br><span class="line">      this.y++;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;value, done: false&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类通过<code>x</code>和<code>y</code>属性跟踪迭代矩阵的过程。<code>next</code>方法首先检查是否已到达矩阵的底部。如果没有，则首先创建保存当前值的对象，然后更新其位置，如果可以的话移动到下一行。</p>
<p>让我们将<code>Matrix</code>类变成可迭代的。在本书中，我偶尔会使用“马后炮”一样的原型操作来向类添加方法，以便各个代码段保持短小并各自独立。在日常编程中，不需要将代码拆分成小块，而是直接在类中声明这些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Matrix.prototype[Symbol.iterator] = function() &#123;</span><br><span class="line">  return new MatrixIterator(this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>for...of...</code>来遍历矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let matrix = new Matrix(2, 2, (x, y) =&gt; `value $&#123;x&#125;,$&#123;y&#125;`);</span><br><span class="line">for (let &#123;x, y, value&#125; of matrix) &#123;</span><br><span class="line">  console.log(x, y, value);</span><br><span class="line">&#125;</span><br><span class="line">// → 0 0 value 0,0</span><br><span class="line">// → 1 0 value 1,0</span><br><span class="line">// → 0 1 value 0,1</span><br><span class="line">// → 1 1 value 1,1</span><br></pre></td></tr></table></figure>
<h3 id="Getters-setters-and-statics"><a href="#Getters-setters-and-statics" class="headerlink" title="Getters, setters, and statics"></a>Getters, setters, and statics</h3><p>接口通常由函数方法组成，但也可以包含保存非函数值的属性。例如，<code>Map</code>对象具有一个<code>size</code>属性，可以告诉你存储了多少个键。</p>
<p>这样的对象甚至不需要直接在实例中计算和存储这样的属性。即使是直接访问的属性也可能有潜在的函数调用。这些方法称为getter，它们是通过在对象表达式或类声明中的方法名称前写<code>get</code>来定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let varyingSize = &#123;</span><br><span class="line">  get size() &#123;</span><br><span class="line">    return Math.floor(Math.random() * 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(varyingSize.size);</span><br><span class="line">// → 73</span><br><span class="line">console.log(varyingSize.size);</span><br><span class="line">// → 49</span><br></pre></td></tr></table></figure>
<p>只要有人从此对象的<code>size</code>属性中读取，就会调用关联的方法。使用<code>setter</code>写入属性时，你可以执行类似的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Temperature &#123;</span><br><span class="line">  constructor(celsius) &#123;</span><br><span class="line">    this.celsius = celsius;</span><br><span class="line">  &#125;</span><br><span class="line">  get fahrenheit() &#123;</span><br><span class="line">    return this.celsius * 1.8 + 32;</span><br><span class="line">  &#125;</span><br><span class="line">  set fahrenheit(value) &#123;</span><br><span class="line">    this.celsius = (value - 32) / 1.8;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static fromFahrenheit(value) &#123;</span><br><span class="line">    return new Temperature((value - 32) / 1.8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let temp = new Temperature(22);</span><br><span class="line">console.log(temp.fahrenheit);</span><br><span class="line">// → 71.6</span><br><span class="line">temp.fahrenheit = 86;</span><br><span class="line">console.log(temp.celsius);</span><br><span class="line">// → 30</span><br></pre></td></tr></table></figure>
<p><code>Temperature</code>类允许你以摄氏度或华氏度读取和写入温度，但在内部它仅存储摄氏度并自动在<code>fahrenheit</code> getter 和 setter 中转换为摄氏温度。</p>
<p>有时你希望将一些属性直接附加到构造函数，而不是原型。此类方法无法访问类实例，但可以用于提供创建实例的其他方法。</p>
<p>在类声明中，在名称之前写有<code>static</code>的方法存储在构造函数中。因此，<code>Temperature</code>类允许你编写<code>Temperature.fromFahrenheit（100）</code>以使用华氏度创建温度。</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>已知一些矩阵是对称的。如果以左上角到右下角的对角线镜像反转这种矩阵，它将保持不变。换句话说，存储在x，y的值总是与y，x处的值相同。</p>
<p>假设我们需要一个像 Matrix 这样的数据结构，但却强制要求矩阵是对称的。我们可以从头开始编写它，但这将涉及重复一些与我们已编写的代码非常相似的代码。</p>
<p>JavaScript 的原型系统可以创建一个就像旧类一样的新类，但是对它的一些属性可以重新定义。新类的原型来自旧的原型，但为<code>set</code>方法添加了新的定义。</p>
<p>在面向对象的编程术语中，这称为继承。新类继承旧类的属性和行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SymmetricMatrix extends Matrix &#123;</span><br><span class="line">  constructor(size, element = (x, y) =&gt; undefined) &#123;</span><br><span class="line">    super(size, size, (x, y) =&gt; &#123;</span><br><span class="line">      if (x &lt; y) return element(y, x);</span><br><span class="line">      else return element(x, y);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(x, y, value) &#123;</span><br><span class="line">    super.set(x, y, value);</span><br><span class="line">    if (x != y) &#123;</span><br><span class="line">      super.set(y, x, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let matrix = new SymmetricMatrix(5, (x, y) =&gt; `$&#123;x&#125;,$&#123;y&#125;`);</span><br><span class="line">console.log(matrix.get(2, 3));</span><br><span class="line">// → 3,2</span><br></pre></td></tr></table></figure>
<p>使用关键词<code>extends</code>表示此类不应直接基于默认的<code>Object</code>原型，而应基于其他类。这被称为超类，由它派生出的类叫子类。</p>
<p>要初始化<code>SymmetricMatrix</code>实例，构造函数通过<code>super</code>关键字调用其超类的构造函数。如果想要这个新对象的行为（大致）类似于Matrix，那么这是必要的，它将需要矩阵具有的实例属性。为了确保矩阵是对称的，构造函数包装<code>element</code>函数以交换对角线下方的值的坐标。</p>
<p><code>set</code>方法再次使用<code>super</code>，但这次不是调用构造函数，而是从超类的方法集调用特定方法。我们正在重新定义<code>set</code>但确实想要使用原始行为。因为<code>this.set</code>引用的是新的<code>set</code>方法，所以调用它不起作用。在类内部方法中，<code>super</code>提供了一种调用方法的方法，能以它们在超类中定义的形式调用。</p>
<p>继承允许我们使用相对较少的工作基于现有数据类型构建稍微不同的数据类型。它是面向对象传统的基本组成部分，包括封装和多态。在现在，后两者普遍被视为绝妙的想法，但继承更具争议性。</p>
<p>封装和多态可以用来将代码片段彼此分开，减少整个程序的纠缠，而继承从根本上将类连接在一起，创造更多的纠缠。从类继承时，你通常必须比仅使用它更多地了解它的工作原理。继承可以是一个有用的工具，我现在在我自己的程序中使用它，但它不应该是你第一个想到使用的工具，你可能不会乐意寻找机会来构建类层次结构（家庭树类）。</p>
<h3 id="The-instanceof-operator"><a href="#The-instanceof-operator" class="headerlink" title="The instanceof operator"></a>The instanceof operator</h3><p>有时知道对象是否来自特定类是有用的。为此，JavaScript 提供了一个名为<code>instanceof</code>的二元运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new SymmetricMatrix(2) instanceof SymmetricMatrix);</span><br><span class="line">// → true</span><br><span class="line">console.log(new SymmetricMatrix(2) instanceof Matrix);</span><br><span class="line">// → true</span><br><span class="line">console.log(new Matrix(2, 2) instanceof SymmetricMatrix);</span><br><span class="line">// → false</span><br><span class="line">console.log([1] instanceof Array);</span><br><span class="line">// → true</span><br></pre></td></tr></table></figure>
<p>运算符将查看继承的类型，因此<code>SymmetricMatrix</code>是<code>Matrix</code>的实例。运算符也可以应用于像<code>Array</code>这样的标准构造函数。几乎每个对象都是<code>Object</code>的一个实例。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>所以对象不只是拥有自己的属性。他们有原型，是其他对象。只要他们的原型具有该属性，他们将表现得好像他们拥有他们没有的属性。简单对象将<code>Object.prototype</code>作为其原型。</p>
<p>构造函数是名称通常以大写字母开头的函数，可以与<code>new</code>操作符一起使用来创建新对象。新对象的原型将是构造函数的<code>prototype</code>属性中找到的对象。你可以充分利用这一点，将所有给定对象都要共享的属性放入其原型中。有一个<code>class</code>的声明方式，提供了一种用来定义构造函数及其原型的简明的方法。</p>
<p>每次访问对象的属性时，你都可以定义 getter 和 setter 以隐蔽地调用方法。静态方法是存储在类的构造函数中的方法，而不是其原型。</p>
<p>传入参数为对象和构造函数，<code>instanceof</code>运算符可以告诉你该对象是否是该构造函数的实例。</p>
<p>对象的一个有用的事情是为它们指定一个接口，并告诉每个人他们应该只通过该接口与你的对象交互。构成对象的其余细节现在已封装，隐藏在接口之后。</p>
<p>多个类型可以实现相同的接口。为使用接口而编写的代码知道如何与提供接口的任意数量的不同对象交互。这称为多态性。</p>
<p>当实现仅在某些细节上有所不同的多个类时，将新类编写为现有类的子类，继承其部分行为可能会有所帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shiftwatchout.github.io/2019/05/10/译-eloquent-javascript-Objects/" data-id="ck8x5rjac000lgsorn0237jrg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/translation/">translation</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/08/译-Cargo-Sorting-DNA-Robot/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          译-Cargo Sorting DNA Robot
        
      </div>
    </a>
  
  
    <a href="/2019/04/14/译-Biomass-Gasification/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Biomass Gasification</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chemistry/">Chemistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAscript/">ECMAscript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/translation/">translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/">vscode</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Chemistry/" style="font-size: 15px;">Chemistry</a> <a href="/tags/ECMAscript/" style="font-size: 17.5px;">ECMAscript</a> <a href="/tags/Hexo/" style="font-size: 12.5px;">Hexo</a> <a href="/tags/Python/" style="font-size: 12.5px;">Python</a> <a href="/tags/React/" style="font-size: 12.5px;">React</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/translation/" style="font-size: 20px;">translation</a> <a href="/tags/vscode/" style="font-size: 12.5px;">vscode</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/12/Git-学习/">Git 学习</a>
          </li>
        
          <li>
            <a href="/2020/04/06/pandas-读取Excel/">pandas 处理 Excel</a>
          </li>
        
          <li>
            <a href="/2020/04/05/Anaconda-VSCode环境搭建/">Anaconda+VSCode环境搭建</a>
          </li>
        
          <li>
            <a href="/2020/03/11/hexo-fatal-error/">hexo fatal error</a>
          </li>
        
          <li>
            <a href="/2020/03/10/译-Styling-React-Native-Apps/">译-Styling React Native Apps</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Watch Out<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>